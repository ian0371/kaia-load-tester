// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package auction

import (
	"errors"
	"math/big"
	"strings"

	"github.com/kaiachain/kaia"
	"github.com/kaiachain/kaia/accounts/abi"
	"github.com/kaiachain/kaia/accounts/abi/bind"
	"github.com/kaiachain/kaia/blockchain/types"
	"github.com/kaiachain/kaia/common"
	"github.com/kaiachain/kaia/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = kaia.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// IAuctionEntryPointAuctionTx is an auto generated low-level Go binding around an user-defined struct.
type IAuctionEntryPointAuctionTx struct {
	TargetTxHash  [32]byte
	BlockNumber   *big.Int
	Sender        common.Address
	To            common.Address
	Nonce         *big.Int
	Bid           *big.Int
	CallGasLimit  *big.Int
	Data          []byte
	SearcherSig   []byte
	AuctioneerSig []byte
}

// IRegistryRecord is an auto generated low-level Go binding around an user-defined struct.
type IRegistryRecord struct {
	Addr       common.Address
	Activation *big.Int
}

// AuctionDepositVaultMetaData contains all meta data concerning the AuctionDepositVault contract.
var AuctionDepositVaultMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_auctionFeeVault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EmptyDepositVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinDepositNotOver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAuctionDepositVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyEntryPoint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyProposer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyStakingAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawReservationExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalNotAllowedYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroDepositAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeeVault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeVault\",\"type\":\"address\"}],\"name\":\"ChangeAuctionFeeVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ChangeMinDepositAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLocktime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLocktime\",\"type\":\"uint256\"}],\"name\":\"ChangeMinWithdrawLocktime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TakenBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TakenBidFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasAmount\",\"type\":\"uint256\"}],\"name\":\"TakenGas\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasAmount\",\"type\":\"uint256\"}],\"name\":\"TakenGasFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"VaultDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"VaultReserveWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"VaultWithdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"REGISTRY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionFeeVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAuctionFeeVault\",\"type\":\"address\"}],\"name\":\"changeAuctionFeeVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinAmount\",\"type\":\"uint256\"}],\"name\":\"changeMinDepositAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLocktime\",\"type\":\"uint256\"}],\"name\":\"changeMinWithdrawLocktime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"}],\"name\":\"depositFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getAllAddrsOverMinDeposit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"searchers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"depositAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nonces\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getDepositAddrs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"searchers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositAddrsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"}],\"name\":\"isMinDepositOver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minWithdrawLockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"takeBid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"name\":\"takeGas\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawReservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"at\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"bd3bf7f3": "REGISTRY_ADDRESS()",
		"88a639c9": "auctionFeeVault()",
		"c2cf75ec": "changeAuctionFeeVault(address)",
		"8caad7b5": "changeMinDepositAmount(uint256)",
		"39253624": "changeMinWithdrawLocktime(uint256)",
		"d0e30db0": "deposit()",
		"1eb903cf": "depositBalances(address)",
		"aa67c919": "depositFor(address)",
		"5be1a55e": "getAllAddrsOverMinDeposit(uint256,uint256)",
		"e45076ac": "getDepositAddrs(uint256,uint256)",
		"84792e0b": "getDepositAddrsLength()",
		"48f928e8": "isMinDepositOver(address)",
		"645006ca": "minDepositAmount()",
		"99d52501": "minWithdrawLockTime()",
		"8da5cb5b": "owner()",
		"715018a6": "renounceOwnership()",
		"bea39cab": "reserveWithdraw()",
		"08bf759d": "takeBid(address,uint256)",
		"b4fdfae5": "takeGas(address,uint256)",
		"f2fde38b": "transferOwnership(address)",
		"3ccfd60b": "withdraw()",
		"7decbd4d": "withdrawReservations(address)",
	},
	Bin: "0x6080604052678ac7230489e80000600155603c600255348015610020575f80fd5b5060405161183838038061183883398101604081905261003f91610130565b816001600160a01b03811661006d57604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b610076816100c6565b50806001600160a01b03811661009f5760405163d92e233d60e01b815260040160405180910390fd5b50600380546001600160a01b0319166001600160a01b039290921691909117905550610161565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80516001600160a01b038116811461012b575f80fd5b919050565b5f8060408385031215610141575f80fd5b61014a83610115565b915061015860208401610115565b90509250929050565b6116ca8061016e5f395ff3fe608060405260043610610131575f3560e01c80638caad7b5116100a8578063bd3bf7f31161006d578063bd3bf7f31461037d578063bea39cab14610392578063c2cf75ec146103a6578063d0e30db0146103c5578063e45076ac146103cd578063f2fde38b146103f9575f80fd5b80638caad7b5146102fb5780638da5cb5b1461031a57806399d5250114610336578063aa67c9191461034b578063b4fdfae51461035e575f80fd5b80635be1a55e116100f95780635be1a55e14610212578063645006ca14610240578063715018a6146102555780637decbd4d1461026957806384792e0b146102b057806388a639c9146102c4575f80fd5b806308bf759d146101355780631eb903cf1461016957806339253624146101a25780633ccfd60b146101c357806348f928e8146101d7575b5f80fd5b348015610140575f80fd5b5061015461014f366004611444565b610418565b60405190151581526020015b60405180910390f35b348015610174575f80fd5b5061019461018336600461146e565b60046020525f908152604090205481565b604051908152602001610160565b3480156101ad575f80fd5b506101c16101bc366004611489565b6104d3565b005b3480156101ce575f80fd5b506101c161051c565b3480156101e2575f80fd5b506101546101f136600461146e565b6001546001600160a01b039091165f90815260046020526040902054101590565b34801561021d575f80fd5b5061023161022c3660046114a0565b61066e565b60405161016093929190611532565b34801561024b575f80fd5b5061019460015481565b348015610260575f80fd5b506101c1610906565b348015610274575f80fd5b5061029b61028336600461146e565b60056020525f90815260409020805460019091015482565b60408051928352602083019190915201610160565b3480156102bb575f80fd5b50610194610919565b3480156102cf575f80fd5b506003546102e3906001600160a01b031681565b6040516001600160a01b039091168152602001610160565b348015610306575f80fd5b506101c1610315366004611489565b610929565b348015610325575f80fd5b505f546001600160a01b03166102e3565b348015610341575f80fd5b5061019460025481565b6101c161035936600461146e565b610972565b348015610369575f80fd5b50610154610378366004611444565b6109ac565b348015610388575f80fd5b506102e361040181565b34801561039d575f80fd5b506101c1610a75565b3480156103b1575f80fd5b506101c16103c036600461146e565b610b46565b6101c1610be0565b3480156103d8575f80fd5b506103ec6103e73660046114a0565b610c17565b6040516101609190611574565b348015610404575f80fd5b506101c161041336600461146e565b610d00565b5f610421610d3f565b6001600160a01b0316336001600160a01b0316146104525760405163bd07c55160e01b815260040160405180910390fd5b6001600160a01b0383165f90815260046020526040902054808311156104b6577fdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c48482856040516104a593929190611586565b60405180910390a15f9150506104cd565b6104c9846104c48686610dc2565b610e64565b9150505b92915050565b6104db610fa5565b60025460408051918252602082018390527f5e273c905caf5b3f4d3a98caf8814cdccb3860b2b334a58140b692fcf28b286d910160405180910390a1600255565b335f8181526005602052604090206001810154905480158061053e5750804211155b1561055c576040516357c9104b60e11b815260040160405180910390fd5b6001600160a01b0383165f90815260046020526040902054821115610596576001600160a01b0383165f9081526004602052604090205491505b6105a08383610dc2565b506001600160a01b0383165f818152600560205260408082208281556001018290555190919084908381818185875af1925050503d805f81146105fe576040519150601f19603f3d011682016040523d82523d5f602084013e610603565b606091505b5050905080610625576040516327fcd9d160e01b815260040160405180910390fd5b7f97c7b889c23f0ecb7c22eac5c58266eae022989cfdbd9b6dcf63417338c787de848461065187610fd1565b60405161066093929190611586565b60405180910390a150505050565b60608060605f61067e6006611043565b90505f855f0361068f5750806106b3565b8161069a87896115bb565b116106ae576106a986886115bb565b6106b0565b815b90505b5f6106bc610d3f565b90506106c888836115ce565b67ffffffffffffffff8111156106e0576106e06115e1565b604051908082528060200260200182016040528015610709578160200160208202803683370190505b50955061071688836115ce565b67ffffffffffffffff81111561072e5761072e6115e1565b604051908082528060200260200182016040528015610757578160200160208202803683370190505b50945061076488836115ce565b67ffffffffffffffff81111561077c5761077c6115e1565b6040519080825280602002602001820160405280156107a5578160200160208202803683370190505b5093505f885b838110156108f1575f6107bf60068361104c565b6001546001600160a01b0382165f90815260046020526040902054919250116108e857808984815181106107f5576107f56115f5565b60200260200101906001600160a01b031690816001600160a01b03168152505060045f826001600160a01b03166001600160a01b031681526020019081526020015f205488848151811061084b5761084b6115f5565b6020908102919091010152604051623f675f60e91b81526001600160a01b038281166004830152851690637ecebe0090602401602060405180830381865afa158015610899573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108bd9190611609565b8784815181106108cf576108cf6115f5565b6020908102919091010152826108e481611620565b9350505b506001016107ab565b50808752808652808552505050509250925092565b61090e610fa5565b6109175f611057565b565b5f6109246006611043565b905090565b610931610fa5565b60015460408051918252602082018390527f404f17a8e681362e0d411e6b9b82111f6f7657596601fbe44eb9e2c960438f54910160405180910390a1600155565b335f908152600560205260409020541561099f5760405163bcb6b8c360e01b815260040160405180910390fd5b6109a981346110a6565b50565b5f6109b5610d3f565b6001600160a01b0316336001600160a01b0316146109e65760405163bd07c55160e01b815260040160405180910390fd5b5f6109f1833a611638565b6001600160a01b0385165f9081526004602052604090205490915080821115610a59577fdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c4858284604051610a4793929190611586565b60405180910390a15f925050506104cd565b610a6c85610a678785610dc2565b611176565b95945050505050565b335f9081526005602052604090205415610aa25760405163bcb6b8c360e01b815260040160405180910390fd5b335f8181526004602052604081205490819003610ad25760405163078e1d8560e01b815260040160405180910390fd5b600254610adf90426115bb565b6001600160a01b0383165f9081526005602052604090209081556001018190557f89312dfc642f95af3c0376f434dd92d2ce54d713297a8df3921828edbd2ef1a18282610b2b82610fd1565b604051610b3a93929190611586565b60405180910390a15050565b610b4e610fa5565b806001600160a01b038116610b765760405163d92e233d60e01b815260040160405180910390fd5b600354604080516001600160a01b03928316815291841660208301527f384b2820c6944bcf938c3d8c170a4421377f8e7a397ffb5ff321b8dce59bb97d910160405180910390a150600380546001600160a01b0319166001600160a01b0392909216919091179055565b335f9081526005602052604090205415610c0d5760405163bcb6b8c360e01b815260040160405180910390fd5b61091733346110a6565b60605f610c246006611043565b90505f835f03610c35575080610c59565b81610c4085876115bb565b11610c5457610c4f84866115bb565b610c56565b815b90505b610c6385826115ce565b67ffffffffffffffff811115610c7b57610c7b6115e1565b604051908082528060200260200182016040528015610ca4578160200160208202803683370190505b509250845b81811015610cf757610cbc60068261104c565b84610cc788846115ce565b81518110610cd757610cd76115f5565b6001600160a01b0390921660209283029190910190910152600101610ca9565b50505092915050565b610d08610fa5565b6001600160a01b038116610d3657604051631e4fbdf760e01b81525f60048201526024015b60405180910390fd5b6109a981611057565b60405163e2693e3f60e01b8152602060048201526011602482015270105d58dd1a5bdb915b9d1c9e541bda5b9d607a1b60448201525f906104019063e2693e3f90606401602060405180830381865afa158015610d9e573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610924919061164f565b6001600160a01b0382165f9081526004602052604081205481908310610dff576001600160a01b0384165f90815260046020526040902054610e01565b825b6001600160a01b0385165f90815260046020526040812080549293508392909190610e2d9084906115ce565b90915550506001600160a01b0384165f908152600460205260408120549003610e5d57610e5b60068561125f565b505b9392505050565b604080516001600160a01b0384811660248084019190915283518084039091018152604490920183526020820180516001600160e01b0316638573e2ff60e01b17905260035492515f93909116908490610ebf90849061166a565b5f6040518083038185875af1925050503d805f8114610ef9576040519150601f19603f3d011682016040523d82523d5f602084013e610efe565b606091505b50508092505081610f5b57610f138484611273565b50604080516001600160a01b0386168152602081018590527fd26b9fcb04629bad3365ea66f0f4d563e8c71753e7ee1a0c601f1a02ceebed8b910160405180910390a1610f9e565b604080516001600160a01b0386168152602081018590527fbf3f09205213cdb412585918db004ac3947fcd2db1f85fdbb20faaa950e08d2e910160405180910390a15b5092915050565b5f546001600160a01b031633146109175760405163118cdaa760e01b8152336004820152602401610d2d565b5f610fda610d3f565b604051623f675f60e91b81526001600160a01b0384811660048301529190911690637ecebe0090602401602060405180830381865afa15801561101f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104cd9190611609565b5f6104cd825490565b5f610e5d83836112bf565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b805f036110c65760405163078e1d8560e01b815260040160405180910390fd5b6001546001600160a01b0383165f908152600460205260409020546110eb90836115bb565b101561110a5760405163ca5d4cb760e01b815260040160405180910390fd5b5f6111158383611273565b90507fb356f70fb7268cd9ebf6cd2c25e8628582435a3754305d2edade9b81c096118183838361114487610fd1565b604080516001600160a01b039095168552602085019390935291830152606082015260800160405180910390a1505050565b6040515f90419083908381818185875af1925050503d805f81146111b5576040519150601f19603f3d011682016040523d82523d5f602084013e6111ba565b606091505b50508091505080611217576111cf8383611273565b50604080516001600160a01b0385168152602081018490527f53605ab3492a9ae1542e049df64874ee628a589811e81b2594f416e9d092b7ca910160405180910390a16104cd565b604080516001600160a01b0385168152602081018490527f672970b97597bfb4460c604bb4adc66538c7b00a40bfb2cb9b6566f1692266fd910160405180910390a192915050565b5f610e5d836001600160a01b0384166112e5565b6001600160a01b0382165f9081526004602052604081205481906112989084906115bb565b6001600160a01b0385165f9081526004602052604090208190559050610e5b6006856113c8565b5f825f0182815481106112d4576112d46115f5565b905f5260205f200154905092915050565b5f81815260018301602052604081205480156113bf575f6113076001836115ce565b85549091505f9061131a906001906115ce565b9050808214611379575f865f018281548110611338576113386115f5565b905f5260205f200154905080875f018481548110611358576113586115f5565b5f918252602080832090910192909255918252600188019052604090208390555b855486908061138a5761138a611680565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f9055600193505050506104cd565b5f9150506104cd565b5f610e5d836001600160a01b0384165f6113f483835f9081526001919091016020526040902054151590565b61142957508154600181810184555f8481526020808220909301849055845484825282860190935260409020919091556104cd565b505f6104cd565b6001600160a01b03811681146109a9575f80fd5b5f8060408385031215611455575f80fd5b823561146081611430565b946020939093013593505050565b5f6020828403121561147e575f80fd5b8135610e5d81611430565b5f60208284031215611499575f80fd5b5035919050565b5f80604083850312156114b1575f80fd5b50508035926020909101359150565b5f815180845260208085019450602084015f5b838110156114f85781516001600160a01b0316875295820195908201906001016114d3565b509495945050505050565b5f815180845260208085019450602084015f5b838110156114f857815187529582019590820190600101611516565b606081525f61154460608301866114c0565b82810360208401526115568186611503565b9050828103604084015261156a8185611503565b9695505050505050565b602081525f610e5d60208301846114c0565b6001600160a01b039390931683526020830191909152604082015260600190565b634e487b7160e01b5f52601160045260245ffd5b808201808211156104cd576104cd6115a7565b818103818111156104cd576104cd6115a7565b634e487b7160e01b5f52604160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b5f60208284031215611619575f80fd5b5051919050565b5f60018201611631576116316115a7565b5060010190565b80820281158282048414176104cd576104cd6115a7565b5f6020828403121561165f575f80fd5b8151610e5d81611430565b5f82518060208501845e5f920191825250919050565b634e487b7160e01b5f52603160045260245ffdfea26469706673582212204dbed8cdc1c91331cadd972026f3b5d6daf328cd53366338bd075770914a934764736f6c63430008190033",
}

// AuctionDepositVaultABI is the input ABI used to generate the binding from.
// Deprecated: Use AuctionDepositVaultMetaData.ABI instead.
var AuctionDepositVaultABI = AuctionDepositVaultMetaData.ABI

// AuctionDepositVaultBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const AuctionDepositVaultBinRuntime = `608060405260043610610131575f3560e01c80638caad7b5116100a8578063bd3bf7f31161006d578063bd3bf7f31461037d578063bea39cab14610392578063c2cf75ec146103a6578063d0e30db0146103c5578063e45076ac146103cd578063f2fde38b146103f9575f80fd5b80638caad7b5146102fb5780638da5cb5b1461031a57806399d5250114610336578063aa67c9191461034b578063b4fdfae51461035e575f80fd5b80635be1a55e116100f95780635be1a55e14610212578063645006ca14610240578063715018a6146102555780637decbd4d1461026957806384792e0b146102b057806388a639c9146102c4575f80fd5b806308bf759d146101355780631eb903cf1461016957806339253624146101a25780633ccfd60b146101c357806348f928e8146101d7575b5f80fd5b348015610140575f80fd5b5061015461014f366004611444565b610418565b60405190151581526020015b60405180910390f35b348015610174575f80fd5b5061019461018336600461146e565b60046020525f908152604090205481565b604051908152602001610160565b3480156101ad575f80fd5b506101c16101bc366004611489565b6104d3565b005b3480156101ce575f80fd5b506101c161051c565b3480156101e2575f80fd5b506101546101f136600461146e565b6001546001600160a01b039091165f90815260046020526040902054101590565b34801561021d575f80fd5b5061023161022c3660046114a0565b61066e565b60405161016093929190611532565b34801561024b575f80fd5b5061019460015481565b348015610260575f80fd5b506101c1610906565b348015610274575f80fd5b5061029b61028336600461146e565b60056020525f90815260409020805460019091015482565b60408051928352602083019190915201610160565b3480156102bb575f80fd5b50610194610919565b3480156102cf575f80fd5b506003546102e3906001600160a01b031681565b6040516001600160a01b039091168152602001610160565b348015610306575f80fd5b506101c1610315366004611489565b610929565b348015610325575f80fd5b505f546001600160a01b03166102e3565b348015610341575f80fd5b5061019460025481565b6101c161035936600461146e565b610972565b348015610369575f80fd5b50610154610378366004611444565b6109ac565b348015610388575f80fd5b506102e361040181565b34801561039d575f80fd5b506101c1610a75565b3480156103b1575f80fd5b506101c16103c036600461146e565b610b46565b6101c1610be0565b3480156103d8575f80fd5b506103ec6103e73660046114a0565b610c17565b6040516101609190611574565b348015610404575f80fd5b506101c161041336600461146e565b610d00565b5f610421610d3f565b6001600160a01b0316336001600160a01b0316146104525760405163bd07c55160e01b815260040160405180910390fd5b6001600160a01b0383165f90815260046020526040902054808311156104b6577fdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c48482856040516104a593929190611586565b60405180910390a15f9150506104cd565b6104c9846104c48686610dc2565b610e64565b9150505b92915050565b6104db610fa5565b60025460408051918252602082018390527f5e273c905caf5b3f4d3a98caf8814cdccb3860b2b334a58140b692fcf28b286d910160405180910390a1600255565b335f8181526005602052604090206001810154905480158061053e5750804211155b1561055c576040516357c9104b60e11b815260040160405180910390fd5b6001600160a01b0383165f90815260046020526040902054821115610596576001600160a01b0383165f9081526004602052604090205491505b6105a08383610dc2565b506001600160a01b0383165f818152600560205260408082208281556001018290555190919084908381818185875af1925050503d805f81146105fe576040519150601f19603f3d011682016040523d82523d5f602084013e610603565b606091505b5050905080610625576040516327fcd9d160e01b815260040160405180910390fd5b7f97c7b889c23f0ecb7c22eac5c58266eae022989cfdbd9b6dcf63417338c787de848461065187610fd1565b60405161066093929190611586565b60405180910390a150505050565b60608060605f61067e6006611043565b90505f855f0361068f5750806106b3565b8161069a87896115bb565b116106ae576106a986886115bb565b6106b0565b815b90505b5f6106bc610d3f565b90506106c888836115ce565b67ffffffffffffffff8111156106e0576106e06115e1565b604051908082528060200260200182016040528015610709578160200160208202803683370190505b50955061071688836115ce565b67ffffffffffffffff81111561072e5761072e6115e1565b604051908082528060200260200182016040528015610757578160200160208202803683370190505b50945061076488836115ce565b67ffffffffffffffff81111561077c5761077c6115e1565b6040519080825280602002602001820160405280156107a5578160200160208202803683370190505b5093505f885b838110156108f1575f6107bf60068361104c565b6001546001600160a01b0382165f90815260046020526040902054919250116108e857808984815181106107f5576107f56115f5565b60200260200101906001600160a01b031690816001600160a01b03168152505060045f826001600160a01b03166001600160a01b031681526020019081526020015f205488848151811061084b5761084b6115f5565b6020908102919091010152604051623f675f60e91b81526001600160a01b038281166004830152851690637ecebe0090602401602060405180830381865afa158015610899573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108bd9190611609565b8784815181106108cf576108cf6115f5565b6020908102919091010152826108e481611620565b9350505b506001016107ab565b50808752808652808552505050509250925092565b61090e610fa5565b6109175f611057565b565b5f6109246006611043565b905090565b610931610fa5565b60015460408051918252602082018390527f404f17a8e681362e0d411e6b9b82111f6f7657596601fbe44eb9e2c960438f54910160405180910390a1600155565b335f908152600560205260409020541561099f5760405163bcb6b8c360e01b815260040160405180910390fd5b6109a981346110a6565b50565b5f6109b5610d3f565b6001600160a01b0316336001600160a01b0316146109e65760405163bd07c55160e01b815260040160405180910390fd5b5f6109f1833a611638565b6001600160a01b0385165f9081526004602052604090205490915080821115610a59577fdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c4858284604051610a4793929190611586565b60405180910390a15f925050506104cd565b610a6c85610a678785610dc2565b611176565b95945050505050565b335f9081526005602052604090205415610aa25760405163bcb6b8c360e01b815260040160405180910390fd5b335f8181526004602052604081205490819003610ad25760405163078e1d8560e01b815260040160405180910390fd5b600254610adf90426115bb565b6001600160a01b0383165f9081526005602052604090209081556001018190557f89312dfc642f95af3c0376f434dd92d2ce54d713297a8df3921828edbd2ef1a18282610b2b82610fd1565b604051610b3a93929190611586565b60405180910390a15050565b610b4e610fa5565b806001600160a01b038116610b765760405163d92e233d60e01b815260040160405180910390fd5b600354604080516001600160a01b03928316815291841660208301527f384b2820c6944bcf938c3d8c170a4421377f8e7a397ffb5ff321b8dce59bb97d910160405180910390a150600380546001600160a01b0319166001600160a01b0392909216919091179055565b335f9081526005602052604090205415610c0d5760405163bcb6b8c360e01b815260040160405180910390fd5b61091733346110a6565b60605f610c246006611043565b90505f835f03610c35575080610c59565b81610c4085876115bb565b11610c5457610c4f84866115bb565b610c56565b815b90505b610c6385826115ce565b67ffffffffffffffff811115610c7b57610c7b6115e1565b604051908082528060200260200182016040528015610ca4578160200160208202803683370190505b509250845b81811015610cf757610cbc60068261104c565b84610cc788846115ce565b81518110610cd757610cd76115f5565b6001600160a01b0390921660209283029190910190910152600101610ca9565b50505092915050565b610d08610fa5565b6001600160a01b038116610d3657604051631e4fbdf760e01b81525f60048201526024015b60405180910390fd5b6109a981611057565b60405163e2693e3f60e01b8152602060048201526011602482015270105d58dd1a5bdb915b9d1c9e541bda5b9d607a1b60448201525f906104019063e2693e3f90606401602060405180830381865afa158015610d9e573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610924919061164f565b6001600160a01b0382165f9081526004602052604081205481908310610dff576001600160a01b0384165f90815260046020526040902054610e01565b825b6001600160a01b0385165f90815260046020526040812080549293508392909190610e2d9084906115ce565b90915550506001600160a01b0384165f908152600460205260408120549003610e5d57610e5b60068561125f565b505b9392505050565b604080516001600160a01b0384811660248084019190915283518084039091018152604490920183526020820180516001600160e01b0316638573e2ff60e01b17905260035492515f93909116908490610ebf90849061166a565b5f6040518083038185875af1925050503d805f8114610ef9576040519150601f19603f3d011682016040523d82523d5f602084013e610efe565b606091505b50508092505081610f5b57610f138484611273565b50604080516001600160a01b0386168152602081018590527fd26b9fcb04629bad3365ea66f0f4d563e8c71753e7ee1a0c601f1a02ceebed8b910160405180910390a1610f9e565b604080516001600160a01b0386168152602081018590527fbf3f09205213cdb412585918db004ac3947fcd2db1f85fdbb20faaa950e08d2e910160405180910390a15b5092915050565b5f546001600160a01b031633146109175760405163118cdaa760e01b8152336004820152602401610d2d565b5f610fda610d3f565b604051623f675f60e91b81526001600160a01b0384811660048301529190911690637ecebe0090602401602060405180830381865afa15801561101f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104cd9190611609565b5f6104cd825490565b5f610e5d83836112bf565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b805f036110c65760405163078e1d8560e01b815260040160405180910390fd5b6001546001600160a01b0383165f908152600460205260409020546110eb90836115bb565b101561110a5760405163ca5d4cb760e01b815260040160405180910390fd5b5f6111158383611273565b90507fb356f70fb7268cd9ebf6cd2c25e8628582435a3754305d2edade9b81c096118183838361114487610fd1565b604080516001600160a01b039095168552602085019390935291830152606082015260800160405180910390a1505050565b6040515f90419083908381818185875af1925050503d805f81146111b5576040519150601f19603f3d011682016040523d82523d5f602084013e6111ba565b606091505b50508091505080611217576111cf8383611273565b50604080516001600160a01b0385168152602081018490527f53605ab3492a9ae1542e049df64874ee628a589811e81b2594f416e9d092b7ca910160405180910390a16104cd565b604080516001600160a01b0385168152602081018490527f672970b97597bfb4460c604bb4adc66538c7b00a40bfb2cb9b6566f1692266fd910160405180910390a192915050565b5f610e5d836001600160a01b0384166112e5565b6001600160a01b0382165f9081526004602052604081205481906112989084906115bb565b6001600160a01b0385165f9081526004602052604090208190559050610e5b6006856113c8565b5f825f0182815481106112d4576112d46115f5565b905f5260205f200154905092915050565b5f81815260018301602052604081205480156113bf575f6113076001836115ce565b85549091505f9061131a906001906115ce565b9050808214611379575f865f018281548110611338576113386115f5565b905f5260205f200154905080875f018481548110611358576113586115f5565b5f918252602080832090910192909255918252600188019052604090208390555b855486908061138a5761138a611680565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f9055600193505050506104cd565b5f9150506104cd565b5f610e5d836001600160a01b0384165f6113f483835f9081526001919091016020526040902054151590565b61142957508154600181810184555f8481526020808220909301849055845484825282860190935260409020919091556104cd565b505f6104cd565b6001600160a01b03811681146109a9575f80fd5b5f8060408385031215611455575f80fd5b823561146081611430565b946020939093013593505050565b5f6020828403121561147e575f80fd5b8135610e5d81611430565b5f60208284031215611499575f80fd5b5035919050565b5f80604083850312156114b1575f80fd5b50508035926020909101359150565b5f815180845260208085019450602084015f5b838110156114f85781516001600160a01b0316875295820195908201906001016114d3565b509495945050505050565b5f815180845260208085019450602084015f5b838110156114f857815187529582019590820190600101611516565b606081525f61154460608301866114c0565b82810360208401526115568186611503565b9050828103604084015261156a8185611503565b9695505050505050565b602081525f610e5d60208301846114c0565b6001600160a01b039390931683526020830191909152604082015260600190565b634e487b7160e01b5f52601160045260245ffd5b808201808211156104cd576104cd6115a7565b818103818111156104cd576104cd6115a7565b634e487b7160e01b5f52604160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b5f60208284031215611619575f80fd5b5051919050565b5f60018201611631576116316115a7565b5060010190565b80820281158282048414176104cd576104cd6115a7565b5f6020828403121561165f575f80fd5b8151610e5d81611430565b5f82518060208501845e5f920191825250919050565b634e487b7160e01b5f52603160045260245ffdfea26469706673582212204dbed8cdc1c91331cadd972026f3b5d6daf328cd53366338bd075770914a934764736f6c63430008190033`

// Deprecated: Use AuctionDepositVaultMetaData.Sigs instead.
// AuctionDepositVaultFuncSigs maps the 4-byte function signature to its string representation.
var AuctionDepositVaultFuncSigs = AuctionDepositVaultMetaData.Sigs

// AuctionDepositVaultBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AuctionDepositVaultMetaData.Bin instead.
var AuctionDepositVaultBin = AuctionDepositVaultMetaData.Bin

// DeployAuctionDepositVault deploys a new Kaia contract, binding an instance of AuctionDepositVault to it.
func DeployAuctionDepositVault(auth *bind.TransactOpts, backend bind.ContractBackend, initialOwner common.Address, _auctionFeeVault common.Address) (common.Address, *types.Transaction, *AuctionDepositVault, error) {
	parsed, err := AuctionDepositVaultMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AuctionDepositVaultBin), backend, initialOwner, _auctionFeeVault)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AuctionDepositVault{AuctionDepositVaultCaller: AuctionDepositVaultCaller{contract: contract}, AuctionDepositVaultTransactor: AuctionDepositVaultTransactor{contract: contract}, AuctionDepositVaultFilterer: AuctionDepositVaultFilterer{contract: contract}}, nil
}

// AuctionDepositVault is an auto generated Go binding around a Kaia contract.
type AuctionDepositVault struct {
	AuctionDepositVaultCaller     // Read-only binding to the contract
	AuctionDepositVaultTransactor // Write-only binding to the contract
	AuctionDepositVaultFilterer   // Log filterer for contract events
}

// AuctionDepositVaultCaller is an auto generated read-only Go binding around a Kaia contract.
type AuctionDepositVaultCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionDepositVaultTransactor is an auto generated write-only Go binding around a Kaia contract.
type AuctionDepositVaultTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionDepositVaultFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type AuctionDepositVaultFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionDepositVaultSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type AuctionDepositVaultSession struct {
	Contract     *AuctionDepositVault // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// AuctionDepositVaultCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type AuctionDepositVaultCallerSession struct {
	Contract *AuctionDepositVaultCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// AuctionDepositVaultTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type AuctionDepositVaultTransactorSession struct {
	Contract     *AuctionDepositVaultTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// AuctionDepositVaultRaw is an auto generated low-level Go binding around a Kaia contract.
type AuctionDepositVaultRaw struct {
	Contract *AuctionDepositVault // Generic contract binding to access the raw methods on
}

// AuctionDepositVaultCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type AuctionDepositVaultCallerRaw struct {
	Contract *AuctionDepositVaultCaller // Generic read-only contract binding to access the raw methods on
}

// AuctionDepositVaultTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type AuctionDepositVaultTransactorRaw struct {
	Contract *AuctionDepositVaultTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAuctionDepositVault creates a new instance of AuctionDepositVault, bound to a specific deployed contract.
func NewAuctionDepositVault(address common.Address, backend bind.ContractBackend) (*AuctionDepositVault, error) {
	contract, err := bindAuctionDepositVault(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVault{AuctionDepositVaultCaller: AuctionDepositVaultCaller{contract: contract}, AuctionDepositVaultTransactor: AuctionDepositVaultTransactor{contract: contract}, AuctionDepositVaultFilterer: AuctionDepositVaultFilterer{contract: contract}}, nil
}

// NewAuctionDepositVaultCaller creates a new read-only instance of AuctionDepositVault, bound to a specific deployed contract.
func NewAuctionDepositVaultCaller(address common.Address, caller bind.ContractCaller) (*AuctionDepositVaultCaller, error) {
	contract, err := bindAuctionDepositVault(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultCaller{contract: contract}, nil
}

// NewAuctionDepositVaultTransactor creates a new write-only instance of AuctionDepositVault, bound to a specific deployed contract.
func NewAuctionDepositVaultTransactor(address common.Address, transactor bind.ContractTransactor) (*AuctionDepositVaultTransactor, error) {
	contract, err := bindAuctionDepositVault(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultTransactor{contract: contract}, nil
}

// NewAuctionDepositVaultFilterer creates a new log filterer instance of AuctionDepositVault, bound to a specific deployed contract.
func NewAuctionDepositVaultFilterer(address common.Address, filterer bind.ContractFilterer) (*AuctionDepositVaultFilterer, error) {
	contract, err := bindAuctionDepositVault(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultFilterer{contract: contract}, nil
}

// bindAuctionDepositVault binds a generic wrapper to an already deployed contract.
func bindAuctionDepositVault(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AuctionDepositVaultMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AuctionDepositVault *AuctionDepositVaultRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AuctionDepositVault.Contract.AuctionDepositVaultCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AuctionDepositVault *AuctionDepositVaultRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.AuctionDepositVaultTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AuctionDepositVault *AuctionDepositVaultRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.AuctionDepositVaultTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AuctionDepositVault *AuctionDepositVaultCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AuctionDepositVault.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AuctionDepositVault *AuctionDepositVaultTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AuctionDepositVault *AuctionDepositVaultTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.contract.Transact(opts, method, params...)
}

// REGISTRYADDRESS is a free data retrieval call binding the contract method 0xbd3bf7f3.
//
// Solidity: function REGISTRY_ADDRESS() view returns(address)
func (_AuctionDepositVault *AuctionDepositVaultCaller) REGISTRYADDRESS(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AuctionDepositVault.contract.Call(opts, &out, "REGISTRY_ADDRESS")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// REGISTRYADDRESS is a free data retrieval call binding the contract method 0xbd3bf7f3.
//
// Solidity: function REGISTRY_ADDRESS() view returns(address)
func (_AuctionDepositVault *AuctionDepositVaultSession) REGISTRYADDRESS() (common.Address, error) {
	return _AuctionDepositVault.Contract.REGISTRYADDRESS(&_AuctionDepositVault.CallOpts)
}

// REGISTRYADDRESS is a free data retrieval call binding the contract method 0xbd3bf7f3.
//
// Solidity: function REGISTRY_ADDRESS() view returns(address)
func (_AuctionDepositVault *AuctionDepositVaultCallerSession) REGISTRYADDRESS() (common.Address, error) {
	return _AuctionDepositVault.Contract.REGISTRYADDRESS(&_AuctionDepositVault.CallOpts)
}

// AuctionFeeVault is a free data retrieval call binding the contract method 0x88a639c9.
//
// Solidity: function auctionFeeVault() view returns(address)
func (_AuctionDepositVault *AuctionDepositVaultCaller) AuctionFeeVault(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AuctionDepositVault.contract.Call(opts, &out, "auctionFeeVault")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AuctionFeeVault is a free data retrieval call binding the contract method 0x88a639c9.
//
// Solidity: function auctionFeeVault() view returns(address)
func (_AuctionDepositVault *AuctionDepositVaultSession) AuctionFeeVault() (common.Address, error) {
	return _AuctionDepositVault.Contract.AuctionFeeVault(&_AuctionDepositVault.CallOpts)
}

// AuctionFeeVault is a free data retrieval call binding the contract method 0x88a639c9.
//
// Solidity: function auctionFeeVault() view returns(address)
func (_AuctionDepositVault *AuctionDepositVaultCallerSession) AuctionFeeVault() (common.Address, error) {
	return _AuctionDepositVault.Contract.AuctionFeeVault(&_AuctionDepositVault.CallOpts)
}

// DepositBalances is a free data retrieval call binding the contract method 0x1eb903cf.
//
// Solidity: function depositBalances(address ) view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultCaller) DepositBalances(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _AuctionDepositVault.contract.Call(opts, &out, "depositBalances", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DepositBalances is a free data retrieval call binding the contract method 0x1eb903cf.
//
// Solidity: function depositBalances(address ) view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultSession) DepositBalances(arg0 common.Address) (*big.Int, error) {
	return _AuctionDepositVault.Contract.DepositBalances(&_AuctionDepositVault.CallOpts, arg0)
}

// DepositBalances is a free data retrieval call binding the contract method 0x1eb903cf.
//
// Solidity: function depositBalances(address ) view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultCallerSession) DepositBalances(arg0 common.Address) (*big.Int, error) {
	return _AuctionDepositVault.Contract.DepositBalances(&_AuctionDepositVault.CallOpts, arg0)
}

// GetAllAddrsOverMinDeposit is a free data retrieval call binding the contract method 0x5be1a55e.
//
// Solidity: function getAllAddrsOverMinDeposit(uint256 start, uint256 limit) view returns(address[] searchers, uint256[] depositAmounts, uint256[] nonces)
func (_AuctionDepositVault *AuctionDepositVaultCaller) GetAllAddrsOverMinDeposit(opts *bind.CallOpts, start *big.Int, limit *big.Int) (struct {
	Searchers      []common.Address
	DepositAmounts []*big.Int
	Nonces         []*big.Int
}, error) {
	var out []interface{}
	err := _AuctionDepositVault.contract.Call(opts, &out, "getAllAddrsOverMinDeposit", start, limit)

	outstruct := new(struct {
		Searchers      []common.Address
		DepositAmounts []*big.Int
		Nonces         []*big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Searchers = *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)
	outstruct.DepositAmounts = *abi.ConvertType(out[1], new([]*big.Int)).(*[]*big.Int)
	outstruct.Nonces = *abi.ConvertType(out[2], new([]*big.Int)).(*[]*big.Int)

	return *outstruct, err

}

// GetAllAddrsOverMinDeposit is a free data retrieval call binding the contract method 0x5be1a55e.
//
// Solidity: function getAllAddrsOverMinDeposit(uint256 start, uint256 limit) view returns(address[] searchers, uint256[] depositAmounts, uint256[] nonces)
func (_AuctionDepositVault *AuctionDepositVaultSession) GetAllAddrsOverMinDeposit(start *big.Int, limit *big.Int) (struct {
	Searchers      []common.Address
	DepositAmounts []*big.Int
	Nonces         []*big.Int
}, error) {
	return _AuctionDepositVault.Contract.GetAllAddrsOverMinDeposit(&_AuctionDepositVault.CallOpts, start, limit)
}

// GetAllAddrsOverMinDeposit is a free data retrieval call binding the contract method 0x5be1a55e.
//
// Solidity: function getAllAddrsOverMinDeposit(uint256 start, uint256 limit) view returns(address[] searchers, uint256[] depositAmounts, uint256[] nonces)
func (_AuctionDepositVault *AuctionDepositVaultCallerSession) GetAllAddrsOverMinDeposit(start *big.Int, limit *big.Int) (struct {
	Searchers      []common.Address
	DepositAmounts []*big.Int
	Nonces         []*big.Int
}, error) {
	return _AuctionDepositVault.Contract.GetAllAddrsOverMinDeposit(&_AuctionDepositVault.CallOpts, start, limit)
}

// GetDepositAddrs is a free data retrieval call binding the contract method 0xe45076ac.
//
// Solidity: function getDepositAddrs(uint256 start, uint256 limit) view returns(address[] searchers)
func (_AuctionDepositVault *AuctionDepositVaultCaller) GetDepositAddrs(opts *bind.CallOpts, start *big.Int, limit *big.Int) ([]common.Address, error) {
	var out []interface{}
	err := _AuctionDepositVault.contract.Call(opts, &out, "getDepositAddrs", start, limit)

	if err != nil {
		return *new([]common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)

	return out0, err

}

// GetDepositAddrs is a free data retrieval call binding the contract method 0xe45076ac.
//
// Solidity: function getDepositAddrs(uint256 start, uint256 limit) view returns(address[] searchers)
func (_AuctionDepositVault *AuctionDepositVaultSession) GetDepositAddrs(start *big.Int, limit *big.Int) ([]common.Address, error) {
	return _AuctionDepositVault.Contract.GetDepositAddrs(&_AuctionDepositVault.CallOpts, start, limit)
}

// GetDepositAddrs is a free data retrieval call binding the contract method 0xe45076ac.
//
// Solidity: function getDepositAddrs(uint256 start, uint256 limit) view returns(address[] searchers)
func (_AuctionDepositVault *AuctionDepositVaultCallerSession) GetDepositAddrs(start *big.Int, limit *big.Int) ([]common.Address, error) {
	return _AuctionDepositVault.Contract.GetDepositAddrs(&_AuctionDepositVault.CallOpts, start, limit)
}

// GetDepositAddrsLength is a free data retrieval call binding the contract method 0x84792e0b.
//
// Solidity: function getDepositAddrsLength() view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultCaller) GetDepositAddrsLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AuctionDepositVault.contract.Call(opts, &out, "getDepositAddrsLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetDepositAddrsLength is a free data retrieval call binding the contract method 0x84792e0b.
//
// Solidity: function getDepositAddrsLength() view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultSession) GetDepositAddrsLength() (*big.Int, error) {
	return _AuctionDepositVault.Contract.GetDepositAddrsLength(&_AuctionDepositVault.CallOpts)
}

// GetDepositAddrsLength is a free data retrieval call binding the contract method 0x84792e0b.
//
// Solidity: function getDepositAddrsLength() view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultCallerSession) GetDepositAddrsLength() (*big.Int, error) {
	return _AuctionDepositVault.Contract.GetDepositAddrsLength(&_AuctionDepositVault.CallOpts)
}

// IsMinDepositOver is a free data retrieval call binding the contract method 0x48f928e8.
//
// Solidity: function isMinDepositOver(address searcher) view returns(bool)
func (_AuctionDepositVault *AuctionDepositVaultCaller) IsMinDepositOver(opts *bind.CallOpts, searcher common.Address) (bool, error) {
	var out []interface{}
	err := _AuctionDepositVault.contract.Call(opts, &out, "isMinDepositOver", searcher)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsMinDepositOver is a free data retrieval call binding the contract method 0x48f928e8.
//
// Solidity: function isMinDepositOver(address searcher) view returns(bool)
func (_AuctionDepositVault *AuctionDepositVaultSession) IsMinDepositOver(searcher common.Address) (bool, error) {
	return _AuctionDepositVault.Contract.IsMinDepositOver(&_AuctionDepositVault.CallOpts, searcher)
}

// IsMinDepositOver is a free data retrieval call binding the contract method 0x48f928e8.
//
// Solidity: function isMinDepositOver(address searcher) view returns(bool)
func (_AuctionDepositVault *AuctionDepositVaultCallerSession) IsMinDepositOver(searcher common.Address) (bool, error) {
	return _AuctionDepositVault.Contract.IsMinDepositOver(&_AuctionDepositVault.CallOpts, searcher)
}

// MinDepositAmount is a free data retrieval call binding the contract method 0x645006ca.
//
// Solidity: function minDepositAmount() view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultCaller) MinDepositAmount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AuctionDepositVault.contract.Call(opts, &out, "minDepositAmount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinDepositAmount is a free data retrieval call binding the contract method 0x645006ca.
//
// Solidity: function minDepositAmount() view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultSession) MinDepositAmount() (*big.Int, error) {
	return _AuctionDepositVault.Contract.MinDepositAmount(&_AuctionDepositVault.CallOpts)
}

// MinDepositAmount is a free data retrieval call binding the contract method 0x645006ca.
//
// Solidity: function minDepositAmount() view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultCallerSession) MinDepositAmount() (*big.Int, error) {
	return _AuctionDepositVault.Contract.MinDepositAmount(&_AuctionDepositVault.CallOpts)
}

// MinWithdrawLockTime is a free data retrieval call binding the contract method 0x99d52501.
//
// Solidity: function minWithdrawLockTime() view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultCaller) MinWithdrawLockTime(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AuctionDepositVault.contract.Call(opts, &out, "minWithdrawLockTime")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinWithdrawLockTime is a free data retrieval call binding the contract method 0x99d52501.
//
// Solidity: function minWithdrawLockTime() view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultSession) MinWithdrawLockTime() (*big.Int, error) {
	return _AuctionDepositVault.Contract.MinWithdrawLockTime(&_AuctionDepositVault.CallOpts)
}

// MinWithdrawLockTime is a free data retrieval call binding the contract method 0x99d52501.
//
// Solidity: function minWithdrawLockTime() view returns(uint256)
func (_AuctionDepositVault *AuctionDepositVaultCallerSession) MinWithdrawLockTime() (*big.Int, error) {
	return _AuctionDepositVault.Contract.MinWithdrawLockTime(&_AuctionDepositVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AuctionDepositVault *AuctionDepositVaultCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AuctionDepositVault.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AuctionDepositVault *AuctionDepositVaultSession) Owner() (common.Address, error) {
	return _AuctionDepositVault.Contract.Owner(&_AuctionDepositVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AuctionDepositVault *AuctionDepositVaultCallerSession) Owner() (common.Address, error) {
	return _AuctionDepositVault.Contract.Owner(&_AuctionDepositVault.CallOpts)
}

// WithdrawReservations is a free data retrieval call binding the contract method 0x7decbd4d.
//
// Solidity: function withdrawReservations(address ) view returns(uint256 at, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultCaller) WithdrawReservations(opts *bind.CallOpts, arg0 common.Address) (struct {
	At     *big.Int
	Amount *big.Int
}, error) {
	var out []interface{}
	err := _AuctionDepositVault.contract.Call(opts, &out, "withdrawReservations", arg0)

	outstruct := new(struct {
		At     *big.Int
		Amount *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.At = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.Amount = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// WithdrawReservations is a free data retrieval call binding the contract method 0x7decbd4d.
//
// Solidity: function withdrawReservations(address ) view returns(uint256 at, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultSession) WithdrawReservations(arg0 common.Address) (struct {
	At     *big.Int
	Amount *big.Int
}, error) {
	return _AuctionDepositVault.Contract.WithdrawReservations(&_AuctionDepositVault.CallOpts, arg0)
}

// WithdrawReservations is a free data retrieval call binding the contract method 0x7decbd4d.
//
// Solidity: function withdrawReservations(address ) view returns(uint256 at, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultCallerSession) WithdrawReservations(arg0 common.Address) (struct {
	At     *big.Int
	Amount *big.Int
}, error) {
	return _AuctionDepositVault.Contract.WithdrawReservations(&_AuctionDepositVault.CallOpts, arg0)
}

// ChangeAuctionFeeVault is a paid mutator transaction binding the contract method 0xc2cf75ec.
//
// Solidity: function changeAuctionFeeVault(address newAuctionFeeVault) returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactor) ChangeAuctionFeeVault(opts *bind.TransactOpts, newAuctionFeeVault common.Address) (*types.Transaction, error) {
	return _AuctionDepositVault.contract.Transact(opts, "changeAuctionFeeVault", newAuctionFeeVault)
}

// ChangeAuctionFeeVault is a paid mutator transaction binding the contract method 0xc2cf75ec.
//
// Solidity: function changeAuctionFeeVault(address newAuctionFeeVault) returns()
func (_AuctionDepositVault *AuctionDepositVaultSession) ChangeAuctionFeeVault(newAuctionFeeVault common.Address) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.ChangeAuctionFeeVault(&_AuctionDepositVault.TransactOpts, newAuctionFeeVault)
}

// ChangeAuctionFeeVault is a paid mutator transaction binding the contract method 0xc2cf75ec.
//
// Solidity: function changeAuctionFeeVault(address newAuctionFeeVault) returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactorSession) ChangeAuctionFeeVault(newAuctionFeeVault common.Address) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.ChangeAuctionFeeVault(&_AuctionDepositVault.TransactOpts, newAuctionFeeVault)
}

// ChangeMinDepositAmount is a paid mutator transaction binding the contract method 0x8caad7b5.
//
// Solidity: function changeMinDepositAmount(uint256 newMinAmount) returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactor) ChangeMinDepositAmount(opts *bind.TransactOpts, newMinAmount *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.contract.Transact(opts, "changeMinDepositAmount", newMinAmount)
}

// ChangeMinDepositAmount is a paid mutator transaction binding the contract method 0x8caad7b5.
//
// Solidity: function changeMinDepositAmount(uint256 newMinAmount) returns()
func (_AuctionDepositVault *AuctionDepositVaultSession) ChangeMinDepositAmount(newMinAmount *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.ChangeMinDepositAmount(&_AuctionDepositVault.TransactOpts, newMinAmount)
}

// ChangeMinDepositAmount is a paid mutator transaction binding the contract method 0x8caad7b5.
//
// Solidity: function changeMinDepositAmount(uint256 newMinAmount) returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactorSession) ChangeMinDepositAmount(newMinAmount *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.ChangeMinDepositAmount(&_AuctionDepositVault.TransactOpts, newMinAmount)
}

// ChangeMinWithdrawLocktime is a paid mutator transaction binding the contract method 0x39253624.
//
// Solidity: function changeMinWithdrawLocktime(uint256 newLocktime) returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactor) ChangeMinWithdrawLocktime(opts *bind.TransactOpts, newLocktime *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.contract.Transact(opts, "changeMinWithdrawLocktime", newLocktime)
}

// ChangeMinWithdrawLocktime is a paid mutator transaction binding the contract method 0x39253624.
//
// Solidity: function changeMinWithdrawLocktime(uint256 newLocktime) returns()
func (_AuctionDepositVault *AuctionDepositVaultSession) ChangeMinWithdrawLocktime(newLocktime *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.ChangeMinWithdrawLocktime(&_AuctionDepositVault.TransactOpts, newLocktime)
}

// ChangeMinWithdrawLocktime is a paid mutator transaction binding the contract method 0x39253624.
//
// Solidity: function changeMinWithdrawLocktime(uint256 newLocktime) returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactorSession) ChangeMinWithdrawLocktime(newLocktime *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.ChangeMinWithdrawLocktime(&_AuctionDepositVault.TransactOpts, newLocktime)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactor) Deposit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionDepositVault.contract.Transact(opts, "deposit")
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_AuctionDepositVault *AuctionDepositVaultSession) Deposit() (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.Deposit(&_AuctionDepositVault.TransactOpts)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactorSession) Deposit() (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.Deposit(&_AuctionDepositVault.TransactOpts)
}

// DepositFor is a paid mutator transaction binding the contract method 0xaa67c919.
//
// Solidity: function depositFor(address searcher) payable returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactor) DepositFor(opts *bind.TransactOpts, searcher common.Address) (*types.Transaction, error) {
	return _AuctionDepositVault.contract.Transact(opts, "depositFor", searcher)
}

// DepositFor is a paid mutator transaction binding the contract method 0xaa67c919.
//
// Solidity: function depositFor(address searcher) payable returns()
func (_AuctionDepositVault *AuctionDepositVaultSession) DepositFor(searcher common.Address) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.DepositFor(&_AuctionDepositVault.TransactOpts, searcher)
}

// DepositFor is a paid mutator transaction binding the contract method 0xaa67c919.
//
// Solidity: function depositFor(address searcher) payable returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactorSession) DepositFor(searcher common.Address) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.DepositFor(&_AuctionDepositVault.TransactOpts, searcher)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionDepositVault.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_AuctionDepositVault *AuctionDepositVaultSession) RenounceOwnership() (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.RenounceOwnership(&_AuctionDepositVault.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.RenounceOwnership(&_AuctionDepositVault.TransactOpts)
}

// ReserveWithdraw is a paid mutator transaction binding the contract method 0xbea39cab.
//
// Solidity: function reserveWithdraw() returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactor) ReserveWithdraw(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionDepositVault.contract.Transact(opts, "reserveWithdraw")
}

// ReserveWithdraw is a paid mutator transaction binding the contract method 0xbea39cab.
//
// Solidity: function reserveWithdraw() returns()
func (_AuctionDepositVault *AuctionDepositVaultSession) ReserveWithdraw() (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.ReserveWithdraw(&_AuctionDepositVault.TransactOpts)
}

// ReserveWithdraw is a paid mutator transaction binding the contract method 0xbea39cab.
//
// Solidity: function reserveWithdraw() returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactorSession) ReserveWithdraw() (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.ReserveWithdraw(&_AuctionDepositVault.TransactOpts)
}

// TakeBid is a paid mutator transaction binding the contract method 0x08bf759d.
//
// Solidity: function takeBid(address searcher, uint256 amount) returns(bool)
func (_AuctionDepositVault *AuctionDepositVaultTransactor) TakeBid(opts *bind.TransactOpts, searcher common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.contract.Transact(opts, "takeBid", searcher, amount)
}

// TakeBid is a paid mutator transaction binding the contract method 0x08bf759d.
//
// Solidity: function takeBid(address searcher, uint256 amount) returns(bool)
func (_AuctionDepositVault *AuctionDepositVaultSession) TakeBid(searcher common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.TakeBid(&_AuctionDepositVault.TransactOpts, searcher, amount)
}

// TakeBid is a paid mutator transaction binding the contract method 0x08bf759d.
//
// Solidity: function takeBid(address searcher, uint256 amount) returns(bool)
func (_AuctionDepositVault *AuctionDepositVaultTransactorSession) TakeBid(searcher common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.TakeBid(&_AuctionDepositVault.TransactOpts, searcher, amount)
}

// TakeGas is a paid mutator transaction binding the contract method 0xb4fdfae5.
//
// Solidity: function takeGas(address searcher, uint256 gasUsed) returns(bool)
func (_AuctionDepositVault *AuctionDepositVaultTransactor) TakeGas(opts *bind.TransactOpts, searcher common.Address, gasUsed *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.contract.Transact(opts, "takeGas", searcher, gasUsed)
}

// TakeGas is a paid mutator transaction binding the contract method 0xb4fdfae5.
//
// Solidity: function takeGas(address searcher, uint256 gasUsed) returns(bool)
func (_AuctionDepositVault *AuctionDepositVaultSession) TakeGas(searcher common.Address, gasUsed *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.TakeGas(&_AuctionDepositVault.TransactOpts, searcher, gasUsed)
}

// TakeGas is a paid mutator transaction binding the contract method 0xb4fdfae5.
//
// Solidity: function takeGas(address searcher, uint256 gasUsed) returns(bool)
func (_AuctionDepositVault *AuctionDepositVaultTransactorSession) TakeGas(searcher common.Address, gasUsed *big.Int) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.TakeGas(&_AuctionDepositVault.TransactOpts, searcher, gasUsed)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _AuctionDepositVault.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AuctionDepositVault *AuctionDepositVaultSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.TransferOwnership(&_AuctionDepositVault.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.TransferOwnership(&_AuctionDepositVault.TransactOpts, newOwner)
}

// Withdraw is a paid mutator transaction binding the contract method 0x3ccfd60b.
//
// Solidity: function withdraw() returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactor) Withdraw(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionDepositVault.contract.Transact(opts, "withdraw")
}

// Withdraw is a paid mutator transaction binding the contract method 0x3ccfd60b.
//
// Solidity: function withdraw() returns()
func (_AuctionDepositVault *AuctionDepositVaultSession) Withdraw() (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.Withdraw(&_AuctionDepositVault.TransactOpts)
}

// Withdraw is a paid mutator transaction binding the contract method 0x3ccfd60b.
//
// Solidity: function withdraw() returns()
func (_AuctionDepositVault *AuctionDepositVaultTransactorSession) Withdraw() (*types.Transaction, error) {
	return _AuctionDepositVault.Contract.Withdraw(&_AuctionDepositVault.TransactOpts)
}

// AuctionDepositVaultChangeAuctionFeeVaultIterator is returned from FilterChangeAuctionFeeVault and is used to iterate over the raw logs and unpacked data for ChangeAuctionFeeVault events raised by the AuctionDepositVault contract.
type AuctionDepositVaultChangeAuctionFeeVaultIterator struct {
	Event *AuctionDepositVaultChangeAuctionFeeVault // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultChangeAuctionFeeVaultIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultChangeAuctionFeeVault)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultChangeAuctionFeeVault)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultChangeAuctionFeeVaultIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultChangeAuctionFeeVaultIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultChangeAuctionFeeVault represents a ChangeAuctionFeeVault event raised by the AuctionDepositVault contract.
type AuctionDepositVaultChangeAuctionFeeVault struct {
	OldFeeVault common.Address
	NewFeeVault common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterChangeAuctionFeeVault is a free log retrieval operation binding the contract event 0x384b2820c6944bcf938c3d8c170a4421377f8e7a397ffb5ff321b8dce59bb97d.
//
// Solidity: event ChangeAuctionFeeVault(address oldFeeVault, address newFeeVault)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterChangeAuctionFeeVault(opts *bind.FilterOpts) (*AuctionDepositVaultChangeAuctionFeeVaultIterator, error) {

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "ChangeAuctionFeeVault")
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultChangeAuctionFeeVaultIterator{contract: _AuctionDepositVault.contract, event: "ChangeAuctionFeeVault", logs: logs, sub: sub}, nil
}

// WatchChangeAuctionFeeVault is a free log subscription operation binding the contract event 0x384b2820c6944bcf938c3d8c170a4421377f8e7a397ffb5ff321b8dce59bb97d.
//
// Solidity: event ChangeAuctionFeeVault(address oldFeeVault, address newFeeVault)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchChangeAuctionFeeVault(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultChangeAuctionFeeVault) (event.Subscription, error) {

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "ChangeAuctionFeeVault")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultChangeAuctionFeeVault)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "ChangeAuctionFeeVault", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeAuctionFeeVault is a log parse operation binding the contract event 0x384b2820c6944bcf938c3d8c170a4421377f8e7a397ffb5ff321b8dce59bb97d.
//
// Solidity: event ChangeAuctionFeeVault(address oldFeeVault, address newFeeVault)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseChangeAuctionFeeVault(log types.Log) (*AuctionDepositVaultChangeAuctionFeeVault, error) {
	event := new(AuctionDepositVaultChangeAuctionFeeVault)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "ChangeAuctionFeeVault", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionDepositVaultChangeMinDepositAmountIterator is returned from FilterChangeMinDepositAmount and is used to iterate over the raw logs and unpacked data for ChangeMinDepositAmount events raised by the AuctionDepositVault contract.
type AuctionDepositVaultChangeMinDepositAmountIterator struct {
	Event *AuctionDepositVaultChangeMinDepositAmount // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultChangeMinDepositAmountIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultChangeMinDepositAmount)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultChangeMinDepositAmount)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultChangeMinDepositAmountIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultChangeMinDepositAmountIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultChangeMinDepositAmount represents a ChangeMinDepositAmount event raised by the AuctionDepositVault contract.
type AuctionDepositVaultChangeMinDepositAmount struct {
	OldAmount *big.Int
	NewAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterChangeMinDepositAmount is a free log retrieval operation binding the contract event 0x404f17a8e681362e0d411e6b9b82111f6f7657596601fbe44eb9e2c960438f54.
//
// Solidity: event ChangeMinDepositAmount(uint256 oldAmount, uint256 newAmount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterChangeMinDepositAmount(opts *bind.FilterOpts) (*AuctionDepositVaultChangeMinDepositAmountIterator, error) {

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "ChangeMinDepositAmount")
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultChangeMinDepositAmountIterator{contract: _AuctionDepositVault.contract, event: "ChangeMinDepositAmount", logs: logs, sub: sub}, nil
}

// WatchChangeMinDepositAmount is a free log subscription operation binding the contract event 0x404f17a8e681362e0d411e6b9b82111f6f7657596601fbe44eb9e2c960438f54.
//
// Solidity: event ChangeMinDepositAmount(uint256 oldAmount, uint256 newAmount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchChangeMinDepositAmount(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultChangeMinDepositAmount) (event.Subscription, error) {

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "ChangeMinDepositAmount")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultChangeMinDepositAmount)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "ChangeMinDepositAmount", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeMinDepositAmount is a log parse operation binding the contract event 0x404f17a8e681362e0d411e6b9b82111f6f7657596601fbe44eb9e2c960438f54.
//
// Solidity: event ChangeMinDepositAmount(uint256 oldAmount, uint256 newAmount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseChangeMinDepositAmount(log types.Log) (*AuctionDepositVaultChangeMinDepositAmount, error) {
	event := new(AuctionDepositVaultChangeMinDepositAmount)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "ChangeMinDepositAmount", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionDepositVaultChangeMinWithdrawLocktimeIterator is returned from FilterChangeMinWithdrawLocktime and is used to iterate over the raw logs and unpacked data for ChangeMinWithdrawLocktime events raised by the AuctionDepositVault contract.
type AuctionDepositVaultChangeMinWithdrawLocktimeIterator struct {
	Event *AuctionDepositVaultChangeMinWithdrawLocktime // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultChangeMinWithdrawLocktimeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultChangeMinWithdrawLocktime)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultChangeMinWithdrawLocktime)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultChangeMinWithdrawLocktimeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultChangeMinWithdrawLocktimeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultChangeMinWithdrawLocktime represents a ChangeMinWithdrawLocktime event raised by the AuctionDepositVault contract.
type AuctionDepositVaultChangeMinWithdrawLocktime struct {
	OldLocktime *big.Int
	NewLocktime *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterChangeMinWithdrawLocktime is a free log retrieval operation binding the contract event 0x5e273c905caf5b3f4d3a98caf8814cdccb3860b2b334a58140b692fcf28b286d.
//
// Solidity: event ChangeMinWithdrawLocktime(uint256 oldLocktime, uint256 newLocktime)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterChangeMinWithdrawLocktime(opts *bind.FilterOpts) (*AuctionDepositVaultChangeMinWithdrawLocktimeIterator, error) {

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "ChangeMinWithdrawLocktime")
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultChangeMinWithdrawLocktimeIterator{contract: _AuctionDepositVault.contract, event: "ChangeMinWithdrawLocktime", logs: logs, sub: sub}, nil
}

// WatchChangeMinWithdrawLocktime is a free log subscription operation binding the contract event 0x5e273c905caf5b3f4d3a98caf8814cdccb3860b2b334a58140b692fcf28b286d.
//
// Solidity: event ChangeMinWithdrawLocktime(uint256 oldLocktime, uint256 newLocktime)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchChangeMinWithdrawLocktime(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultChangeMinWithdrawLocktime) (event.Subscription, error) {

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "ChangeMinWithdrawLocktime")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultChangeMinWithdrawLocktime)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "ChangeMinWithdrawLocktime", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeMinWithdrawLocktime is a log parse operation binding the contract event 0x5e273c905caf5b3f4d3a98caf8814cdccb3860b2b334a58140b692fcf28b286d.
//
// Solidity: event ChangeMinWithdrawLocktime(uint256 oldLocktime, uint256 newLocktime)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseChangeMinWithdrawLocktime(log types.Log) (*AuctionDepositVaultChangeMinWithdrawLocktime, error) {
	event := new(AuctionDepositVaultChangeMinWithdrawLocktime)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "ChangeMinWithdrawLocktime", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionDepositVaultInsufficientBalanceIterator is returned from FilterInsufficientBalance and is used to iterate over the raw logs and unpacked data for InsufficientBalance events raised by the AuctionDepositVault contract.
type AuctionDepositVaultInsufficientBalanceIterator struct {
	Event *AuctionDepositVaultInsufficientBalance // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultInsufficientBalanceIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultInsufficientBalance)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultInsufficientBalance)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultInsufficientBalanceIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultInsufficientBalanceIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultInsufficientBalance represents a InsufficientBalance event raised by the AuctionDepositVault contract.
type AuctionDepositVaultInsufficientBalance struct {
	Searcher common.Address
	Balance  *big.Int
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterInsufficientBalance is a free log retrieval operation binding the contract event 0xdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c4.
//
// Solidity: event InsufficientBalance(address searcher, uint256 balance, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterInsufficientBalance(opts *bind.FilterOpts) (*AuctionDepositVaultInsufficientBalanceIterator, error) {

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "InsufficientBalance")
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultInsufficientBalanceIterator{contract: _AuctionDepositVault.contract, event: "InsufficientBalance", logs: logs, sub: sub}, nil
}

// WatchInsufficientBalance is a free log subscription operation binding the contract event 0xdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c4.
//
// Solidity: event InsufficientBalance(address searcher, uint256 balance, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchInsufficientBalance(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultInsufficientBalance) (event.Subscription, error) {

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "InsufficientBalance")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultInsufficientBalance)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "InsufficientBalance", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInsufficientBalance is a log parse operation binding the contract event 0xdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c4.
//
// Solidity: event InsufficientBalance(address searcher, uint256 balance, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseInsufficientBalance(log types.Log) (*AuctionDepositVaultInsufficientBalance, error) {
	event := new(AuctionDepositVaultInsufficientBalance)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "InsufficientBalance", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionDepositVaultOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the AuctionDepositVault contract.
type AuctionDepositVaultOwnershipTransferredIterator struct {
	Event *AuctionDepositVaultOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultOwnershipTransferred represents a OwnershipTransferred event raised by the AuctionDepositVault contract.
type AuctionDepositVaultOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*AuctionDepositVaultOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultOwnershipTransferredIterator{contract: _AuctionDepositVault.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultOwnershipTransferred)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseOwnershipTransferred(log types.Log) (*AuctionDepositVaultOwnershipTransferred, error) {
	event := new(AuctionDepositVaultOwnershipTransferred)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionDepositVaultTakenBidIterator is returned from FilterTakenBid and is used to iterate over the raw logs and unpacked data for TakenBid events raised by the AuctionDepositVault contract.
type AuctionDepositVaultTakenBidIterator struct {
	Event *AuctionDepositVaultTakenBid // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultTakenBidIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultTakenBid)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultTakenBid)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultTakenBidIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultTakenBidIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultTakenBid represents a TakenBid event raised by the AuctionDepositVault contract.
type AuctionDepositVaultTakenBid struct {
	Searcher common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTakenBid is a free log retrieval operation binding the contract event 0xbf3f09205213cdb412585918db004ac3947fcd2db1f85fdbb20faaa950e08d2e.
//
// Solidity: event TakenBid(address searcher, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterTakenBid(opts *bind.FilterOpts) (*AuctionDepositVaultTakenBidIterator, error) {

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "TakenBid")
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultTakenBidIterator{contract: _AuctionDepositVault.contract, event: "TakenBid", logs: logs, sub: sub}, nil
}

// WatchTakenBid is a free log subscription operation binding the contract event 0xbf3f09205213cdb412585918db004ac3947fcd2db1f85fdbb20faaa950e08d2e.
//
// Solidity: event TakenBid(address searcher, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchTakenBid(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultTakenBid) (event.Subscription, error) {

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "TakenBid")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultTakenBid)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "TakenBid", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenBid is a log parse operation binding the contract event 0xbf3f09205213cdb412585918db004ac3947fcd2db1f85fdbb20faaa950e08d2e.
//
// Solidity: event TakenBid(address searcher, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseTakenBid(log types.Log) (*AuctionDepositVaultTakenBid, error) {
	event := new(AuctionDepositVaultTakenBid)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "TakenBid", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionDepositVaultTakenBidFailedIterator is returned from FilterTakenBidFailed and is used to iterate over the raw logs and unpacked data for TakenBidFailed events raised by the AuctionDepositVault contract.
type AuctionDepositVaultTakenBidFailedIterator struct {
	Event *AuctionDepositVaultTakenBidFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultTakenBidFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultTakenBidFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultTakenBidFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultTakenBidFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultTakenBidFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultTakenBidFailed represents a TakenBidFailed event raised by the AuctionDepositVault contract.
type AuctionDepositVaultTakenBidFailed struct {
	Searcher common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTakenBidFailed is a free log retrieval operation binding the contract event 0xd26b9fcb04629bad3365ea66f0f4d563e8c71753e7ee1a0c601f1a02ceebed8b.
//
// Solidity: event TakenBidFailed(address searcher, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterTakenBidFailed(opts *bind.FilterOpts) (*AuctionDepositVaultTakenBidFailedIterator, error) {

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "TakenBidFailed")
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultTakenBidFailedIterator{contract: _AuctionDepositVault.contract, event: "TakenBidFailed", logs: logs, sub: sub}, nil
}

// WatchTakenBidFailed is a free log subscription operation binding the contract event 0xd26b9fcb04629bad3365ea66f0f4d563e8c71753e7ee1a0c601f1a02ceebed8b.
//
// Solidity: event TakenBidFailed(address searcher, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchTakenBidFailed(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultTakenBidFailed) (event.Subscription, error) {

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "TakenBidFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultTakenBidFailed)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "TakenBidFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenBidFailed is a log parse operation binding the contract event 0xd26b9fcb04629bad3365ea66f0f4d563e8c71753e7ee1a0c601f1a02ceebed8b.
//
// Solidity: event TakenBidFailed(address searcher, uint256 amount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseTakenBidFailed(log types.Log) (*AuctionDepositVaultTakenBidFailed, error) {
	event := new(AuctionDepositVaultTakenBidFailed)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "TakenBidFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionDepositVaultTakenGasIterator is returned from FilterTakenGas and is used to iterate over the raw logs and unpacked data for TakenGas events raised by the AuctionDepositVault contract.
type AuctionDepositVaultTakenGasIterator struct {
	Event *AuctionDepositVaultTakenGas // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultTakenGasIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultTakenGas)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultTakenGas)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultTakenGasIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultTakenGasIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultTakenGas represents a TakenGas event raised by the AuctionDepositVault contract.
type AuctionDepositVaultTakenGas struct {
	Searcher  common.Address
	GasAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterTakenGas is a free log retrieval operation binding the contract event 0x672970b97597bfb4460c604bb4adc66538c7b00a40bfb2cb9b6566f1692266fd.
//
// Solidity: event TakenGas(address searcher, uint256 gasAmount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterTakenGas(opts *bind.FilterOpts) (*AuctionDepositVaultTakenGasIterator, error) {

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "TakenGas")
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultTakenGasIterator{contract: _AuctionDepositVault.contract, event: "TakenGas", logs: logs, sub: sub}, nil
}

// WatchTakenGas is a free log subscription operation binding the contract event 0x672970b97597bfb4460c604bb4adc66538c7b00a40bfb2cb9b6566f1692266fd.
//
// Solidity: event TakenGas(address searcher, uint256 gasAmount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchTakenGas(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultTakenGas) (event.Subscription, error) {

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "TakenGas")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultTakenGas)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "TakenGas", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenGas is a log parse operation binding the contract event 0x672970b97597bfb4460c604bb4adc66538c7b00a40bfb2cb9b6566f1692266fd.
//
// Solidity: event TakenGas(address searcher, uint256 gasAmount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseTakenGas(log types.Log) (*AuctionDepositVaultTakenGas, error) {
	event := new(AuctionDepositVaultTakenGas)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "TakenGas", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionDepositVaultTakenGasFailedIterator is returned from FilterTakenGasFailed and is used to iterate over the raw logs and unpacked data for TakenGasFailed events raised by the AuctionDepositVault contract.
type AuctionDepositVaultTakenGasFailedIterator struct {
	Event *AuctionDepositVaultTakenGasFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultTakenGasFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultTakenGasFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultTakenGasFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultTakenGasFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultTakenGasFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultTakenGasFailed represents a TakenGasFailed event raised by the AuctionDepositVault contract.
type AuctionDepositVaultTakenGasFailed struct {
	Searcher  common.Address
	GasAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterTakenGasFailed is a free log retrieval operation binding the contract event 0x53605ab3492a9ae1542e049df64874ee628a589811e81b2594f416e9d092b7ca.
//
// Solidity: event TakenGasFailed(address searcher, uint256 gasAmount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterTakenGasFailed(opts *bind.FilterOpts) (*AuctionDepositVaultTakenGasFailedIterator, error) {

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "TakenGasFailed")
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultTakenGasFailedIterator{contract: _AuctionDepositVault.contract, event: "TakenGasFailed", logs: logs, sub: sub}, nil
}

// WatchTakenGasFailed is a free log subscription operation binding the contract event 0x53605ab3492a9ae1542e049df64874ee628a589811e81b2594f416e9d092b7ca.
//
// Solidity: event TakenGasFailed(address searcher, uint256 gasAmount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchTakenGasFailed(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultTakenGasFailed) (event.Subscription, error) {

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "TakenGasFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultTakenGasFailed)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "TakenGasFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenGasFailed is a log parse operation binding the contract event 0x53605ab3492a9ae1542e049df64874ee628a589811e81b2594f416e9d092b7ca.
//
// Solidity: event TakenGasFailed(address searcher, uint256 gasAmount)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseTakenGasFailed(log types.Log) (*AuctionDepositVaultTakenGasFailed, error) {
	event := new(AuctionDepositVaultTakenGasFailed)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "TakenGasFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionDepositVaultVaultDepositIterator is returned from FilterVaultDeposit and is used to iterate over the raw logs and unpacked data for VaultDeposit events raised by the AuctionDepositVault contract.
type AuctionDepositVaultVaultDepositIterator struct {
	Event *AuctionDepositVaultVaultDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultVaultDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultVaultDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultVaultDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultVaultDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultVaultDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultVaultDeposit represents a VaultDeposit event raised by the AuctionDepositVault contract.
type AuctionDepositVaultVaultDeposit struct {
	Searcher    common.Address
	Amount      *big.Int
	TotalAmount *big.Int
	Nonce       *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterVaultDeposit is a free log retrieval operation binding the contract event 0xb356f70fb7268cd9ebf6cd2c25e8628582435a3754305d2edade9b81c0961181.
//
// Solidity: event VaultDeposit(address searcher, uint256 amount, uint256 totalAmount, uint256 nonce)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterVaultDeposit(opts *bind.FilterOpts) (*AuctionDepositVaultVaultDepositIterator, error) {

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "VaultDeposit")
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultVaultDepositIterator{contract: _AuctionDepositVault.contract, event: "VaultDeposit", logs: logs, sub: sub}, nil
}

// WatchVaultDeposit is a free log subscription operation binding the contract event 0xb356f70fb7268cd9ebf6cd2c25e8628582435a3754305d2edade9b81c0961181.
//
// Solidity: event VaultDeposit(address searcher, uint256 amount, uint256 totalAmount, uint256 nonce)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchVaultDeposit(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultVaultDeposit) (event.Subscription, error) {

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "VaultDeposit")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultVaultDeposit)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "VaultDeposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVaultDeposit is a log parse operation binding the contract event 0xb356f70fb7268cd9ebf6cd2c25e8628582435a3754305d2edade9b81c0961181.
//
// Solidity: event VaultDeposit(address searcher, uint256 amount, uint256 totalAmount, uint256 nonce)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseVaultDeposit(log types.Log) (*AuctionDepositVaultVaultDeposit, error) {
	event := new(AuctionDepositVaultVaultDeposit)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "VaultDeposit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionDepositVaultVaultReserveWithdrawIterator is returned from FilterVaultReserveWithdraw and is used to iterate over the raw logs and unpacked data for VaultReserveWithdraw events raised by the AuctionDepositVault contract.
type AuctionDepositVaultVaultReserveWithdrawIterator struct {
	Event *AuctionDepositVaultVaultReserveWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultVaultReserveWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultVaultReserveWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultVaultReserveWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultVaultReserveWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultVaultReserveWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultVaultReserveWithdraw represents a VaultReserveWithdraw event raised by the AuctionDepositVault contract.
type AuctionDepositVaultVaultReserveWithdraw struct {
	Searcher common.Address
	Amount   *big.Int
	Nonce    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterVaultReserveWithdraw is a free log retrieval operation binding the contract event 0x89312dfc642f95af3c0376f434dd92d2ce54d713297a8df3921828edbd2ef1a1.
//
// Solidity: event VaultReserveWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterVaultReserveWithdraw(opts *bind.FilterOpts) (*AuctionDepositVaultVaultReserveWithdrawIterator, error) {

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "VaultReserveWithdraw")
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultVaultReserveWithdrawIterator{contract: _AuctionDepositVault.contract, event: "VaultReserveWithdraw", logs: logs, sub: sub}, nil
}

// WatchVaultReserveWithdraw is a free log subscription operation binding the contract event 0x89312dfc642f95af3c0376f434dd92d2ce54d713297a8df3921828edbd2ef1a1.
//
// Solidity: event VaultReserveWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchVaultReserveWithdraw(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultVaultReserveWithdraw) (event.Subscription, error) {

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "VaultReserveWithdraw")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultVaultReserveWithdraw)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "VaultReserveWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVaultReserveWithdraw is a log parse operation binding the contract event 0x89312dfc642f95af3c0376f434dd92d2ce54d713297a8df3921828edbd2ef1a1.
//
// Solidity: event VaultReserveWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseVaultReserveWithdraw(log types.Log) (*AuctionDepositVaultVaultReserveWithdraw, error) {
	event := new(AuctionDepositVaultVaultReserveWithdraw)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "VaultReserveWithdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionDepositVaultVaultWithdrawIterator is returned from FilterVaultWithdraw and is used to iterate over the raw logs and unpacked data for VaultWithdraw events raised by the AuctionDepositVault contract.
type AuctionDepositVaultVaultWithdrawIterator struct {
	Event *AuctionDepositVaultVaultWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionDepositVaultVaultWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionDepositVaultVaultWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionDepositVaultVaultWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionDepositVaultVaultWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionDepositVaultVaultWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionDepositVaultVaultWithdraw represents a VaultWithdraw event raised by the AuctionDepositVault contract.
type AuctionDepositVaultVaultWithdraw struct {
	Searcher common.Address
	Amount   *big.Int
	Nonce    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterVaultWithdraw is a free log retrieval operation binding the contract event 0x97c7b889c23f0ecb7c22eac5c58266eae022989cfdbd9b6dcf63417338c787de.
//
// Solidity: event VaultWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) FilterVaultWithdraw(opts *bind.FilterOpts) (*AuctionDepositVaultVaultWithdrawIterator, error) {

	logs, sub, err := _AuctionDepositVault.contract.FilterLogs(opts, "VaultWithdraw")
	if err != nil {
		return nil, err
	}
	return &AuctionDepositVaultVaultWithdrawIterator{contract: _AuctionDepositVault.contract, event: "VaultWithdraw", logs: logs, sub: sub}, nil
}

// WatchVaultWithdraw is a free log subscription operation binding the contract event 0x97c7b889c23f0ecb7c22eac5c58266eae022989cfdbd9b6dcf63417338c787de.
//
// Solidity: event VaultWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) WatchVaultWithdraw(opts *bind.WatchOpts, sink chan<- *AuctionDepositVaultVaultWithdraw) (event.Subscription, error) {

	logs, sub, err := _AuctionDepositVault.contract.WatchLogs(opts, "VaultWithdraw")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionDepositVaultVaultWithdraw)
				if err := _AuctionDepositVault.contract.UnpackLog(event, "VaultWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVaultWithdraw is a log parse operation binding the contract event 0x97c7b889c23f0ecb7c22eac5c58266eae022989cfdbd9b6dcf63417338c787de.
//
// Solidity: event VaultWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_AuctionDepositVault *AuctionDepositVaultFilterer) ParseVaultWithdraw(log types.Log) (*AuctionDepositVaultVaultWithdraw, error) {
	event := new(AuctionDepositVaultVaultWithdraw)
	if err := _AuctionDepositVault.contract.UnpackLog(event, "VaultWithdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionErrorMetaData contains all meta data concerning the AuctionError contract.
var AuctionErrorMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"EmptyDepositVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinDepositNotOver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAuctionDepositVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyEntryPoint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyProposer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyStakingAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawReservationExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalNotAllowedYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroDepositAmount\",\"type\":\"error\"}]",
	Bin: "0x6080604052348015600e575f80fd5b50603e80601a5f395ff3fe60806040525f80fdfea26469706673582212207528d0d43ae476e30651a0be079c16a1af03532761e8a907f228cacf87ea7d1264736f6c63430008190033",
}

// AuctionErrorABI is the input ABI used to generate the binding from.
// Deprecated: Use AuctionErrorMetaData.ABI instead.
var AuctionErrorABI = AuctionErrorMetaData.ABI

// AuctionErrorBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const AuctionErrorBinRuntime = `60806040525f80fdfea26469706673582212207528d0d43ae476e30651a0be079c16a1af03532761e8a907f228cacf87ea7d1264736f6c63430008190033`

// AuctionErrorBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AuctionErrorMetaData.Bin instead.
var AuctionErrorBin = AuctionErrorMetaData.Bin

// DeployAuctionError deploys a new Kaia contract, binding an instance of AuctionError to it.
func DeployAuctionError(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *AuctionError, error) {
	parsed, err := AuctionErrorMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AuctionErrorBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AuctionError{AuctionErrorCaller: AuctionErrorCaller{contract: contract}, AuctionErrorTransactor: AuctionErrorTransactor{contract: contract}, AuctionErrorFilterer: AuctionErrorFilterer{contract: contract}}, nil
}

// AuctionError is an auto generated Go binding around a Kaia contract.
type AuctionError struct {
	AuctionErrorCaller     // Read-only binding to the contract
	AuctionErrorTransactor // Write-only binding to the contract
	AuctionErrorFilterer   // Log filterer for contract events
}

// AuctionErrorCaller is an auto generated read-only Go binding around a Kaia contract.
type AuctionErrorCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionErrorTransactor is an auto generated write-only Go binding around a Kaia contract.
type AuctionErrorTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionErrorFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type AuctionErrorFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionErrorSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type AuctionErrorSession struct {
	Contract     *AuctionError     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AuctionErrorCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type AuctionErrorCallerSession struct {
	Contract *AuctionErrorCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// AuctionErrorTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type AuctionErrorTransactorSession struct {
	Contract     *AuctionErrorTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// AuctionErrorRaw is an auto generated low-level Go binding around a Kaia contract.
type AuctionErrorRaw struct {
	Contract *AuctionError // Generic contract binding to access the raw methods on
}

// AuctionErrorCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type AuctionErrorCallerRaw struct {
	Contract *AuctionErrorCaller // Generic read-only contract binding to access the raw methods on
}

// AuctionErrorTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type AuctionErrorTransactorRaw struct {
	Contract *AuctionErrorTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAuctionError creates a new instance of AuctionError, bound to a specific deployed contract.
func NewAuctionError(address common.Address, backend bind.ContractBackend) (*AuctionError, error) {
	contract, err := bindAuctionError(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AuctionError{AuctionErrorCaller: AuctionErrorCaller{contract: contract}, AuctionErrorTransactor: AuctionErrorTransactor{contract: contract}, AuctionErrorFilterer: AuctionErrorFilterer{contract: contract}}, nil
}

// NewAuctionErrorCaller creates a new read-only instance of AuctionError, bound to a specific deployed contract.
func NewAuctionErrorCaller(address common.Address, caller bind.ContractCaller) (*AuctionErrorCaller, error) {
	contract, err := bindAuctionError(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AuctionErrorCaller{contract: contract}, nil
}

// NewAuctionErrorTransactor creates a new write-only instance of AuctionError, bound to a specific deployed contract.
func NewAuctionErrorTransactor(address common.Address, transactor bind.ContractTransactor) (*AuctionErrorTransactor, error) {
	contract, err := bindAuctionError(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AuctionErrorTransactor{contract: contract}, nil
}

// NewAuctionErrorFilterer creates a new log filterer instance of AuctionError, bound to a specific deployed contract.
func NewAuctionErrorFilterer(address common.Address, filterer bind.ContractFilterer) (*AuctionErrorFilterer, error) {
	contract, err := bindAuctionError(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AuctionErrorFilterer{contract: contract}, nil
}

// bindAuctionError binds a generic wrapper to an already deployed contract.
func bindAuctionError(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AuctionErrorMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AuctionError *AuctionErrorRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AuctionError.Contract.AuctionErrorCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AuctionError *AuctionErrorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionError.Contract.AuctionErrorTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AuctionError *AuctionErrorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AuctionError.Contract.AuctionErrorTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AuctionError *AuctionErrorCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AuctionError.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AuctionError *AuctionErrorTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionError.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AuctionError *AuctionErrorTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AuctionError.Contract.contract.Transact(opts, method, params...)
}

// ContextMetaData contains all meta data concerning the Context contract.
var ContextMetaData = &bind.MetaData{
	ABI: "[]",
}

// ContextABI is the input ABI used to generate the binding from.
// Deprecated: Use ContextMetaData.ABI instead.
var ContextABI = ContextMetaData.ABI

// ContextBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ContextBinRuntime = ``

// Context is an auto generated Go binding around a Kaia contract.
type Context struct {
	ContextCaller     // Read-only binding to the contract
	ContextTransactor // Write-only binding to the contract
	ContextFilterer   // Log filterer for contract events
}

// ContextCaller is an auto generated read-only Go binding around a Kaia contract.
type ContextCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextTransactor is an auto generated write-only Go binding around a Kaia contract.
type ContextTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type ContextFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type ContextSession struct {
	Contract     *Context          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ContextCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type ContextCallerSession struct {
	Contract *ContextCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// ContextTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type ContextTransactorSession struct {
	Contract     *ContextTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ContextRaw is an auto generated low-level Go binding around a Kaia contract.
type ContextRaw struct {
	Contract *Context // Generic contract binding to access the raw methods on
}

// ContextCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type ContextCallerRaw struct {
	Contract *ContextCaller // Generic read-only contract binding to access the raw methods on
}

// ContextTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type ContextTransactorRaw struct {
	Contract *ContextTransactor // Generic write-only contract binding to access the raw methods on
}

// NewContext creates a new instance of Context, bound to a specific deployed contract.
func NewContext(address common.Address, backend bind.ContractBackend) (*Context, error) {
	contract, err := bindContext(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Context{ContextCaller: ContextCaller{contract: contract}, ContextTransactor: ContextTransactor{contract: contract}, ContextFilterer: ContextFilterer{contract: contract}}, nil
}

// NewContextCaller creates a new read-only instance of Context, bound to a specific deployed contract.
func NewContextCaller(address common.Address, caller bind.ContractCaller) (*ContextCaller, error) {
	contract, err := bindContext(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ContextCaller{contract: contract}, nil
}

// NewContextTransactor creates a new write-only instance of Context, bound to a specific deployed contract.
func NewContextTransactor(address common.Address, transactor bind.ContractTransactor) (*ContextTransactor, error) {
	contract, err := bindContext(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ContextTransactor{contract: contract}, nil
}

// NewContextFilterer creates a new log filterer instance of Context, bound to a specific deployed contract.
func NewContextFilterer(address common.Address, filterer bind.ContractFilterer) (*ContextFilterer, error) {
	contract, err := bindContext(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ContextFilterer{contract: contract}, nil
}

// bindContext binds a generic wrapper to an already deployed contract.
func bindContext(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ContextMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.ContextCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.contract.Transact(opts, method, params...)
}

// EnumerableSetMetaData contains all meta data concerning the EnumerableSet contract.
var EnumerableSetMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x60556032600b8282823980515f1a607314602657634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f80fdfea2646970667358221220ab7ec786af90a9f4a47555f20c6e9ec9c8cbd49047b90c75fa05c2991f6f865664736f6c63430008190033",
}

// EnumerableSetABI is the input ABI used to generate the binding from.
// Deprecated: Use EnumerableSetMetaData.ABI instead.
var EnumerableSetABI = EnumerableSetMetaData.ABI

// EnumerableSetBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const EnumerableSetBinRuntime = `730000000000000000000000000000000000000000301460806040525f80fdfea2646970667358221220ab7ec786af90a9f4a47555f20c6e9ec9c8cbd49047b90c75fa05c2991f6f865664736f6c63430008190033`

// EnumerableSetBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use EnumerableSetMetaData.Bin instead.
var EnumerableSetBin = EnumerableSetMetaData.Bin

// DeployEnumerableSet deploys a new Kaia contract, binding an instance of EnumerableSet to it.
func DeployEnumerableSet(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *EnumerableSet, error) {
	parsed, err := EnumerableSetMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(EnumerableSetBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &EnumerableSet{EnumerableSetCaller: EnumerableSetCaller{contract: contract}, EnumerableSetTransactor: EnumerableSetTransactor{contract: contract}, EnumerableSetFilterer: EnumerableSetFilterer{contract: contract}}, nil
}

// EnumerableSet is an auto generated Go binding around a Kaia contract.
type EnumerableSet struct {
	EnumerableSetCaller     // Read-only binding to the contract
	EnumerableSetTransactor // Write-only binding to the contract
	EnumerableSetFilterer   // Log filterer for contract events
}

// EnumerableSetCaller is an auto generated read-only Go binding around a Kaia contract.
type EnumerableSetCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EnumerableSetTransactor is an auto generated write-only Go binding around a Kaia contract.
type EnumerableSetTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EnumerableSetFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type EnumerableSetFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EnumerableSetSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type EnumerableSetSession struct {
	Contract     *EnumerableSet    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// EnumerableSetCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type EnumerableSetCallerSession struct {
	Contract *EnumerableSetCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// EnumerableSetTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type EnumerableSetTransactorSession struct {
	Contract     *EnumerableSetTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// EnumerableSetRaw is an auto generated low-level Go binding around a Kaia contract.
type EnumerableSetRaw struct {
	Contract *EnumerableSet // Generic contract binding to access the raw methods on
}

// EnumerableSetCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type EnumerableSetCallerRaw struct {
	Contract *EnumerableSetCaller // Generic read-only contract binding to access the raw methods on
}

// EnumerableSetTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type EnumerableSetTransactorRaw struct {
	Contract *EnumerableSetTransactor // Generic write-only contract binding to access the raw methods on
}

// NewEnumerableSet creates a new instance of EnumerableSet, bound to a specific deployed contract.
func NewEnumerableSet(address common.Address, backend bind.ContractBackend) (*EnumerableSet, error) {
	contract, err := bindEnumerableSet(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &EnumerableSet{EnumerableSetCaller: EnumerableSetCaller{contract: contract}, EnumerableSetTransactor: EnumerableSetTransactor{contract: contract}, EnumerableSetFilterer: EnumerableSetFilterer{contract: contract}}, nil
}

// NewEnumerableSetCaller creates a new read-only instance of EnumerableSet, bound to a specific deployed contract.
func NewEnumerableSetCaller(address common.Address, caller bind.ContractCaller) (*EnumerableSetCaller, error) {
	contract, err := bindEnumerableSet(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &EnumerableSetCaller{contract: contract}, nil
}

// NewEnumerableSetTransactor creates a new write-only instance of EnumerableSet, bound to a specific deployed contract.
func NewEnumerableSetTransactor(address common.Address, transactor bind.ContractTransactor) (*EnumerableSetTransactor, error) {
	contract, err := bindEnumerableSet(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &EnumerableSetTransactor{contract: contract}, nil
}

// NewEnumerableSetFilterer creates a new log filterer instance of EnumerableSet, bound to a specific deployed contract.
func NewEnumerableSetFilterer(address common.Address, filterer bind.ContractFilterer) (*EnumerableSetFilterer, error) {
	contract, err := bindEnumerableSet(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &EnumerableSetFilterer{contract: contract}, nil
}

// bindEnumerableSet binds a generic wrapper to an already deployed contract.
func bindEnumerableSet(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := EnumerableSetMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EnumerableSet *EnumerableSetRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EnumerableSet.Contract.EnumerableSetCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EnumerableSet *EnumerableSetRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EnumerableSet.Contract.EnumerableSetTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EnumerableSet *EnumerableSetRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EnumerableSet.Contract.EnumerableSetTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EnumerableSet *EnumerableSetCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EnumerableSet.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EnumerableSet *EnumerableSetTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EnumerableSet.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EnumerableSet *EnumerableSetTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EnumerableSet.Contract.contract.Transact(opts, method, params...)
}

// IAuctionDepositVaultMetaData contains all meta data concerning the IAuctionDepositVault contract.
var IAuctionDepositVaultMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeeVault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeVault\",\"type\":\"address\"}],\"name\":\"ChangeAuctionFeeVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ChangeMinDepositAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLocktime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLocktime\",\"type\":\"uint256\"}],\"name\":\"ChangeMinWithdrawLocktime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TakenBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TakenBidFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasAmount\",\"type\":\"uint256\"}],\"name\":\"TakenGas\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasAmount\",\"type\":\"uint256\"}],\"name\":\"TakenGasFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"VaultDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"VaultReserveWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"VaultWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAuctionFeeVault\",\"type\":\"address\"}],\"name\":\"changeAuctionFeeVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinAmount\",\"type\":\"uint256\"}],\"name\":\"changeMinDepositAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLocktime\",\"type\":\"uint256\"}],\"name\":\"changeMinWithdrawLocktime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"}],\"name\":\"depositBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"}],\"name\":\"depositFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getAllAddrsOverMinDeposit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"searchers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"depositAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nonces\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getDepositAddrs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"searchers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositAddrsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"}],\"name\":\"isMinDepositOver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"takeBid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"name\":\"takeGas\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"c2cf75ec": "changeAuctionFeeVault(address)",
		"8caad7b5": "changeMinDepositAmount(uint256)",
		"39253624": "changeMinWithdrawLocktime(uint256)",
		"d0e30db0": "deposit()",
		"1eb903cf": "depositBalances(address)",
		"aa67c919": "depositFor(address)",
		"5be1a55e": "getAllAddrsOverMinDeposit(uint256,uint256)",
		"e45076ac": "getDepositAddrs(uint256,uint256)",
		"84792e0b": "getDepositAddrsLength()",
		"48f928e8": "isMinDepositOver(address)",
		"bea39cab": "reserveWithdraw()",
		"08bf759d": "takeBid(address,uint256)",
		"b4fdfae5": "takeGas(address,uint256)",
		"3ccfd60b": "withdraw()",
	},
}

// IAuctionDepositVaultABI is the input ABI used to generate the binding from.
// Deprecated: Use IAuctionDepositVaultMetaData.ABI instead.
var IAuctionDepositVaultABI = IAuctionDepositVaultMetaData.ABI

// IAuctionDepositVaultBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IAuctionDepositVaultBinRuntime = ``

// Deprecated: Use IAuctionDepositVaultMetaData.Sigs instead.
// IAuctionDepositVaultFuncSigs maps the 4-byte function signature to its string representation.
var IAuctionDepositVaultFuncSigs = IAuctionDepositVaultMetaData.Sigs

// IAuctionDepositVault is an auto generated Go binding around a Kaia contract.
type IAuctionDepositVault struct {
	IAuctionDepositVaultCaller     // Read-only binding to the contract
	IAuctionDepositVaultTransactor // Write-only binding to the contract
	IAuctionDepositVaultFilterer   // Log filterer for contract events
}

// IAuctionDepositVaultCaller is an auto generated read-only Go binding around a Kaia contract.
type IAuctionDepositVaultCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionDepositVaultTransactor is an auto generated write-only Go binding around a Kaia contract.
type IAuctionDepositVaultTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionDepositVaultFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type IAuctionDepositVaultFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionDepositVaultSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type IAuctionDepositVaultSession struct {
	Contract     *IAuctionDepositVault // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IAuctionDepositVaultCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type IAuctionDepositVaultCallerSession struct {
	Contract *IAuctionDepositVaultCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// IAuctionDepositVaultTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type IAuctionDepositVaultTransactorSession struct {
	Contract     *IAuctionDepositVaultTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// IAuctionDepositVaultRaw is an auto generated low-level Go binding around a Kaia contract.
type IAuctionDepositVaultRaw struct {
	Contract *IAuctionDepositVault // Generic contract binding to access the raw methods on
}

// IAuctionDepositVaultCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type IAuctionDepositVaultCallerRaw struct {
	Contract *IAuctionDepositVaultCaller // Generic read-only contract binding to access the raw methods on
}

// IAuctionDepositVaultTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type IAuctionDepositVaultTransactorRaw struct {
	Contract *IAuctionDepositVaultTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAuctionDepositVault creates a new instance of IAuctionDepositVault, bound to a specific deployed contract.
func NewIAuctionDepositVault(address common.Address, backend bind.ContractBackend) (*IAuctionDepositVault, error) {
	contract, err := bindIAuctionDepositVault(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVault{IAuctionDepositVaultCaller: IAuctionDepositVaultCaller{contract: contract}, IAuctionDepositVaultTransactor: IAuctionDepositVaultTransactor{contract: contract}, IAuctionDepositVaultFilterer: IAuctionDepositVaultFilterer{contract: contract}}, nil
}

// NewIAuctionDepositVaultCaller creates a new read-only instance of IAuctionDepositVault, bound to a specific deployed contract.
func NewIAuctionDepositVaultCaller(address common.Address, caller bind.ContractCaller) (*IAuctionDepositVaultCaller, error) {
	contract, err := bindIAuctionDepositVault(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultCaller{contract: contract}, nil
}

// NewIAuctionDepositVaultTransactor creates a new write-only instance of IAuctionDepositVault, bound to a specific deployed contract.
func NewIAuctionDepositVaultTransactor(address common.Address, transactor bind.ContractTransactor) (*IAuctionDepositVaultTransactor, error) {
	contract, err := bindIAuctionDepositVault(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultTransactor{contract: contract}, nil
}

// NewIAuctionDepositVaultFilterer creates a new log filterer instance of IAuctionDepositVault, bound to a specific deployed contract.
func NewIAuctionDepositVaultFilterer(address common.Address, filterer bind.ContractFilterer) (*IAuctionDepositVaultFilterer, error) {
	contract, err := bindIAuctionDepositVault(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultFilterer{contract: contract}, nil
}

// bindIAuctionDepositVault binds a generic wrapper to an already deployed contract.
func bindIAuctionDepositVault(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IAuctionDepositVaultMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuctionDepositVault *IAuctionDepositVaultRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuctionDepositVault.Contract.IAuctionDepositVaultCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuctionDepositVault *IAuctionDepositVaultRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.IAuctionDepositVaultTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuctionDepositVault *IAuctionDepositVaultRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.IAuctionDepositVaultTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuctionDepositVault *IAuctionDepositVaultCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuctionDepositVault.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.contract.Transact(opts, method, params...)
}

// DepositBalances is a free data retrieval call binding the contract method 0x1eb903cf.
//
// Solidity: function depositBalances(address searcher) view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultCaller) DepositBalances(opts *bind.CallOpts, searcher common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IAuctionDepositVault.contract.Call(opts, &out, "depositBalances", searcher)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DepositBalances is a free data retrieval call binding the contract method 0x1eb903cf.
//
// Solidity: function depositBalances(address searcher) view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) DepositBalances(searcher common.Address) (*big.Int, error) {
	return _IAuctionDepositVault.Contract.DepositBalances(&_IAuctionDepositVault.CallOpts, searcher)
}

// DepositBalances is a free data retrieval call binding the contract method 0x1eb903cf.
//
// Solidity: function depositBalances(address searcher) view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultCallerSession) DepositBalances(searcher common.Address) (*big.Int, error) {
	return _IAuctionDepositVault.Contract.DepositBalances(&_IAuctionDepositVault.CallOpts, searcher)
}

// GetAllAddrsOverMinDeposit is a free data retrieval call binding the contract method 0x5be1a55e.
//
// Solidity: function getAllAddrsOverMinDeposit(uint256 start, uint256 limit) view returns(address[] searchers, uint256[] depositAmounts, uint256[] nonces)
func (_IAuctionDepositVault *IAuctionDepositVaultCaller) GetAllAddrsOverMinDeposit(opts *bind.CallOpts, start *big.Int, limit *big.Int) (struct {
	Searchers      []common.Address
	DepositAmounts []*big.Int
	Nonces         []*big.Int
}, error) {
	var out []interface{}
	err := _IAuctionDepositVault.contract.Call(opts, &out, "getAllAddrsOverMinDeposit", start, limit)

	outstruct := new(struct {
		Searchers      []common.Address
		DepositAmounts []*big.Int
		Nonces         []*big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Searchers = *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)
	outstruct.DepositAmounts = *abi.ConvertType(out[1], new([]*big.Int)).(*[]*big.Int)
	outstruct.Nonces = *abi.ConvertType(out[2], new([]*big.Int)).(*[]*big.Int)

	return *outstruct, err

}

// GetAllAddrsOverMinDeposit is a free data retrieval call binding the contract method 0x5be1a55e.
//
// Solidity: function getAllAddrsOverMinDeposit(uint256 start, uint256 limit) view returns(address[] searchers, uint256[] depositAmounts, uint256[] nonces)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) GetAllAddrsOverMinDeposit(start *big.Int, limit *big.Int) (struct {
	Searchers      []common.Address
	DepositAmounts []*big.Int
	Nonces         []*big.Int
}, error) {
	return _IAuctionDepositVault.Contract.GetAllAddrsOverMinDeposit(&_IAuctionDepositVault.CallOpts, start, limit)
}

// GetAllAddrsOverMinDeposit is a free data retrieval call binding the contract method 0x5be1a55e.
//
// Solidity: function getAllAddrsOverMinDeposit(uint256 start, uint256 limit) view returns(address[] searchers, uint256[] depositAmounts, uint256[] nonces)
func (_IAuctionDepositVault *IAuctionDepositVaultCallerSession) GetAllAddrsOverMinDeposit(start *big.Int, limit *big.Int) (struct {
	Searchers      []common.Address
	DepositAmounts []*big.Int
	Nonces         []*big.Int
}, error) {
	return _IAuctionDepositVault.Contract.GetAllAddrsOverMinDeposit(&_IAuctionDepositVault.CallOpts, start, limit)
}

// GetDepositAddrs is a free data retrieval call binding the contract method 0xe45076ac.
//
// Solidity: function getDepositAddrs(uint256 start, uint256 limit) view returns(address[] searchers)
func (_IAuctionDepositVault *IAuctionDepositVaultCaller) GetDepositAddrs(opts *bind.CallOpts, start *big.Int, limit *big.Int) ([]common.Address, error) {
	var out []interface{}
	err := _IAuctionDepositVault.contract.Call(opts, &out, "getDepositAddrs", start, limit)

	if err != nil {
		return *new([]common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)

	return out0, err

}

// GetDepositAddrs is a free data retrieval call binding the contract method 0xe45076ac.
//
// Solidity: function getDepositAddrs(uint256 start, uint256 limit) view returns(address[] searchers)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) GetDepositAddrs(start *big.Int, limit *big.Int) ([]common.Address, error) {
	return _IAuctionDepositVault.Contract.GetDepositAddrs(&_IAuctionDepositVault.CallOpts, start, limit)
}

// GetDepositAddrs is a free data retrieval call binding the contract method 0xe45076ac.
//
// Solidity: function getDepositAddrs(uint256 start, uint256 limit) view returns(address[] searchers)
func (_IAuctionDepositVault *IAuctionDepositVaultCallerSession) GetDepositAddrs(start *big.Int, limit *big.Int) ([]common.Address, error) {
	return _IAuctionDepositVault.Contract.GetDepositAddrs(&_IAuctionDepositVault.CallOpts, start, limit)
}

// GetDepositAddrsLength is a free data retrieval call binding the contract method 0x84792e0b.
//
// Solidity: function getDepositAddrsLength() view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultCaller) GetDepositAddrsLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IAuctionDepositVault.contract.Call(opts, &out, "getDepositAddrsLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetDepositAddrsLength is a free data retrieval call binding the contract method 0x84792e0b.
//
// Solidity: function getDepositAddrsLength() view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) GetDepositAddrsLength() (*big.Int, error) {
	return _IAuctionDepositVault.Contract.GetDepositAddrsLength(&_IAuctionDepositVault.CallOpts)
}

// GetDepositAddrsLength is a free data retrieval call binding the contract method 0x84792e0b.
//
// Solidity: function getDepositAddrsLength() view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultCallerSession) GetDepositAddrsLength() (*big.Int, error) {
	return _IAuctionDepositVault.Contract.GetDepositAddrsLength(&_IAuctionDepositVault.CallOpts)
}

// IsMinDepositOver is a free data retrieval call binding the contract method 0x48f928e8.
//
// Solidity: function isMinDepositOver(address searcher) view returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultCaller) IsMinDepositOver(opts *bind.CallOpts, searcher common.Address) (bool, error) {
	var out []interface{}
	err := _IAuctionDepositVault.contract.Call(opts, &out, "isMinDepositOver", searcher)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsMinDepositOver is a free data retrieval call binding the contract method 0x48f928e8.
//
// Solidity: function isMinDepositOver(address searcher) view returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) IsMinDepositOver(searcher common.Address) (bool, error) {
	return _IAuctionDepositVault.Contract.IsMinDepositOver(&_IAuctionDepositVault.CallOpts, searcher)
}

// IsMinDepositOver is a free data retrieval call binding the contract method 0x48f928e8.
//
// Solidity: function isMinDepositOver(address searcher) view returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultCallerSession) IsMinDepositOver(searcher common.Address) (bool, error) {
	return _IAuctionDepositVault.Contract.IsMinDepositOver(&_IAuctionDepositVault.CallOpts, searcher)
}

// ChangeAuctionFeeVault is a paid mutator transaction binding the contract method 0xc2cf75ec.
//
// Solidity: function changeAuctionFeeVault(address newAuctionFeeVault) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) ChangeAuctionFeeVault(opts *bind.TransactOpts, newAuctionFeeVault common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "changeAuctionFeeVault", newAuctionFeeVault)
}

// ChangeAuctionFeeVault is a paid mutator transaction binding the contract method 0xc2cf75ec.
//
// Solidity: function changeAuctionFeeVault(address newAuctionFeeVault) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) ChangeAuctionFeeVault(newAuctionFeeVault common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeAuctionFeeVault(&_IAuctionDepositVault.TransactOpts, newAuctionFeeVault)
}

// ChangeAuctionFeeVault is a paid mutator transaction binding the contract method 0xc2cf75ec.
//
// Solidity: function changeAuctionFeeVault(address newAuctionFeeVault) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) ChangeAuctionFeeVault(newAuctionFeeVault common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeAuctionFeeVault(&_IAuctionDepositVault.TransactOpts, newAuctionFeeVault)
}

// ChangeMinDepositAmount is a paid mutator transaction binding the contract method 0x8caad7b5.
//
// Solidity: function changeMinDepositAmount(uint256 newMinAmount) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) ChangeMinDepositAmount(opts *bind.TransactOpts, newMinAmount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "changeMinDepositAmount", newMinAmount)
}

// ChangeMinDepositAmount is a paid mutator transaction binding the contract method 0x8caad7b5.
//
// Solidity: function changeMinDepositAmount(uint256 newMinAmount) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) ChangeMinDepositAmount(newMinAmount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeMinDepositAmount(&_IAuctionDepositVault.TransactOpts, newMinAmount)
}

// ChangeMinDepositAmount is a paid mutator transaction binding the contract method 0x8caad7b5.
//
// Solidity: function changeMinDepositAmount(uint256 newMinAmount) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) ChangeMinDepositAmount(newMinAmount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeMinDepositAmount(&_IAuctionDepositVault.TransactOpts, newMinAmount)
}

// ChangeMinWithdrawLocktime is a paid mutator transaction binding the contract method 0x39253624.
//
// Solidity: function changeMinWithdrawLocktime(uint256 newLocktime) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) ChangeMinWithdrawLocktime(opts *bind.TransactOpts, newLocktime *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "changeMinWithdrawLocktime", newLocktime)
}

// ChangeMinWithdrawLocktime is a paid mutator transaction binding the contract method 0x39253624.
//
// Solidity: function changeMinWithdrawLocktime(uint256 newLocktime) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) ChangeMinWithdrawLocktime(newLocktime *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeMinWithdrawLocktime(&_IAuctionDepositVault.TransactOpts, newLocktime)
}

// ChangeMinWithdrawLocktime is a paid mutator transaction binding the contract method 0x39253624.
//
// Solidity: function changeMinWithdrawLocktime(uint256 newLocktime) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) ChangeMinWithdrawLocktime(newLocktime *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeMinWithdrawLocktime(&_IAuctionDepositVault.TransactOpts, newLocktime)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) Deposit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "deposit")
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) Deposit() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.Deposit(&_IAuctionDepositVault.TransactOpts)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) Deposit() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.Deposit(&_IAuctionDepositVault.TransactOpts)
}

// DepositFor is a paid mutator transaction binding the contract method 0xaa67c919.
//
// Solidity: function depositFor(address searcher) payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) DepositFor(opts *bind.TransactOpts, searcher common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "depositFor", searcher)
}

// DepositFor is a paid mutator transaction binding the contract method 0xaa67c919.
//
// Solidity: function depositFor(address searcher) payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) DepositFor(searcher common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.DepositFor(&_IAuctionDepositVault.TransactOpts, searcher)
}

// DepositFor is a paid mutator transaction binding the contract method 0xaa67c919.
//
// Solidity: function depositFor(address searcher) payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) DepositFor(searcher common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.DepositFor(&_IAuctionDepositVault.TransactOpts, searcher)
}

// ReserveWithdraw is a paid mutator transaction binding the contract method 0xbea39cab.
//
// Solidity: function reserveWithdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) ReserveWithdraw(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "reserveWithdraw")
}

// ReserveWithdraw is a paid mutator transaction binding the contract method 0xbea39cab.
//
// Solidity: function reserveWithdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) ReserveWithdraw() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ReserveWithdraw(&_IAuctionDepositVault.TransactOpts)
}

// ReserveWithdraw is a paid mutator transaction binding the contract method 0xbea39cab.
//
// Solidity: function reserveWithdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) ReserveWithdraw() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ReserveWithdraw(&_IAuctionDepositVault.TransactOpts)
}

// TakeBid is a paid mutator transaction binding the contract method 0x08bf759d.
//
// Solidity: function takeBid(address searcher, uint256 amount) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) TakeBid(opts *bind.TransactOpts, searcher common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "takeBid", searcher, amount)
}

// TakeBid is a paid mutator transaction binding the contract method 0x08bf759d.
//
// Solidity: function takeBid(address searcher, uint256 amount) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) TakeBid(searcher common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.TakeBid(&_IAuctionDepositVault.TransactOpts, searcher, amount)
}

// TakeBid is a paid mutator transaction binding the contract method 0x08bf759d.
//
// Solidity: function takeBid(address searcher, uint256 amount) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) TakeBid(searcher common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.TakeBid(&_IAuctionDepositVault.TransactOpts, searcher, amount)
}

// TakeGas is a paid mutator transaction binding the contract method 0xb4fdfae5.
//
// Solidity: function takeGas(address searcher, uint256 gasUsed) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) TakeGas(opts *bind.TransactOpts, searcher common.Address, gasUsed *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "takeGas", searcher, gasUsed)
}

// TakeGas is a paid mutator transaction binding the contract method 0xb4fdfae5.
//
// Solidity: function takeGas(address searcher, uint256 gasUsed) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) TakeGas(searcher common.Address, gasUsed *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.TakeGas(&_IAuctionDepositVault.TransactOpts, searcher, gasUsed)
}

// TakeGas is a paid mutator transaction binding the contract method 0xb4fdfae5.
//
// Solidity: function takeGas(address searcher, uint256 gasUsed) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) TakeGas(searcher common.Address, gasUsed *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.TakeGas(&_IAuctionDepositVault.TransactOpts, searcher, gasUsed)
}

// Withdraw is a paid mutator transaction binding the contract method 0x3ccfd60b.
//
// Solidity: function withdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) Withdraw(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "withdraw")
}

// Withdraw is a paid mutator transaction binding the contract method 0x3ccfd60b.
//
// Solidity: function withdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) Withdraw() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.Withdraw(&_IAuctionDepositVault.TransactOpts)
}

// Withdraw is a paid mutator transaction binding the contract method 0x3ccfd60b.
//
// Solidity: function withdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) Withdraw() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.Withdraw(&_IAuctionDepositVault.TransactOpts)
}

// IAuctionDepositVaultChangeAuctionFeeVaultIterator is returned from FilterChangeAuctionFeeVault and is used to iterate over the raw logs and unpacked data for ChangeAuctionFeeVault events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeAuctionFeeVaultIterator struct {
	Event *IAuctionDepositVaultChangeAuctionFeeVault // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultChangeAuctionFeeVaultIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultChangeAuctionFeeVault)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultChangeAuctionFeeVault)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultChangeAuctionFeeVaultIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultChangeAuctionFeeVaultIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultChangeAuctionFeeVault represents a ChangeAuctionFeeVault event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeAuctionFeeVault struct {
	OldFeeVault common.Address
	NewFeeVault common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterChangeAuctionFeeVault is a free log retrieval operation binding the contract event 0x384b2820c6944bcf938c3d8c170a4421377f8e7a397ffb5ff321b8dce59bb97d.
//
// Solidity: event ChangeAuctionFeeVault(address oldFeeVault, address newFeeVault)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterChangeAuctionFeeVault(opts *bind.FilterOpts) (*IAuctionDepositVaultChangeAuctionFeeVaultIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "ChangeAuctionFeeVault")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultChangeAuctionFeeVaultIterator{contract: _IAuctionDepositVault.contract, event: "ChangeAuctionFeeVault", logs: logs, sub: sub}, nil
}

// WatchChangeAuctionFeeVault is a free log subscription operation binding the contract event 0x384b2820c6944bcf938c3d8c170a4421377f8e7a397ffb5ff321b8dce59bb97d.
//
// Solidity: event ChangeAuctionFeeVault(address oldFeeVault, address newFeeVault)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchChangeAuctionFeeVault(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultChangeAuctionFeeVault) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "ChangeAuctionFeeVault")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultChangeAuctionFeeVault)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeAuctionFeeVault", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeAuctionFeeVault is a log parse operation binding the contract event 0x384b2820c6944bcf938c3d8c170a4421377f8e7a397ffb5ff321b8dce59bb97d.
//
// Solidity: event ChangeAuctionFeeVault(address oldFeeVault, address newFeeVault)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseChangeAuctionFeeVault(log types.Log) (*IAuctionDepositVaultChangeAuctionFeeVault, error) {
	event := new(IAuctionDepositVaultChangeAuctionFeeVault)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeAuctionFeeVault", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultChangeMinDepositAmountIterator is returned from FilterChangeMinDepositAmount and is used to iterate over the raw logs and unpacked data for ChangeMinDepositAmount events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeMinDepositAmountIterator struct {
	Event *IAuctionDepositVaultChangeMinDepositAmount // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultChangeMinDepositAmountIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultChangeMinDepositAmount)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultChangeMinDepositAmount)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultChangeMinDepositAmountIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultChangeMinDepositAmountIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultChangeMinDepositAmount represents a ChangeMinDepositAmount event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeMinDepositAmount struct {
	OldAmount *big.Int
	NewAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterChangeMinDepositAmount is a free log retrieval operation binding the contract event 0x404f17a8e681362e0d411e6b9b82111f6f7657596601fbe44eb9e2c960438f54.
//
// Solidity: event ChangeMinDepositAmount(uint256 oldAmount, uint256 newAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterChangeMinDepositAmount(opts *bind.FilterOpts) (*IAuctionDepositVaultChangeMinDepositAmountIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "ChangeMinDepositAmount")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultChangeMinDepositAmountIterator{contract: _IAuctionDepositVault.contract, event: "ChangeMinDepositAmount", logs: logs, sub: sub}, nil
}

// WatchChangeMinDepositAmount is a free log subscription operation binding the contract event 0x404f17a8e681362e0d411e6b9b82111f6f7657596601fbe44eb9e2c960438f54.
//
// Solidity: event ChangeMinDepositAmount(uint256 oldAmount, uint256 newAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchChangeMinDepositAmount(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultChangeMinDepositAmount) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "ChangeMinDepositAmount")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultChangeMinDepositAmount)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeMinDepositAmount", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeMinDepositAmount is a log parse operation binding the contract event 0x404f17a8e681362e0d411e6b9b82111f6f7657596601fbe44eb9e2c960438f54.
//
// Solidity: event ChangeMinDepositAmount(uint256 oldAmount, uint256 newAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseChangeMinDepositAmount(log types.Log) (*IAuctionDepositVaultChangeMinDepositAmount, error) {
	event := new(IAuctionDepositVaultChangeMinDepositAmount)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeMinDepositAmount", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultChangeMinWithdrawLocktimeIterator is returned from FilterChangeMinWithdrawLocktime and is used to iterate over the raw logs and unpacked data for ChangeMinWithdrawLocktime events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeMinWithdrawLocktimeIterator struct {
	Event *IAuctionDepositVaultChangeMinWithdrawLocktime // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultChangeMinWithdrawLocktimeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultChangeMinWithdrawLocktime)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultChangeMinWithdrawLocktime)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultChangeMinWithdrawLocktimeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultChangeMinWithdrawLocktimeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultChangeMinWithdrawLocktime represents a ChangeMinWithdrawLocktime event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeMinWithdrawLocktime struct {
	OldLocktime *big.Int
	NewLocktime *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterChangeMinWithdrawLocktime is a free log retrieval operation binding the contract event 0x5e273c905caf5b3f4d3a98caf8814cdccb3860b2b334a58140b692fcf28b286d.
//
// Solidity: event ChangeMinWithdrawLocktime(uint256 oldLocktime, uint256 newLocktime)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterChangeMinWithdrawLocktime(opts *bind.FilterOpts) (*IAuctionDepositVaultChangeMinWithdrawLocktimeIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "ChangeMinWithdrawLocktime")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultChangeMinWithdrawLocktimeIterator{contract: _IAuctionDepositVault.contract, event: "ChangeMinWithdrawLocktime", logs: logs, sub: sub}, nil
}

// WatchChangeMinWithdrawLocktime is a free log subscription operation binding the contract event 0x5e273c905caf5b3f4d3a98caf8814cdccb3860b2b334a58140b692fcf28b286d.
//
// Solidity: event ChangeMinWithdrawLocktime(uint256 oldLocktime, uint256 newLocktime)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchChangeMinWithdrawLocktime(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultChangeMinWithdrawLocktime) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "ChangeMinWithdrawLocktime")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultChangeMinWithdrawLocktime)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeMinWithdrawLocktime", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeMinWithdrawLocktime is a log parse operation binding the contract event 0x5e273c905caf5b3f4d3a98caf8814cdccb3860b2b334a58140b692fcf28b286d.
//
// Solidity: event ChangeMinWithdrawLocktime(uint256 oldLocktime, uint256 newLocktime)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseChangeMinWithdrawLocktime(log types.Log) (*IAuctionDepositVaultChangeMinWithdrawLocktime, error) {
	event := new(IAuctionDepositVaultChangeMinWithdrawLocktime)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeMinWithdrawLocktime", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultInsufficientBalanceIterator is returned from FilterInsufficientBalance and is used to iterate over the raw logs and unpacked data for InsufficientBalance events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultInsufficientBalanceIterator struct {
	Event *IAuctionDepositVaultInsufficientBalance // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultInsufficientBalanceIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultInsufficientBalance)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultInsufficientBalance)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultInsufficientBalanceIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultInsufficientBalanceIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultInsufficientBalance represents a InsufficientBalance event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultInsufficientBalance struct {
	Searcher common.Address
	Balance  *big.Int
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterInsufficientBalance is a free log retrieval operation binding the contract event 0xdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c4.
//
// Solidity: event InsufficientBalance(address searcher, uint256 balance, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterInsufficientBalance(opts *bind.FilterOpts) (*IAuctionDepositVaultInsufficientBalanceIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "InsufficientBalance")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultInsufficientBalanceIterator{contract: _IAuctionDepositVault.contract, event: "InsufficientBalance", logs: logs, sub: sub}, nil
}

// WatchInsufficientBalance is a free log subscription operation binding the contract event 0xdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c4.
//
// Solidity: event InsufficientBalance(address searcher, uint256 balance, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchInsufficientBalance(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultInsufficientBalance) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "InsufficientBalance")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultInsufficientBalance)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "InsufficientBalance", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInsufficientBalance is a log parse operation binding the contract event 0xdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c4.
//
// Solidity: event InsufficientBalance(address searcher, uint256 balance, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseInsufficientBalance(log types.Log) (*IAuctionDepositVaultInsufficientBalance, error) {
	event := new(IAuctionDepositVaultInsufficientBalance)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "InsufficientBalance", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultTakenBidIterator is returned from FilterTakenBid and is used to iterate over the raw logs and unpacked data for TakenBid events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenBidIterator struct {
	Event *IAuctionDepositVaultTakenBid // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultTakenBidIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultTakenBid)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultTakenBid)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultTakenBidIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultTakenBidIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultTakenBid represents a TakenBid event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenBid struct {
	Searcher common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTakenBid is a free log retrieval operation binding the contract event 0xbf3f09205213cdb412585918db004ac3947fcd2db1f85fdbb20faaa950e08d2e.
//
// Solidity: event TakenBid(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterTakenBid(opts *bind.FilterOpts) (*IAuctionDepositVaultTakenBidIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "TakenBid")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultTakenBidIterator{contract: _IAuctionDepositVault.contract, event: "TakenBid", logs: logs, sub: sub}, nil
}

// WatchTakenBid is a free log subscription operation binding the contract event 0xbf3f09205213cdb412585918db004ac3947fcd2db1f85fdbb20faaa950e08d2e.
//
// Solidity: event TakenBid(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchTakenBid(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultTakenBid) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "TakenBid")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultTakenBid)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenBid", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenBid is a log parse operation binding the contract event 0xbf3f09205213cdb412585918db004ac3947fcd2db1f85fdbb20faaa950e08d2e.
//
// Solidity: event TakenBid(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseTakenBid(log types.Log) (*IAuctionDepositVaultTakenBid, error) {
	event := new(IAuctionDepositVaultTakenBid)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenBid", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultTakenBidFailedIterator is returned from FilterTakenBidFailed and is used to iterate over the raw logs and unpacked data for TakenBidFailed events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenBidFailedIterator struct {
	Event *IAuctionDepositVaultTakenBidFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultTakenBidFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultTakenBidFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultTakenBidFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultTakenBidFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultTakenBidFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultTakenBidFailed represents a TakenBidFailed event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenBidFailed struct {
	Searcher common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTakenBidFailed is a free log retrieval operation binding the contract event 0xd26b9fcb04629bad3365ea66f0f4d563e8c71753e7ee1a0c601f1a02ceebed8b.
//
// Solidity: event TakenBidFailed(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterTakenBidFailed(opts *bind.FilterOpts) (*IAuctionDepositVaultTakenBidFailedIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "TakenBidFailed")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultTakenBidFailedIterator{contract: _IAuctionDepositVault.contract, event: "TakenBidFailed", logs: logs, sub: sub}, nil
}

// WatchTakenBidFailed is a free log subscription operation binding the contract event 0xd26b9fcb04629bad3365ea66f0f4d563e8c71753e7ee1a0c601f1a02ceebed8b.
//
// Solidity: event TakenBidFailed(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchTakenBidFailed(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultTakenBidFailed) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "TakenBidFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultTakenBidFailed)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenBidFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenBidFailed is a log parse operation binding the contract event 0xd26b9fcb04629bad3365ea66f0f4d563e8c71753e7ee1a0c601f1a02ceebed8b.
//
// Solidity: event TakenBidFailed(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseTakenBidFailed(log types.Log) (*IAuctionDepositVaultTakenBidFailed, error) {
	event := new(IAuctionDepositVaultTakenBidFailed)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenBidFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultTakenGasIterator is returned from FilterTakenGas and is used to iterate over the raw logs and unpacked data for TakenGas events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenGasIterator struct {
	Event *IAuctionDepositVaultTakenGas // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultTakenGasIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultTakenGas)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultTakenGas)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultTakenGasIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultTakenGasIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultTakenGas represents a TakenGas event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenGas struct {
	Searcher  common.Address
	GasAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterTakenGas is a free log retrieval operation binding the contract event 0x672970b97597bfb4460c604bb4adc66538c7b00a40bfb2cb9b6566f1692266fd.
//
// Solidity: event TakenGas(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterTakenGas(opts *bind.FilterOpts) (*IAuctionDepositVaultTakenGasIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "TakenGas")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultTakenGasIterator{contract: _IAuctionDepositVault.contract, event: "TakenGas", logs: logs, sub: sub}, nil
}

// WatchTakenGas is a free log subscription operation binding the contract event 0x672970b97597bfb4460c604bb4adc66538c7b00a40bfb2cb9b6566f1692266fd.
//
// Solidity: event TakenGas(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchTakenGas(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultTakenGas) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "TakenGas")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultTakenGas)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenGas", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenGas is a log parse operation binding the contract event 0x672970b97597bfb4460c604bb4adc66538c7b00a40bfb2cb9b6566f1692266fd.
//
// Solidity: event TakenGas(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseTakenGas(log types.Log) (*IAuctionDepositVaultTakenGas, error) {
	event := new(IAuctionDepositVaultTakenGas)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenGas", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultTakenGasFailedIterator is returned from FilterTakenGasFailed and is used to iterate over the raw logs and unpacked data for TakenGasFailed events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenGasFailedIterator struct {
	Event *IAuctionDepositVaultTakenGasFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultTakenGasFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultTakenGasFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultTakenGasFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultTakenGasFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultTakenGasFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultTakenGasFailed represents a TakenGasFailed event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenGasFailed struct {
	Searcher  common.Address
	GasAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterTakenGasFailed is a free log retrieval operation binding the contract event 0x53605ab3492a9ae1542e049df64874ee628a589811e81b2594f416e9d092b7ca.
//
// Solidity: event TakenGasFailed(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterTakenGasFailed(opts *bind.FilterOpts) (*IAuctionDepositVaultTakenGasFailedIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "TakenGasFailed")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultTakenGasFailedIterator{contract: _IAuctionDepositVault.contract, event: "TakenGasFailed", logs: logs, sub: sub}, nil
}

// WatchTakenGasFailed is a free log subscription operation binding the contract event 0x53605ab3492a9ae1542e049df64874ee628a589811e81b2594f416e9d092b7ca.
//
// Solidity: event TakenGasFailed(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchTakenGasFailed(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultTakenGasFailed) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "TakenGasFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultTakenGasFailed)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenGasFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenGasFailed is a log parse operation binding the contract event 0x53605ab3492a9ae1542e049df64874ee628a589811e81b2594f416e9d092b7ca.
//
// Solidity: event TakenGasFailed(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseTakenGasFailed(log types.Log) (*IAuctionDepositVaultTakenGasFailed, error) {
	event := new(IAuctionDepositVaultTakenGasFailed)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenGasFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultVaultDepositIterator is returned from FilterVaultDeposit and is used to iterate over the raw logs and unpacked data for VaultDeposit events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultDepositIterator struct {
	Event *IAuctionDepositVaultVaultDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultVaultDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultVaultDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultVaultDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultVaultDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultVaultDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultVaultDeposit represents a VaultDeposit event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultDeposit struct {
	Searcher    common.Address
	Amount      *big.Int
	TotalAmount *big.Int
	Nonce       *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterVaultDeposit is a free log retrieval operation binding the contract event 0xb356f70fb7268cd9ebf6cd2c25e8628582435a3754305d2edade9b81c0961181.
//
// Solidity: event VaultDeposit(address searcher, uint256 amount, uint256 totalAmount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterVaultDeposit(opts *bind.FilterOpts) (*IAuctionDepositVaultVaultDepositIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "VaultDeposit")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultVaultDepositIterator{contract: _IAuctionDepositVault.contract, event: "VaultDeposit", logs: logs, sub: sub}, nil
}

// WatchVaultDeposit is a free log subscription operation binding the contract event 0xb356f70fb7268cd9ebf6cd2c25e8628582435a3754305d2edade9b81c0961181.
//
// Solidity: event VaultDeposit(address searcher, uint256 amount, uint256 totalAmount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchVaultDeposit(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultVaultDeposit) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "VaultDeposit")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultVaultDeposit)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultDeposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVaultDeposit is a log parse operation binding the contract event 0xb356f70fb7268cd9ebf6cd2c25e8628582435a3754305d2edade9b81c0961181.
//
// Solidity: event VaultDeposit(address searcher, uint256 amount, uint256 totalAmount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseVaultDeposit(log types.Log) (*IAuctionDepositVaultVaultDeposit, error) {
	event := new(IAuctionDepositVaultVaultDeposit)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultDeposit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultVaultReserveWithdrawIterator is returned from FilterVaultReserveWithdraw and is used to iterate over the raw logs and unpacked data for VaultReserveWithdraw events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultReserveWithdrawIterator struct {
	Event *IAuctionDepositVaultVaultReserveWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultVaultReserveWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultVaultReserveWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultVaultReserveWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultVaultReserveWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultVaultReserveWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultVaultReserveWithdraw represents a VaultReserveWithdraw event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultReserveWithdraw struct {
	Searcher common.Address
	Amount   *big.Int
	Nonce    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterVaultReserveWithdraw is a free log retrieval operation binding the contract event 0x89312dfc642f95af3c0376f434dd92d2ce54d713297a8df3921828edbd2ef1a1.
//
// Solidity: event VaultReserveWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterVaultReserveWithdraw(opts *bind.FilterOpts) (*IAuctionDepositVaultVaultReserveWithdrawIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "VaultReserveWithdraw")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultVaultReserveWithdrawIterator{contract: _IAuctionDepositVault.contract, event: "VaultReserveWithdraw", logs: logs, sub: sub}, nil
}

// WatchVaultReserveWithdraw is a free log subscription operation binding the contract event 0x89312dfc642f95af3c0376f434dd92d2ce54d713297a8df3921828edbd2ef1a1.
//
// Solidity: event VaultReserveWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchVaultReserveWithdraw(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultVaultReserveWithdraw) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "VaultReserveWithdraw")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultVaultReserveWithdraw)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultReserveWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVaultReserveWithdraw is a log parse operation binding the contract event 0x89312dfc642f95af3c0376f434dd92d2ce54d713297a8df3921828edbd2ef1a1.
//
// Solidity: event VaultReserveWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseVaultReserveWithdraw(log types.Log) (*IAuctionDepositVaultVaultReserveWithdraw, error) {
	event := new(IAuctionDepositVaultVaultReserveWithdraw)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultReserveWithdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultVaultWithdrawIterator is returned from FilterVaultWithdraw and is used to iterate over the raw logs and unpacked data for VaultWithdraw events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultWithdrawIterator struct {
	Event *IAuctionDepositVaultVaultWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultVaultWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultVaultWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultVaultWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultVaultWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultVaultWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultVaultWithdraw represents a VaultWithdraw event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultWithdraw struct {
	Searcher common.Address
	Amount   *big.Int
	Nonce    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterVaultWithdraw is a free log retrieval operation binding the contract event 0x97c7b889c23f0ecb7c22eac5c58266eae022989cfdbd9b6dcf63417338c787de.
//
// Solidity: event VaultWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterVaultWithdraw(opts *bind.FilterOpts) (*IAuctionDepositVaultVaultWithdrawIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "VaultWithdraw")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultVaultWithdrawIterator{contract: _IAuctionDepositVault.contract, event: "VaultWithdraw", logs: logs, sub: sub}, nil
}

// WatchVaultWithdraw is a free log subscription operation binding the contract event 0x97c7b889c23f0ecb7c22eac5c58266eae022989cfdbd9b6dcf63417338c787de.
//
// Solidity: event VaultWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchVaultWithdraw(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultVaultWithdraw) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "VaultWithdraw")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultVaultWithdraw)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVaultWithdraw is a log parse operation binding the contract event 0x97c7b889c23f0ecb7c22eac5c58266eae022989cfdbd9b6dcf63417338c787de.
//
// Solidity: event VaultWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseVaultWithdraw(log types.Log) (*IAuctionDepositVaultVaultWithdraw, error) {
	event := new(IAuctionDepositVaultVaultWithdraw)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultWithdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionEntryPointMetaData contains all meta data concerning the IAuctionEntryPoint contract.
var IAuctionEntryPointMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Call\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"CallFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAuctioneer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAuctioneer\",\"type\":\"address\"}],\"name\":\"ChangeAuctioneer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDepositVault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDepositVault\",\"type\":\"address\"}],\"name\":\"ChangeDepositVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"UseNonce\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"auctioneer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"targetTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"searcherSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auctioneerSig\",\"type\":\"bytes\"}],\"internalType\":\"structIAuctionEntryPoint.AuctionTx\",\"name\":\"auctionTx\",\"type\":\"tuple\"}],\"name\":\"call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_auctioneer\",\"type\":\"address\"}],\"name\":\"changeAuctioneer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositVault\",\"type\":\"address\"}],\"name\":\"changeDepositVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositVault\",\"outputs\":[{\"internalType\":\"contractIAuctionDepositVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"targetTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"searcherSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auctioneerSig\",\"type\":\"bytes\"}],\"internalType\":\"structIAuctionEntryPoint.AuctionTx\",\"name\":\"auctionTx\",\"type\":\"tuple\"}],\"name\":\"getAuctionTxHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"searchers\",\"type\":\"address[]\"}],\"name\":\"getNonceAndBids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nonces_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bids_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"5ec2c7bf": "auctioneer()",
		"ca157554": "call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes))",
		"774f45ec": "changeAuctioneer(address)",
		"9d59928b": "changeDepositVault(address)",
		"d7cd3949": "depositVault()",
		"a8aa9450": "getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes))",
		"287ca78e": "getNonceAndBids(address[])",
	},
}

// IAuctionEntryPointABI is the input ABI used to generate the binding from.
// Deprecated: Use IAuctionEntryPointMetaData.ABI instead.
var IAuctionEntryPointABI = IAuctionEntryPointMetaData.ABI

// IAuctionEntryPointBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IAuctionEntryPointBinRuntime = ``

// Deprecated: Use IAuctionEntryPointMetaData.Sigs instead.
// IAuctionEntryPointFuncSigs maps the 4-byte function signature to its string representation.
var IAuctionEntryPointFuncSigs = IAuctionEntryPointMetaData.Sigs

// IAuctionEntryPoint is an auto generated Go binding around a Kaia contract.
type IAuctionEntryPoint struct {
	IAuctionEntryPointCaller     // Read-only binding to the contract
	IAuctionEntryPointTransactor // Write-only binding to the contract
	IAuctionEntryPointFilterer   // Log filterer for contract events
}

// IAuctionEntryPointCaller is an auto generated read-only Go binding around a Kaia contract.
type IAuctionEntryPointCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionEntryPointTransactor is an auto generated write-only Go binding around a Kaia contract.
type IAuctionEntryPointTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionEntryPointFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type IAuctionEntryPointFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionEntryPointSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type IAuctionEntryPointSession struct {
	Contract     *IAuctionEntryPoint // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// IAuctionEntryPointCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type IAuctionEntryPointCallerSession struct {
	Contract *IAuctionEntryPointCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// IAuctionEntryPointTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type IAuctionEntryPointTransactorSession struct {
	Contract     *IAuctionEntryPointTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// IAuctionEntryPointRaw is an auto generated low-level Go binding around a Kaia contract.
type IAuctionEntryPointRaw struct {
	Contract *IAuctionEntryPoint // Generic contract binding to access the raw methods on
}

// IAuctionEntryPointCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type IAuctionEntryPointCallerRaw struct {
	Contract *IAuctionEntryPointCaller // Generic read-only contract binding to access the raw methods on
}

// IAuctionEntryPointTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type IAuctionEntryPointTransactorRaw struct {
	Contract *IAuctionEntryPointTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAuctionEntryPoint creates a new instance of IAuctionEntryPoint, bound to a specific deployed contract.
func NewIAuctionEntryPoint(address common.Address, backend bind.ContractBackend) (*IAuctionEntryPoint, error) {
	contract, err := bindIAuctionEntryPoint(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPoint{IAuctionEntryPointCaller: IAuctionEntryPointCaller{contract: contract}, IAuctionEntryPointTransactor: IAuctionEntryPointTransactor{contract: contract}, IAuctionEntryPointFilterer: IAuctionEntryPointFilterer{contract: contract}}, nil
}

// NewIAuctionEntryPointCaller creates a new read-only instance of IAuctionEntryPoint, bound to a specific deployed contract.
func NewIAuctionEntryPointCaller(address common.Address, caller bind.ContractCaller) (*IAuctionEntryPointCaller, error) {
	contract, err := bindIAuctionEntryPoint(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointCaller{contract: contract}, nil
}

// NewIAuctionEntryPointTransactor creates a new write-only instance of IAuctionEntryPoint, bound to a specific deployed contract.
func NewIAuctionEntryPointTransactor(address common.Address, transactor bind.ContractTransactor) (*IAuctionEntryPointTransactor, error) {
	contract, err := bindIAuctionEntryPoint(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointTransactor{contract: contract}, nil
}

// NewIAuctionEntryPointFilterer creates a new log filterer instance of IAuctionEntryPoint, bound to a specific deployed contract.
func NewIAuctionEntryPointFilterer(address common.Address, filterer bind.ContractFilterer) (*IAuctionEntryPointFilterer, error) {
	contract, err := bindIAuctionEntryPoint(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointFilterer{contract: contract}, nil
}

// bindIAuctionEntryPoint binds a generic wrapper to an already deployed contract.
func bindIAuctionEntryPoint(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IAuctionEntryPointMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuctionEntryPoint *IAuctionEntryPointRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuctionEntryPoint.Contract.IAuctionEntryPointCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuctionEntryPoint *IAuctionEntryPointRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.IAuctionEntryPointTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuctionEntryPoint *IAuctionEntryPointRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.IAuctionEntryPointTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuctionEntryPoint *IAuctionEntryPointCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuctionEntryPoint.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuctionEntryPoint *IAuctionEntryPointTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuctionEntryPoint *IAuctionEntryPointTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.contract.Transact(opts, method, params...)
}

// Auctioneer is a free data retrieval call binding the contract method 0x5ec2c7bf.
//
// Solidity: function auctioneer() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointCaller) Auctioneer(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IAuctionEntryPoint.contract.Call(opts, &out, "auctioneer")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Auctioneer is a free data retrieval call binding the contract method 0x5ec2c7bf.
//
// Solidity: function auctioneer() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointSession) Auctioneer() (common.Address, error) {
	return _IAuctionEntryPoint.Contract.Auctioneer(&_IAuctionEntryPoint.CallOpts)
}

// Auctioneer is a free data retrieval call binding the contract method 0x5ec2c7bf.
//
// Solidity: function auctioneer() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointCallerSession) Auctioneer() (common.Address, error) {
	return _IAuctionEntryPoint.Contract.Auctioneer(&_IAuctionEntryPoint.CallOpts)
}

// DepositVault is a free data retrieval call binding the contract method 0xd7cd3949.
//
// Solidity: function depositVault() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointCaller) DepositVault(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IAuctionEntryPoint.contract.Call(opts, &out, "depositVault")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// DepositVault is a free data retrieval call binding the contract method 0xd7cd3949.
//
// Solidity: function depositVault() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointSession) DepositVault() (common.Address, error) {
	return _IAuctionEntryPoint.Contract.DepositVault(&_IAuctionEntryPoint.CallOpts)
}

// DepositVault is a free data retrieval call binding the contract method 0xd7cd3949.
//
// Solidity: function depositVault() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointCallerSession) DepositVault() (common.Address, error) {
	return _IAuctionEntryPoint.Contract.DepositVault(&_IAuctionEntryPoint.CallOpts)
}

// GetAuctionTxHash is a free data retrieval call binding the contract method 0xa8aa9450.
//
// Solidity: function getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) view returns(bytes32)
func (_IAuctionEntryPoint *IAuctionEntryPointCaller) GetAuctionTxHash(opts *bind.CallOpts, auctionTx IAuctionEntryPointAuctionTx) ([32]byte, error) {
	var out []interface{}
	err := _IAuctionEntryPoint.contract.Call(opts, &out, "getAuctionTxHash", auctionTx)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetAuctionTxHash is a free data retrieval call binding the contract method 0xa8aa9450.
//
// Solidity: function getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) view returns(bytes32)
func (_IAuctionEntryPoint *IAuctionEntryPointSession) GetAuctionTxHash(auctionTx IAuctionEntryPointAuctionTx) ([32]byte, error) {
	return _IAuctionEntryPoint.Contract.GetAuctionTxHash(&_IAuctionEntryPoint.CallOpts, auctionTx)
}

// GetAuctionTxHash is a free data retrieval call binding the contract method 0xa8aa9450.
//
// Solidity: function getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) view returns(bytes32)
func (_IAuctionEntryPoint *IAuctionEntryPointCallerSession) GetAuctionTxHash(auctionTx IAuctionEntryPointAuctionTx) ([32]byte, error) {
	return _IAuctionEntryPoint.Contract.GetAuctionTxHash(&_IAuctionEntryPoint.CallOpts, auctionTx)
}

// GetNonceAndBids is a free data retrieval call binding the contract method 0x287ca78e.
//
// Solidity: function getNonceAndBids(address[] searchers) view returns(uint256[] nonces_, uint256[] bids_)
func (_IAuctionEntryPoint *IAuctionEntryPointCaller) GetNonceAndBids(opts *bind.CallOpts, searchers []common.Address) (struct {
	Nonces []*big.Int
	Bids   []*big.Int
}, error) {
	var out []interface{}
	err := _IAuctionEntryPoint.contract.Call(opts, &out, "getNonceAndBids", searchers)

	outstruct := new(struct {
		Nonces []*big.Int
		Bids   []*big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Nonces = *abi.ConvertType(out[0], new([]*big.Int)).(*[]*big.Int)
	outstruct.Bids = *abi.ConvertType(out[1], new([]*big.Int)).(*[]*big.Int)

	return *outstruct, err

}

// GetNonceAndBids is a free data retrieval call binding the contract method 0x287ca78e.
//
// Solidity: function getNonceAndBids(address[] searchers) view returns(uint256[] nonces_, uint256[] bids_)
func (_IAuctionEntryPoint *IAuctionEntryPointSession) GetNonceAndBids(searchers []common.Address) (struct {
	Nonces []*big.Int
	Bids   []*big.Int
}, error) {
	return _IAuctionEntryPoint.Contract.GetNonceAndBids(&_IAuctionEntryPoint.CallOpts, searchers)
}

// GetNonceAndBids is a free data retrieval call binding the contract method 0x287ca78e.
//
// Solidity: function getNonceAndBids(address[] searchers) view returns(uint256[] nonces_, uint256[] bids_)
func (_IAuctionEntryPoint *IAuctionEntryPointCallerSession) GetNonceAndBids(searchers []common.Address) (struct {
	Nonces []*big.Int
	Bids   []*big.Int
}, error) {
	return _IAuctionEntryPoint.Contract.GetNonceAndBids(&_IAuctionEntryPoint.CallOpts, searchers)
}

// Call is a paid mutator transaction binding the contract method 0xca157554.
//
// Solidity: function call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactor) Call(opts *bind.TransactOpts, auctionTx IAuctionEntryPointAuctionTx) (*types.Transaction, error) {
	return _IAuctionEntryPoint.contract.Transact(opts, "call", auctionTx)
}

// Call is a paid mutator transaction binding the contract method 0xca157554.
//
// Solidity: function call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointSession) Call(auctionTx IAuctionEntryPointAuctionTx) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.Call(&_IAuctionEntryPoint.TransactOpts, auctionTx)
}

// Call is a paid mutator transaction binding the contract method 0xca157554.
//
// Solidity: function call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactorSession) Call(auctionTx IAuctionEntryPointAuctionTx) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.Call(&_IAuctionEntryPoint.TransactOpts, auctionTx)
}

// ChangeAuctioneer is a paid mutator transaction binding the contract method 0x774f45ec.
//
// Solidity: function changeAuctioneer(address _auctioneer) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactor) ChangeAuctioneer(opts *bind.TransactOpts, _auctioneer common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.contract.Transact(opts, "changeAuctioneer", _auctioneer)
}

// ChangeAuctioneer is a paid mutator transaction binding the contract method 0x774f45ec.
//
// Solidity: function changeAuctioneer(address _auctioneer) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointSession) ChangeAuctioneer(_auctioneer common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.ChangeAuctioneer(&_IAuctionEntryPoint.TransactOpts, _auctioneer)
}

// ChangeAuctioneer is a paid mutator transaction binding the contract method 0x774f45ec.
//
// Solidity: function changeAuctioneer(address _auctioneer) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactorSession) ChangeAuctioneer(_auctioneer common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.ChangeAuctioneer(&_IAuctionEntryPoint.TransactOpts, _auctioneer)
}

// ChangeDepositVault is a paid mutator transaction binding the contract method 0x9d59928b.
//
// Solidity: function changeDepositVault(address _depositVault) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactor) ChangeDepositVault(opts *bind.TransactOpts, _depositVault common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.contract.Transact(opts, "changeDepositVault", _depositVault)
}

// ChangeDepositVault is a paid mutator transaction binding the contract method 0x9d59928b.
//
// Solidity: function changeDepositVault(address _depositVault) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointSession) ChangeDepositVault(_depositVault common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.ChangeDepositVault(&_IAuctionEntryPoint.TransactOpts, _depositVault)
}

// ChangeDepositVault is a paid mutator transaction binding the contract method 0x9d59928b.
//
// Solidity: function changeDepositVault(address _depositVault) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactorSession) ChangeDepositVault(_depositVault common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.ChangeDepositVault(&_IAuctionEntryPoint.TransactOpts, _depositVault)
}

// IAuctionEntryPointCallIterator is returned from FilterCall and is used to iterate over the raw logs and unpacked data for Call events raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointCallIterator struct {
	Event *IAuctionEntryPointCall // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionEntryPointCallIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionEntryPointCall)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionEntryPointCall)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionEntryPointCallIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionEntryPointCallIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionEntryPointCall represents a Call event raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointCall struct {
	Sender common.Address
	Nonce  *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterCall is a free log retrieval operation binding the contract event 0x9e4369a013b5e45a103a959d8eb70f15c55dc496e8335f245690393dfb4b71d4.
//
// Solidity: event Call(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) FilterCall(opts *bind.FilterOpts) (*IAuctionEntryPointCallIterator, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.FilterLogs(opts, "Call")
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointCallIterator{contract: _IAuctionEntryPoint.contract, event: "Call", logs: logs, sub: sub}, nil
}

// WatchCall is a free log subscription operation binding the contract event 0x9e4369a013b5e45a103a959d8eb70f15c55dc496e8335f245690393dfb4b71d4.
//
// Solidity: event Call(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) WatchCall(opts *bind.WatchOpts, sink chan<- *IAuctionEntryPointCall) (event.Subscription, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.WatchLogs(opts, "Call")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionEntryPointCall)
				if err := _IAuctionEntryPoint.contract.UnpackLog(event, "Call", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCall is a log parse operation binding the contract event 0x9e4369a013b5e45a103a959d8eb70f15c55dc496e8335f245690393dfb4b71d4.
//
// Solidity: event Call(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) ParseCall(log types.Log) (*IAuctionEntryPointCall, error) {
	event := new(IAuctionEntryPointCall)
	if err := _IAuctionEntryPoint.contract.UnpackLog(event, "Call", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionEntryPointCallFailedIterator is returned from FilterCallFailed and is used to iterate over the raw logs and unpacked data for CallFailed events raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointCallFailedIterator struct {
	Event *IAuctionEntryPointCallFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionEntryPointCallFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionEntryPointCallFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionEntryPointCallFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionEntryPointCallFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionEntryPointCallFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionEntryPointCallFailed represents a CallFailed event raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointCallFailed struct {
	Sender common.Address
	Nonce  *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterCallFailed is a free log retrieval operation binding the contract event 0xb9eaeae386d339f8115782f297a9e5f0e13fb587cd6b0d502f113cb8dd4d6cb0.
//
// Solidity: event CallFailed(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) FilterCallFailed(opts *bind.FilterOpts) (*IAuctionEntryPointCallFailedIterator, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.FilterLogs(opts, "CallFailed")
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointCallFailedIterator{contract: _IAuctionEntryPoint.contract, event: "CallFailed", logs: logs, sub: sub}, nil
}

// WatchCallFailed is a free log subscription operation binding the contract event 0xb9eaeae386d339f8115782f297a9e5f0e13fb587cd6b0d502f113cb8dd4d6cb0.
//
// Solidity: event CallFailed(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) WatchCallFailed(opts *bind.WatchOpts, sink chan<- *IAuctionEntryPointCallFailed) (event.Subscription, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.WatchLogs(opts, "CallFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionEntryPointCallFailed)
				if err := _IAuctionEntryPoint.contract.UnpackLog(event, "CallFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCallFailed is a log parse operation binding the contract event 0xb9eaeae386d339f8115782f297a9e5f0e13fb587cd6b0d502f113cb8dd4d6cb0.
//
// Solidity: event CallFailed(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) ParseCallFailed(log types.Log) (*IAuctionEntryPointCallFailed, error) {
	event := new(IAuctionEntryPointCallFailed)
	if err := _IAuctionEntryPoint.contract.UnpackLog(event, "CallFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionEntryPointChangeAuctioneerIterator is returned from FilterChangeAuctioneer and is used to iterate over the raw logs and unpacked data for ChangeAuctioneer events raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointChangeAuctioneerIterator struct {
	Event *IAuctionEntryPointChangeAuctioneer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionEntryPointChangeAuctioneerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionEntryPointChangeAuctioneer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionEntryPointChangeAuctioneer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionEntryPointChangeAuctioneerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionEntryPointChangeAuctioneerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionEntryPointChangeAuctioneer represents a ChangeAuctioneer event raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointChangeAuctioneer struct {
	OldAuctioneer common.Address
	NewAuctioneer common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterChangeAuctioneer is a free log retrieval operation binding the contract event 0xc8a0473779a405800019e7658500d0930d92f78e776b553d286baeefb9c9a0f1.
//
// Solidity: event ChangeAuctioneer(address oldAuctioneer, address newAuctioneer)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) FilterChangeAuctioneer(opts *bind.FilterOpts) (*IAuctionEntryPointChangeAuctioneerIterator, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.FilterLogs(opts, "ChangeAuctioneer")
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointChangeAuctioneerIterator{contract: _IAuctionEntryPoint.contract, event: "ChangeAuctioneer", logs: logs, sub: sub}, nil
}

// WatchChangeAuctioneer is a free log subscription operation binding the contract event 0xc8a0473779a405800019e7658500d0930d92f78e776b553d286baeefb9c9a0f1.
//
// Solidity: event ChangeAuctioneer(address oldAuctioneer, address newAuctioneer)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) WatchChangeAuctioneer(opts *bind.WatchOpts, sink chan<- *IAuctionEntryPointChangeAuctioneer) (event.Subscription, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.WatchLogs(opts, "ChangeAuctioneer")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionEntryPointChangeAuctioneer)
				if err := _IAuctionEntryPoint.contract.UnpackLog(event, "ChangeAuctioneer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeAuctioneer is a log parse operation binding the contract event 0xc8a0473779a405800019e7658500d0930d92f78e776b553d286baeefb9c9a0f1.
//
// Solidity: event ChangeAuctioneer(address oldAuctioneer, address newAuctioneer)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) ParseChangeAuctioneer(log types.Log) (*IAuctionEntryPointChangeAuctioneer, error) {
	event := new(IAuctionEntryPointChangeAuctioneer)
	if err := _IAuctionEntryPoint.contract.UnpackLog(event, "ChangeAuctioneer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionEntryPointChangeDepositVaultIterator is returned from FilterChangeDepositVault and is used to iterate over the raw logs and unpacked data for ChangeDepositVault events raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointChangeDepositVaultIterator struct {
	Event *IAuctionEntryPointChangeDepositVault // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionEntryPointChangeDepositVaultIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionEntryPointChangeDepositVault)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionEntryPointChangeDepositVault)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionEntryPointChangeDepositVaultIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionEntryPointChangeDepositVaultIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionEntryPointChangeDepositVault represents a ChangeDepositVault event raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointChangeDepositVault struct {
	OldDepositVault common.Address
	NewDepositVault common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterChangeDepositVault is a free log retrieval operation binding the contract event 0x32718750012b831b1e21ea05c1ed833c9365fc94e7316126303f6d09f41beb5d.
//
// Solidity: event ChangeDepositVault(address oldDepositVault, address newDepositVault)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) FilterChangeDepositVault(opts *bind.FilterOpts) (*IAuctionEntryPointChangeDepositVaultIterator, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.FilterLogs(opts, "ChangeDepositVault")
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointChangeDepositVaultIterator{contract: _IAuctionEntryPoint.contract, event: "ChangeDepositVault", logs: logs, sub: sub}, nil
}

// WatchChangeDepositVault is a free log subscription operation binding the contract event 0x32718750012b831b1e21ea05c1ed833c9365fc94e7316126303f6d09f41beb5d.
//
// Solidity: event ChangeDepositVault(address oldDepositVault, address newDepositVault)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) WatchChangeDepositVault(opts *bind.WatchOpts, sink chan<- *IAuctionEntryPointChangeDepositVault) (event.Subscription, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.WatchLogs(opts, "ChangeDepositVault")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionEntryPointChangeDepositVault)
				if err := _IAuctionEntryPoint.contract.UnpackLog(event, "ChangeDepositVault", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeDepositVault is a log parse operation binding the contract event 0x32718750012b831b1e21ea05c1ed833c9365fc94e7316126303f6d09f41beb5d.
//
// Solidity: event ChangeDepositVault(address oldDepositVault, address newDepositVault)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) ParseChangeDepositVault(log types.Log) (*IAuctionEntryPointChangeDepositVault, error) {
	event := new(IAuctionEntryPointChangeDepositVault)
	if err := _IAuctionEntryPoint.contract.UnpackLog(event, "ChangeDepositVault", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionEntryPointUseNonceIterator is returned from FilterUseNonce and is used to iterate over the raw logs and unpacked data for UseNonce events raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointUseNonceIterator struct {
	Event *IAuctionEntryPointUseNonce // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionEntryPointUseNonceIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionEntryPointUseNonce)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionEntryPointUseNonce)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionEntryPointUseNonceIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionEntryPointUseNonceIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionEntryPointUseNonce represents a UseNonce event raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointUseNonce struct {
	Searcher common.Address
	Nonce    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterUseNonce is a free log retrieval operation binding the contract event 0x7243aab3c75cebfd96dc41ece7762eb023fc8c81e9ba2ce1d487876419b918b5.
//
// Solidity: event UseNonce(address searcher, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) FilterUseNonce(opts *bind.FilterOpts) (*IAuctionEntryPointUseNonceIterator, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.FilterLogs(opts, "UseNonce")
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointUseNonceIterator{contract: _IAuctionEntryPoint.contract, event: "UseNonce", logs: logs, sub: sub}, nil
}

// WatchUseNonce is a free log subscription operation binding the contract event 0x7243aab3c75cebfd96dc41ece7762eb023fc8c81e9ba2ce1d487876419b918b5.
//
// Solidity: event UseNonce(address searcher, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) WatchUseNonce(opts *bind.WatchOpts, sink chan<- *IAuctionEntryPointUseNonce) (event.Subscription, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.WatchLogs(opts, "UseNonce")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionEntryPointUseNonce)
				if err := _IAuctionEntryPoint.contract.UnpackLog(event, "UseNonce", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUseNonce is a log parse operation binding the contract event 0x7243aab3c75cebfd96dc41ece7762eb023fc8c81e9ba2ce1d487876419b918b5.
//
// Solidity: event UseNonce(address searcher, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) ParseUseNonce(log types.Log) (*IAuctionEntryPointUseNonce, error) {
	event := new(IAuctionEntryPointUseNonce)
	if err := _IAuctionEntryPoint.contract.UnpackLog(event, "UseNonce", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionFeeVaultMetaData contains all meta data concerning the IAuctionFeeVault contract.
var IAuctionFeeVaultMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paybackAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validatorPaybackAmount\",\"type\":\"uint256\"}],\"name\":\"FeeDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nodeId\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"RewardAddressRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"searcherPaybackRate\",\"type\":\"uint256\"}],\"name\":\"SearcherPaybackRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validatorPaybackRate\",\"type\":\"uint256\"}],\"name\":\"ValidatorPaybackRateUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nodeId\",\"type\":\"address\"}],\"name\":\"getRewardAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nodeId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardAddr\",\"type\":\"address\"}],\"name\":\"registerRewardAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_searcherPaybackRate\",\"type\":\"uint256\"}],\"name\":\"setSearcherPaybackRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_validatorPaybackRate\",\"type\":\"uint256\"}],\"name\":\"setValidatorPaybackRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"}],\"name\":\"takeBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"27a50f72": "getRewardAddr(address)",
		"363d5183": "registerRewardAddress(address,address)",
		"36cf2c63": "setSearcherPaybackRate(uint256)",
		"11062696": "setValidatorPaybackRate(uint256)",
		"8573e2ff": "takeBid(address)",
		"51cff8d9": "withdraw(address)",
	},
}

// IAuctionFeeVaultABI is the input ABI used to generate the binding from.
// Deprecated: Use IAuctionFeeVaultMetaData.ABI instead.
var IAuctionFeeVaultABI = IAuctionFeeVaultMetaData.ABI

// IAuctionFeeVaultBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IAuctionFeeVaultBinRuntime = ``

// Deprecated: Use IAuctionFeeVaultMetaData.Sigs instead.
// IAuctionFeeVaultFuncSigs maps the 4-byte function signature to its string representation.
var IAuctionFeeVaultFuncSigs = IAuctionFeeVaultMetaData.Sigs

// IAuctionFeeVault is an auto generated Go binding around a Kaia contract.
type IAuctionFeeVault struct {
	IAuctionFeeVaultCaller     // Read-only binding to the contract
	IAuctionFeeVaultTransactor // Write-only binding to the contract
	IAuctionFeeVaultFilterer   // Log filterer for contract events
}

// IAuctionFeeVaultCaller is an auto generated read-only Go binding around a Kaia contract.
type IAuctionFeeVaultCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionFeeVaultTransactor is an auto generated write-only Go binding around a Kaia contract.
type IAuctionFeeVaultTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionFeeVaultFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type IAuctionFeeVaultFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionFeeVaultSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type IAuctionFeeVaultSession struct {
	Contract     *IAuctionFeeVault // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IAuctionFeeVaultCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type IAuctionFeeVaultCallerSession struct {
	Contract *IAuctionFeeVaultCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// IAuctionFeeVaultTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type IAuctionFeeVaultTransactorSession struct {
	Contract     *IAuctionFeeVaultTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// IAuctionFeeVaultRaw is an auto generated low-level Go binding around a Kaia contract.
type IAuctionFeeVaultRaw struct {
	Contract *IAuctionFeeVault // Generic contract binding to access the raw methods on
}

// IAuctionFeeVaultCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type IAuctionFeeVaultCallerRaw struct {
	Contract *IAuctionFeeVaultCaller // Generic read-only contract binding to access the raw methods on
}

// IAuctionFeeVaultTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type IAuctionFeeVaultTransactorRaw struct {
	Contract *IAuctionFeeVaultTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAuctionFeeVault creates a new instance of IAuctionFeeVault, bound to a specific deployed contract.
func NewIAuctionFeeVault(address common.Address, backend bind.ContractBackend) (*IAuctionFeeVault, error) {
	contract, err := bindIAuctionFeeVault(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAuctionFeeVault{IAuctionFeeVaultCaller: IAuctionFeeVaultCaller{contract: contract}, IAuctionFeeVaultTransactor: IAuctionFeeVaultTransactor{contract: contract}, IAuctionFeeVaultFilterer: IAuctionFeeVaultFilterer{contract: contract}}, nil
}

// NewIAuctionFeeVaultCaller creates a new read-only instance of IAuctionFeeVault, bound to a specific deployed contract.
func NewIAuctionFeeVaultCaller(address common.Address, caller bind.ContractCaller) (*IAuctionFeeVaultCaller, error) {
	contract, err := bindIAuctionFeeVault(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAuctionFeeVaultCaller{contract: contract}, nil
}

// NewIAuctionFeeVaultTransactor creates a new write-only instance of IAuctionFeeVault, bound to a specific deployed contract.
func NewIAuctionFeeVaultTransactor(address common.Address, transactor bind.ContractTransactor) (*IAuctionFeeVaultTransactor, error) {
	contract, err := bindIAuctionFeeVault(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAuctionFeeVaultTransactor{contract: contract}, nil
}

// NewIAuctionFeeVaultFilterer creates a new log filterer instance of IAuctionFeeVault, bound to a specific deployed contract.
func NewIAuctionFeeVaultFilterer(address common.Address, filterer bind.ContractFilterer) (*IAuctionFeeVaultFilterer, error) {
	contract, err := bindIAuctionFeeVault(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAuctionFeeVaultFilterer{contract: contract}, nil
}

// bindIAuctionFeeVault binds a generic wrapper to an already deployed contract.
func bindIAuctionFeeVault(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IAuctionFeeVaultMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuctionFeeVault *IAuctionFeeVaultRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuctionFeeVault.Contract.IAuctionFeeVaultCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuctionFeeVault *IAuctionFeeVaultRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.IAuctionFeeVaultTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuctionFeeVault *IAuctionFeeVaultRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.IAuctionFeeVaultTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuctionFeeVault *IAuctionFeeVaultCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuctionFeeVault.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuctionFeeVault *IAuctionFeeVaultTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuctionFeeVault *IAuctionFeeVaultTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.contract.Transact(opts, method, params...)
}

// GetRewardAddr is a free data retrieval call binding the contract method 0x27a50f72.
//
// Solidity: function getRewardAddr(address nodeId) view returns(address)
func (_IAuctionFeeVault *IAuctionFeeVaultCaller) GetRewardAddr(opts *bind.CallOpts, nodeId common.Address) (common.Address, error) {
	var out []interface{}
	err := _IAuctionFeeVault.contract.Call(opts, &out, "getRewardAddr", nodeId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetRewardAddr is a free data retrieval call binding the contract method 0x27a50f72.
//
// Solidity: function getRewardAddr(address nodeId) view returns(address)
func (_IAuctionFeeVault *IAuctionFeeVaultSession) GetRewardAddr(nodeId common.Address) (common.Address, error) {
	return _IAuctionFeeVault.Contract.GetRewardAddr(&_IAuctionFeeVault.CallOpts, nodeId)
}

// GetRewardAddr is a free data retrieval call binding the contract method 0x27a50f72.
//
// Solidity: function getRewardAddr(address nodeId) view returns(address)
func (_IAuctionFeeVault *IAuctionFeeVaultCallerSession) GetRewardAddr(nodeId common.Address) (common.Address, error) {
	return _IAuctionFeeVault.Contract.GetRewardAddr(&_IAuctionFeeVault.CallOpts, nodeId)
}

// RegisterRewardAddress is a paid mutator transaction binding the contract method 0x363d5183.
//
// Solidity: function registerRewardAddress(address nodeId, address rewardAddr) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultTransactor) RegisterRewardAddress(opts *bind.TransactOpts, nodeId common.Address, rewardAddr common.Address) (*types.Transaction, error) {
	return _IAuctionFeeVault.contract.Transact(opts, "registerRewardAddress", nodeId, rewardAddr)
}

// RegisterRewardAddress is a paid mutator transaction binding the contract method 0x363d5183.
//
// Solidity: function registerRewardAddress(address nodeId, address rewardAddr) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultSession) RegisterRewardAddress(nodeId common.Address, rewardAddr common.Address) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.RegisterRewardAddress(&_IAuctionFeeVault.TransactOpts, nodeId, rewardAddr)
}

// RegisterRewardAddress is a paid mutator transaction binding the contract method 0x363d5183.
//
// Solidity: function registerRewardAddress(address nodeId, address rewardAddr) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultTransactorSession) RegisterRewardAddress(nodeId common.Address, rewardAddr common.Address) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.RegisterRewardAddress(&_IAuctionFeeVault.TransactOpts, nodeId, rewardAddr)
}

// SetSearcherPaybackRate is a paid mutator transaction binding the contract method 0x36cf2c63.
//
// Solidity: function setSearcherPaybackRate(uint256 _searcherPaybackRate) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultTransactor) SetSearcherPaybackRate(opts *bind.TransactOpts, _searcherPaybackRate *big.Int) (*types.Transaction, error) {
	return _IAuctionFeeVault.contract.Transact(opts, "setSearcherPaybackRate", _searcherPaybackRate)
}

// SetSearcherPaybackRate is a paid mutator transaction binding the contract method 0x36cf2c63.
//
// Solidity: function setSearcherPaybackRate(uint256 _searcherPaybackRate) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultSession) SetSearcherPaybackRate(_searcherPaybackRate *big.Int) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.SetSearcherPaybackRate(&_IAuctionFeeVault.TransactOpts, _searcherPaybackRate)
}

// SetSearcherPaybackRate is a paid mutator transaction binding the contract method 0x36cf2c63.
//
// Solidity: function setSearcherPaybackRate(uint256 _searcherPaybackRate) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultTransactorSession) SetSearcherPaybackRate(_searcherPaybackRate *big.Int) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.SetSearcherPaybackRate(&_IAuctionFeeVault.TransactOpts, _searcherPaybackRate)
}

// SetValidatorPaybackRate is a paid mutator transaction binding the contract method 0x11062696.
//
// Solidity: function setValidatorPaybackRate(uint256 _validatorPaybackRate) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultTransactor) SetValidatorPaybackRate(opts *bind.TransactOpts, _validatorPaybackRate *big.Int) (*types.Transaction, error) {
	return _IAuctionFeeVault.contract.Transact(opts, "setValidatorPaybackRate", _validatorPaybackRate)
}

// SetValidatorPaybackRate is a paid mutator transaction binding the contract method 0x11062696.
//
// Solidity: function setValidatorPaybackRate(uint256 _validatorPaybackRate) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultSession) SetValidatorPaybackRate(_validatorPaybackRate *big.Int) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.SetValidatorPaybackRate(&_IAuctionFeeVault.TransactOpts, _validatorPaybackRate)
}

// SetValidatorPaybackRate is a paid mutator transaction binding the contract method 0x11062696.
//
// Solidity: function setValidatorPaybackRate(uint256 _validatorPaybackRate) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultTransactorSession) SetValidatorPaybackRate(_validatorPaybackRate *big.Int) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.SetValidatorPaybackRate(&_IAuctionFeeVault.TransactOpts, _validatorPaybackRate)
}

// TakeBid is a paid mutator transaction binding the contract method 0x8573e2ff.
//
// Solidity: function takeBid(address searcher) payable returns()
func (_IAuctionFeeVault *IAuctionFeeVaultTransactor) TakeBid(opts *bind.TransactOpts, searcher common.Address) (*types.Transaction, error) {
	return _IAuctionFeeVault.contract.Transact(opts, "takeBid", searcher)
}

// TakeBid is a paid mutator transaction binding the contract method 0x8573e2ff.
//
// Solidity: function takeBid(address searcher) payable returns()
func (_IAuctionFeeVault *IAuctionFeeVaultSession) TakeBid(searcher common.Address) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.TakeBid(&_IAuctionFeeVault.TransactOpts, searcher)
}

// TakeBid is a paid mutator transaction binding the contract method 0x8573e2ff.
//
// Solidity: function takeBid(address searcher) payable returns()
func (_IAuctionFeeVault *IAuctionFeeVaultTransactorSession) TakeBid(searcher common.Address) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.TakeBid(&_IAuctionFeeVault.TransactOpts, searcher)
}

// Withdraw is a paid mutator transaction binding the contract method 0x51cff8d9.
//
// Solidity: function withdraw(address to) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultTransactor) Withdraw(opts *bind.TransactOpts, to common.Address) (*types.Transaction, error) {
	return _IAuctionFeeVault.contract.Transact(opts, "withdraw", to)
}

// Withdraw is a paid mutator transaction binding the contract method 0x51cff8d9.
//
// Solidity: function withdraw(address to) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultSession) Withdraw(to common.Address) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.Withdraw(&_IAuctionFeeVault.TransactOpts, to)
}

// Withdraw is a paid mutator transaction binding the contract method 0x51cff8d9.
//
// Solidity: function withdraw(address to) returns()
func (_IAuctionFeeVault *IAuctionFeeVaultTransactorSession) Withdraw(to common.Address) (*types.Transaction, error) {
	return _IAuctionFeeVault.Contract.Withdraw(&_IAuctionFeeVault.TransactOpts, to)
}

// IAuctionFeeVaultFeeDepositIterator is returned from FilterFeeDeposit and is used to iterate over the raw logs and unpacked data for FeeDeposit events raised by the IAuctionFeeVault contract.
type IAuctionFeeVaultFeeDepositIterator struct {
	Event *IAuctionFeeVaultFeeDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionFeeVaultFeeDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionFeeVaultFeeDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionFeeVaultFeeDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionFeeVaultFeeDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionFeeVaultFeeDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionFeeVaultFeeDeposit represents a FeeDeposit event raised by the IAuctionFeeVault contract.
type IAuctionFeeVaultFeeDeposit struct {
	Sender                 common.Address
	Amount                 *big.Int
	PaybackAmount          *big.Int
	ValidatorPaybackAmount *big.Int
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterFeeDeposit is a free log retrieval operation binding the contract event 0xa34c9ef6ada915fef21639b2d5c085580cf79046cca66c2c2e8b87e2f3bd8567.
//
// Solidity: event FeeDeposit(address indexed sender, uint256 amount, uint256 paybackAmount, uint256 validatorPaybackAmount)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) FilterFeeDeposit(opts *bind.FilterOpts, sender []common.Address) (*IAuctionFeeVaultFeeDepositIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAuctionFeeVault.contract.FilterLogs(opts, "FeeDeposit", senderRule)
	if err != nil {
		return nil, err
	}
	return &IAuctionFeeVaultFeeDepositIterator{contract: _IAuctionFeeVault.contract, event: "FeeDeposit", logs: logs, sub: sub}, nil
}

// WatchFeeDeposit is a free log subscription operation binding the contract event 0xa34c9ef6ada915fef21639b2d5c085580cf79046cca66c2c2e8b87e2f3bd8567.
//
// Solidity: event FeeDeposit(address indexed sender, uint256 amount, uint256 paybackAmount, uint256 validatorPaybackAmount)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) WatchFeeDeposit(opts *bind.WatchOpts, sink chan<- *IAuctionFeeVaultFeeDeposit, sender []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAuctionFeeVault.contract.WatchLogs(opts, "FeeDeposit", senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionFeeVaultFeeDeposit)
				if err := _IAuctionFeeVault.contract.UnpackLog(event, "FeeDeposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeDeposit is a log parse operation binding the contract event 0xa34c9ef6ada915fef21639b2d5c085580cf79046cca66c2c2e8b87e2f3bd8567.
//
// Solidity: event FeeDeposit(address indexed sender, uint256 amount, uint256 paybackAmount, uint256 validatorPaybackAmount)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) ParseFeeDeposit(log types.Log) (*IAuctionFeeVaultFeeDeposit, error) {
	event := new(IAuctionFeeVaultFeeDeposit)
	if err := _IAuctionFeeVault.contract.UnpackLog(event, "FeeDeposit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionFeeVaultFeeWithdrawalIterator is returned from FilterFeeWithdrawal and is used to iterate over the raw logs and unpacked data for FeeWithdrawal events raised by the IAuctionFeeVault contract.
type IAuctionFeeVaultFeeWithdrawalIterator struct {
	Event *IAuctionFeeVaultFeeWithdrawal // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionFeeVaultFeeWithdrawalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionFeeVaultFeeWithdrawal)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionFeeVaultFeeWithdrawal)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionFeeVaultFeeWithdrawalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionFeeVaultFeeWithdrawalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionFeeVaultFeeWithdrawal represents a FeeWithdrawal event raised by the IAuctionFeeVault contract.
type IAuctionFeeVaultFeeWithdrawal struct {
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterFeeWithdrawal is a free log retrieval operation binding the contract event 0x706d7f48c702007c2fb0881cea5759732e64f52faee427d5ab030787cfb7d787.
//
// Solidity: event FeeWithdrawal(uint256 amount)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) FilterFeeWithdrawal(opts *bind.FilterOpts) (*IAuctionFeeVaultFeeWithdrawalIterator, error) {

	logs, sub, err := _IAuctionFeeVault.contract.FilterLogs(opts, "FeeWithdrawal")
	if err != nil {
		return nil, err
	}
	return &IAuctionFeeVaultFeeWithdrawalIterator{contract: _IAuctionFeeVault.contract, event: "FeeWithdrawal", logs: logs, sub: sub}, nil
}

// WatchFeeWithdrawal is a free log subscription operation binding the contract event 0x706d7f48c702007c2fb0881cea5759732e64f52faee427d5ab030787cfb7d787.
//
// Solidity: event FeeWithdrawal(uint256 amount)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) WatchFeeWithdrawal(opts *bind.WatchOpts, sink chan<- *IAuctionFeeVaultFeeWithdrawal) (event.Subscription, error) {

	logs, sub, err := _IAuctionFeeVault.contract.WatchLogs(opts, "FeeWithdrawal")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionFeeVaultFeeWithdrawal)
				if err := _IAuctionFeeVault.contract.UnpackLog(event, "FeeWithdrawal", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeWithdrawal is a log parse operation binding the contract event 0x706d7f48c702007c2fb0881cea5759732e64f52faee427d5ab030787cfb7d787.
//
// Solidity: event FeeWithdrawal(uint256 amount)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) ParseFeeWithdrawal(log types.Log) (*IAuctionFeeVaultFeeWithdrawal, error) {
	event := new(IAuctionFeeVaultFeeWithdrawal)
	if err := _IAuctionFeeVault.contract.UnpackLog(event, "FeeWithdrawal", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionFeeVaultRewardAddressRegisteredIterator is returned from FilterRewardAddressRegistered and is used to iterate over the raw logs and unpacked data for RewardAddressRegistered events raised by the IAuctionFeeVault contract.
type IAuctionFeeVaultRewardAddressRegisteredIterator struct {
	Event *IAuctionFeeVaultRewardAddressRegistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionFeeVaultRewardAddressRegisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionFeeVaultRewardAddressRegistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionFeeVaultRewardAddressRegistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionFeeVaultRewardAddressRegisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionFeeVaultRewardAddressRegisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionFeeVaultRewardAddressRegistered represents a RewardAddressRegistered event raised by the IAuctionFeeVault contract.
type IAuctionFeeVaultRewardAddressRegistered struct {
	NodeId common.Address
	Reward common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRewardAddressRegistered is a free log retrieval operation binding the contract event 0xe608476cb01b1d04f944f0fdb25841b1f483d26965d42c4a1fab67b8b1488b3b.
//
// Solidity: event RewardAddressRegistered(address indexed nodeId, address indexed reward)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) FilterRewardAddressRegistered(opts *bind.FilterOpts, nodeId []common.Address, reward []common.Address) (*IAuctionFeeVaultRewardAddressRegisteredIterator, error) {

	var nodeIdRule []interface{}
	for _, nodeIdItem := range nodeId {
		nodeIdRule = append(nodeIdRule, nodeIdItem)
	}
	var rewardRule []interface{}
	for _, rewardItem := range reward {
		rewardRule = append(rewardRule, rewardItem)
	}

	logs, sub, err := _IAuctionFeeVault.contract.FilterLogs(opts, "RewardAddressRegistered", nodeIdRule, rewardRule)
	if err != nil {
		return nil, err
	}
	return &IAuctionFeeVaultRewardAddressRegisteredIterator{contract: _IAuctionFeeVault.contract, event: "RewardAddressRegistered", logs: logs, sub: sub}, nil
}

// WatchRewardAddressRegistered is a free log subscription operation binding the contract event 0xe608476cb01b1d04f944f0fdb25841b1f483d26965d42c4a1fab67b8b1488b3b.
//
// Solidity: event RewardAddressRegistered(address indexed nodeId, address indexed reward)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) WatchRewardAddressRegistered(opts *bind.WatchOpts, sink chan<- *IAuctionFeeVaultRewardAddressRegistered, nodeId []common.Address, reward []common.Address) (event.Subscription, error) {

	var nodeIdRule []interface{}
	for _, nodeIdItem := range nodeId {
		nodeIdRule = append(nodeIdRule, nodeIdItem)
	}
	var rewardRule []interface{}
	for _, rewardItem := range reward {
		rewardRule = append(rewardRule, rewardItem)
	}

	logs, sub, err := _IAuctionFeeVault.contract.WatchLogs(opts, "RewardAddressRegistered", nodeIdRule, rewardRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionFeeVaultRewardAddressRegistered)
				if err := _IAuctionFeeVault.contract.UnpackLog(event, "RewardAddressRegistered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRewardAddressRegistered is a log parse operation binding the contract event 0xe608476cb01b1d04f944f0fdb25841b1f483d26965d42c4a1fab67b8b1488b3b.
//
// Solidity: event RewardAddressRegistered(address indexed nodeId, address indexed reward)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) ParseRewardAddressRegistered(log types.Log) (*IAuctionFeeVaultRewardAddressRegistered, error) {
	event := new(IAuctionFeeVaultRewardAddressRegistered)
	if err := _IAuctionFeeVault.contract.UnpackLog(event, "RewardAddressRegistered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionFeeVaultSearcherPaybackRateUpdatedIterator is returned from FilterSearcherPaybackRateUpdated and is used to iterate over the raw logs and unpacked data for SearcherPaybackRateUpdated events raised by the IAuctionFeeVault contract.
type IAuctionFeeVaultSearcherPaybackRateUpdatedIterator struct {
	Event *IAuctionFeeVaultSearcherPaybackRateUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionFeeVaultSearcherPaybackRateUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionFeeVaultSearcherPaybackRateUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionFeeVaultSearcherPaybackRateUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionFeeVaultSearcherPaybackRateUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionFeeVaultSearcherPaybackRateUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionFeeVaultSearcherPaybackRateUpdated represents a SearcherPaybackRateUpdated event raised by the IAuctionFeeVault contract.
type IAuctionFeeVaultSearcherPaybackRateUpdated struct {
	SearcherPaybackRate *big.Int
	Raw                 types.Log // Blockchain specific contextual infos
}

// FilterSearcherPaybackRateUpdated is a free log retrieval operation binding the contract event 0x71745430318b073bd776904f2432cb283ce3d2ded537bafe2640cf4d6e4bc64f.
//
// Solidity: event SearcherPaybackRateUpdated(uint256 searcherPaybackRate)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) FilterSearcherPaybackRateUpdated(opts *bind.FilterOpts) (*IAuctionFeeVaultSearcherPaybackRateUpdatedIterator, error) {

	logs, sub, err := _IAuctionFeeVault.contract.FilterLogs(opts, "SearcherPaybackRateUpdated")
	if err != nil {
		return nil, err
	}
	return &IAuctionFeeVaultSearcherPaybackRateUpdatedIterator{contract: _IAuctionFeeVault.contract, event: "SearcherPaybackRateUpdated", logs: logs, sub: sub}, nil
}

// WatchSearcherPaybackRateUpdated is a free log subscription operation binding the contract event 0x71745430318b073bd776904f2432cb283ce3d2ded537bafe2640cf4d6e4bc64f.
//
// Solidity: event SearcherPaybackRateUpdated(uint256 searcherPaybackRate)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) WatchSearcherPaybackRateUpdated(opts *bind.WatchOpts, sink chan<- *IAuctionFeeVaultSearcherPaybackRateUpdated) (event.Subscription, error) {

	logs, sub, err := _IAuctionFeeVault.contract.WatchLogs(opts, "SearcherPaybackRateUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionFeeVaultSearcherPaybackRateUpdated)
				if err := _IAuctionFeeVault.contract.UnpackLog(event, "SearcherPaybackRateUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSearcherPaybackRateUpdated is a log parse operation binding the contract event 0x71745430318b073bd776904f2432cb283ce3d2ded537bafe2640cf4d6e4bc64f.
//
// Solidity: event SearcherPaybackRateUpdated(uint256 searcherPaybackRate)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) ParseSearcherPaybackRateUpdated(log types.Log) (*IAuctionFeeVaultSearcherPaybackRateUpdated, error) {
	event := new(IAuctionFeeVaultSearcherPaybackRateUpdated)
	if err := _IAuctionFeeVault.contract.UnpackLog(event, "SearcherPaybackRateUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionFeeVaultValidatorPaybackRateUpdatedIterator is returned from FilterValidatorPaybackRateUpdated and is used to iterate over the raw logs and unpacked data for ValidatorPaybackRateUpdated events raised by the IAuctionFeeVault contract.
type IAuctionFeeVaultValidatorPaybackRateUpdatedIterator struct {
	Event *IAuctionFeeVaultValidatorPaybackRateUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionFeeVaultValidatorPaybackRateUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionFeeVaultValidatorPaybackRateUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionFeeVaultValidatorPaybackRateUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionFeeVaultValidatorPaybackRateUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionFeeVaultValidatorPaybackRateUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionFeeVaultValidatorPaybackRateUpdated represents a ValidatorPaybackRateUpdated event raised by the IAuctionFeeVault contract.
type IAuctionFeeVaultValidatorPaybackRateUpdated struct {
	ValidatorPaybackRate *big.Int
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterValidatorPaybackRateUpdated is a free log retrieval operation binding the contract event 0x5309d48fe743a67ce32d8f66af9e2388d65bfc8cc026a4e1fbed3a4612a0af98.
//
// Solidity: event ValidatorPaybackRateUpdated(uint256 validatorPaybackRate)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) FilterValidatorPaybackRateUpdated(opts *bind.FilterOpts) (*IAuctionFeeVaultValidatorPaybackRateUpdatedIterator, error) {

	logs, sub, err := _IAuctionFeeVault.contract.FilterLogs(opts, "ValidatorPaybackRateUpdated")
	if err != nil {
		return nil, err
	}
	return &IAuctionFeeVaultValidatorPaybackRateUpdatedIterator{contract: _IAuctionFeeVault.contract, event: "ValidatorPaybackRateUpdated", logs: logs, sub: sub}, nil
}

// WatchValidatorPaybackRateUpdated is a free log subscription operation binding the contract event 0x5309d48fe743a67ce32d8f66af9e2388d65bfc8cc026a4e1fbed3a4612a0af98.
//
// Solidity: event ValidatorPaybackRateUpdated(uint256 validatorPaybackRate)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) WatchValidatorPaybackRateUpdated(opts *bind.WatchOpts, sink chan<- *IAuctionFeeVaultValidatorPaybackRateUpdated) (event.Subscription, error) {

	logs, sub, err := _IAuctionFeeVault.contract.WatchLogs(opts, "ValidatorPaybackRateUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionFeeVaultValidatorPaybackRateUpdated)
				if err := _IAuctionFeeVault.contract.UnpackLog(event, "ValidatorPaybackRateUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorPaybackRateUpdated is a log parse operation binding the contract event 0x5309d48fe743a67ce32d8f66af9e2388d65bfc8cc026a4e1fbed3a4612a0af98.
//
// Solidity: event ValidatorPaybackRateUpdated(uint256 validatorPaybackRate)
func (_IAuctionFeeVault *IAuctionFeeVaultFilterer) ParseValidatorPaybackRateUpdated(log types.Log) (*IAuctionFeeVaultValidatorPaybackRateUpdated, error) {
	event := new(IAuctionFeeVaultValidatorPaybackRateUpdated)
	if err := _IAuctionFeeVault.contract.UnpackLog(event, "ValidatorPaybackRateUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// INonceMetaData contains all meta data concerning the INonce contract.
var INonceMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"7ecebe00": "nonces(address)",
	},
}

// INonceABI is the input ABI used to generate the binding from.
// Deprecated: Use INonceMetaData.ABI instead.
var INonceABI = INonceMetaData.ABI

// INonceBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const INonceBinRuntime = ``

// Deprecated: Use INonceMetaData.Sigs instead.
// INonceFuncSigs maps the 4-byte function signature to its string representation.
var INonceFuncSigs = INonceMetaData.Sigs

// INonce is an auto generated Go binding around a Kaia contract.
type INonce struct {
	INonceCaller     // Read-only binding to the contract
	INonceTransactor // Write-only binding to the contract
	INonceFilterer   // Log filterer for contract events
}

// INonceCaller is an auto generated read-only Go binding around a Kaia contract.
type INonceCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// INonceTransactor is an auto generated write-only Go binding around a Kaia contract.
type INonceTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// INonceFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type INonceFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// INonceSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type INonceSession struct {
	Contract     *INonce           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// INonceCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type INonceCallerSession struct {
	Contract *INonceCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// INonceTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type INonceTransactorSession struct {
	Contract     *INonceTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// INonceRaw is an auto generated low-level Go binding around a Kaia contract.
type INonceRaw struct {
	Contract *INonce // Generic contract binding to access the raw methods on
}

// INonceCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type INonceCallerRaw struct {
	Contract *INonceCaller // Generic read-only contract binding to access the raw methods on
}

// INonceTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type INonceTransactorRaw struct {
	Contract *INonceTransactor // Generic write-only contract binding to access the raw methods on
}

// NewINonce creates a new instance of INonce, bound to a specific deployed contract.
func NewINonce(address common.Address, backend bind.ContractBackend) (*INonce, error) {
	contract, err := bindINonce(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &INonce{INonceCaller: INonceCaller{contract: contract}, INonceTransactor: INonceTransactor{contract: contract}, INonceFilterer: INonceFilterer{contract: contract}}, nil
}

// NewINonceCaller creates a new read-only instance of INonce, bound to a specific deployed contract.
func NewINonceCaller(address common.Address, caller bind.ContractCaller) (*INonceCaller, error) {
	contract, err := bindINonce(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &INonceCaller{contract: contract}, nil
}

// NewINonceTransactor creates a new write-only instance of INonce, bound to a specific deployed contract.
func NewINonceTransactor(address common.Address, transactor bind.ContractTransactor) (*INonceTransactor, error) {
	contract, err := bindINonce(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &INonceTransactor{contract: contract}, nil
}

// NewINonceFilterer creates a new log filterer instance of INonce, bound to a specific deployed contract.
func NewINonceFilterer(address common.Address, filterer bind.ContractFilterer) (*INonceFilterer, error) {
	contract, err := bindINonce(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &INonceFilterer{contract: contract}, nil
}

// bindINonce binds a generic wrapper to an already deployed contract.
func bindINonce(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := INonceMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_INonce *INonceRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _INonce.Contract.INonceCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_INonce *INonceRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _INonce.Contract.INonceTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_INonce *INonceRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _INonce.Contract.INonceTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_INonce *INonceCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _INonce.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_INonce *INonceTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _INonce.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_INonce *INonceTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _INonce.Contract.contract.Transact(opts, method, params...)
}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address searcher) view returns(uint256)
func (_INonce *INonceCaller) Nonces(opts *bind.CallOpts, searcher common.Address) (*big.Int, error) {
	var out []interface{}
	err := _INonce.contract.Call(opts, &out, "nonces", searcher)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address searcher) view returns(uint256)
func (_INonce *INonceSession) Nonces(searcher common.Address) (*big.Int, error) {
	return _INonce.Contract.Nonces(&_INonce.CallOpts, searcher)
}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address searcher) view returns(uint256)
func (_INonce *INonceCallerSession) Nonces(searcher common.Address) (*big.Int, error) {
	return _INonce.Contract.Nonces(&_INonce.CallOpts, searcher)
}

// IRegistryMetaData contains all meta data concerning the IRegistry contract.
var IRegistryMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"activation\",\"type\":\"uint256\"}],\"name\":\"Registered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"getActiveAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllNames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"getAllRecords\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"activation\",\"type\":\"uint256\"}],\"internalType\":\"structIRegistry.Record[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"names\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"activation\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"activation\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"e2693e3f": "getActiveAddr(string)",
		"fb825e5f": "getAllNames()",
		"78d573a2": "getAllRecords(string)",
		"4622ab03": "names(uint256)",
		"8da5cb5b": "owner()",
		"3b51650d": "records(string,uint256)",
		"d393c871": "register(string,address,uint256)",
		"f2fde38b": "transferOwnership(address)",
	},
}

// IRegistryABI is the input ABI used to generate the binding from.
// Deprecated: Use IRegistryMetaData.ABI instead.
var IRegistryABI = IRegistryMetaData.ABI

// IRegistryBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IRegistryBinRuntime = ``

// Deprecated: Use IRegistryMetaData.Sigs instead.
// IRegistryFuncSigs maps the 4-byte function signature to its string representation.
var IRegistryFuncSigs = IRegistryMetaData.Sigs

// IRegistry is an auto generated Go binding around a Kaia contract.
type IRegistry struct {
	IRegistryCaller     // Read-only binding to the contract
	IRegistryTransactor // Write-only binding to the contract
	IRegistryFilterer   // Log filterer for contract events
}

// IRegistryCaller is an auto generated read-only Go binding around a Kaia contract.
type IRegistryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IRegistryTransactor is an auto generated write-only Go binding around a Kaia contract.
type IRegistryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IRegistryFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type IRegistryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IRegistrySession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type IRegistrySession struct {
	Contract     *IRegistry        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IRegistryCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type IRegistryCallerSession struct {
	Contract *IRegistryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// IRegistryTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type IRegistryTransactorSession struct {
	Contract     *IRegistryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// IRegistryRaw is an auto generated low-level Go binding around a Kaia contract.
type IRegistryRaw struct {
	Contract *IRegistry // Generic contract binding to access the raw methods on
}

// IRegistryCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type IRegistryCallerRaw struct {
	Contract *IRegistryCaller // Generic read-only contract binding to access the raw methods on
}

// IRegistryTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type IRegistryTransactorRaw struct {
	Contract *IRegistryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIRegistry creates a new instance of IRegistry, bound to a specific deployed contract.
func NewIRegistry(address common.Address, backend bind.ContractBackend) (*IRegistry, error) {
	contract, err := bindIRegistry(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IRegistry{IRegistryCaller: IRegistryCaller{contract: contract}, IRegistryTransactor: IRegistryTransactor{contract: contract}, IRegistryFilterer: IRegistryFilterer{contract: contract}}, nil
}

// NewIRegistryCaller creates a new read-only instance of IRegistry, bound to a specific deployed contract.
func NewIRegistryCaller(address common.Address, caller bind.ContractCaller) (*IRegistryCaller, error) {
	contract, err := bindIRegistry(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IRegistryCaller{contract: contract}, nil
}

// NewIRegistryTransactor creates a new write-only instance of IRegistry, bound to a specific deployed contract.
func NewIRegistryTransactor(address common.Address, transactor bind.ContractTransactor) (*IRegistryTransactor, error) {
	contract, err := bindIRegistry(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IRegistryTransactor{contract: contract}, nil
}

// NewIRegistryFilterer creates a new log filterer instance of IRegistry, bound to a specific deployed contract.
func NewIRegistryFilterer(address common.Address, filterer bind.ContractFilterer) (*IRegistryFilterer, error) {
	contract, err := bindIRegistry(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IRegistryFilterer{contract: contract}, nil
}

// bindIRegistry binds a generic wrapper to an already deployed contract.
func bindIRegistry(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IRegistryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IRegistry *IRegistryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IRegistry.Contract.IRegistryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IRegistry *IRegistryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IRegistry.Contract.IRegistryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IRegistry *IRegistryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IRegistry.Contract.IRegistryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IRegistry *IRegistryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IRegistry.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IRegistry *IRegistryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IRegistry.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IRegistry *IRegistryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IRegistry.Contract.contract.Transact(opts, method, params...)
}

// GetActiveAddr is a free data retrieval call binding the contract method 0xe2693e3f.
//
// Solidity: function getActiveAddr(string name) view returns(address)
func (_IRegistry *IRegistryCaller) GetActiveAddr(opts *bind.CallOpts, name string) (common.Address, error) {
	var out []interface{}
	err := _IRegistry.contract.Call(opts, &out, "getActiveAddr", name)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetActiveAddr is a free data retrieval call binding the contract method 0xe2693e3f.
//
// Solidity: function getActiveAddr(string name) view returns(address)
func (_IRegistry *IRegistrySession) GetActiveAddr(name string) (common.Address, error) {
	return _IRegistry.Contract.GetActiveAddr(&_IRegistry.CallOpts, name)
}

// GetActiveAddr is a free data retrieval call binding the contract method 0xe2693e3f.
//
// Solidity: function getActiveAddr(string name) view returns(address)
func (_IRegistry *IRegistryCallerSession) GetActiveAddr(name string) (common.Address, error) {
	return _IRegistry.Contract.GetActiveAddr(&_IRegistry.CallOpts, name)
}

// GetAllNames is a free data retrieval call binding the contract method 0xfb825e5f.
//
// Solidity: function getAllNames() view returns(string[])
func (_IRegistry *IRegistryCaller) GetAllNames(opts *bind.CallOpts) ([]string, error) {
	var out []interface{}
	err := _IRegistry.contract.Call(opts, &out, "getAllNames")

	if err != nil {
		return *new([]string), err
	}

	out0 := *abi.ConvertType(out[0], new([]string)).(*[]string)

	return out0, err

}

// GetAllNames is a free data retrieval call binding the contract method 0xfb825e5f.
//
// Solidity: function getAllNames() view returns(string[])
func (_IRegistry *IRegistrySession) GetAllNames() ([]string, error) {
	return _IRegistry.Contract.GetAllNames(&_IRegistry.CallOpts)
}

// GetAllNames is a free data retrieval call binding the contract method 0xfb825e5f.
//
// Solidity: function getAllNames() view returns(string[])
func (_IRegistry *IRegistryCallerSession) GetAllNames() ([]string, error) {
	return _IRegistry.Contract.GetAllNames(&_IRegistry.CallOpts)
}

// GetAllRecords is a free data retrieval call binding the contract method 0x78d573a2.
//
// Solidity: function getAllRecords(string name) view returns((address,uint256)[])
func (_IRegistry *IRegistryCaller) GetAllRecords(opts *bind.CallOpts, name string) ([]IRegistryRecord, error) {
	var out []interface{}
	err := _IRegistry.contract.Call(opts, &out, "getAllRecords", name)

	if err != nil {
		return *new([]IRegistryRecord), err
	}

	out0 := *abi.ConvertType(out[0], new([]IRegistryRecord)).(*[]IRegistryRecord)

	return out0, err

}

// GetAllRecords is a free data retrieval call binding the contract method 0x78d573a2.
//
// Solidity: function getAllRecords(string name) view returns((address,uint256)[])
func (_IRegistry *IRegistrySession) GetAllRecords(name string) ([]IRegistryRecord, error) {
	return _IRegistry.Contract.GetAllRecords(&_IRegistry.CallOpts, name)
}

// GetAllRecords is a free data retrieval call binding the contract method 0x78d573a2.
//
// Solidity: function getAllRecords(string name) view returns((address,uint256)[])
func (_IRegistry *IRegistryCallerSession) GetAllRecords(name string) ([]IRegistryRecord, error) {
	return _IRegistry.Contract.GetAllRecords(&_IRegistry.CallOpts, name)
}

// Names is a free data retrieval call binding the contract method 0x4622ab03.
//
// Solidity: function names(uint256 ) view returns(string)
func (_IRegistry *IRegistryCaller) Names(opts *bind.CallOpts, arg0 *big.Int) (string, error) {
	var out []interface{}
	err := _IRegistry.contract.Call(opts, &out, "names", arg0)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Names is a free data retrieval call binding the contract method 0x4622ab03.
//
// Solidity: function names(uint256 ) view returns(string)
func (_IRegistry *IRegistrySession) Names(arg0 *big.Int) (string, error) {
	return _IRegistry.Contract.Names(&_IRegistry.CallOpts, arg0)
}

// Names is a free data retrieval call binding the contract method 0x4622ab03.
//
// Solidity: function names(uint256 ) view returns(string)
func (_IRegistry *IRegistryCallerSession) Names(arg0 *big.Int) (string, error) {
	return _IRegistry.Contract.Names(&_IRegistry.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_IRegistry *IRegistryCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IRegistry.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_IRegistry *IRegistrySession) Owner() (common.Address, error) {
	return _IRegistry.Contract.Owner(&_IRegistry.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_IRegistry *IRegistryCallerSession) Owner() (common.Address, error) {
	return _IRegistry.Contract.Owner(&_IRegistry.CallOpts)
}

// Records is a free data retrieval call binding the contract method 0x3b51650d.
//
// Solidity: function records(string , uint256 ) view returns(address addr, uint256 activation)
func (_IRegistry *IRegistryCaller) Records(opts *bind.CallOpts, arg0 string, arg1 *big.Int) (struct {
	Addr       common.Address
	Activation *big.Int
}, error) {
	var out []interface{}
	err := _IRegistry.contract.Call(opts, &out, "records", arg0, arg1)

	outstruct := new(struct {
		Addr       common.Address
		Activation *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Addr = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.Activation = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// Records is a free data retrieval call binding the contract method 0x3b51650d.
//
// Solidity: function records(string , uint256 ) view returns(address addr, uint256 activation)
func (_IRegistry *IRegistrySession) Records(arg0 string, arg1 *big.Int) (struct {
	Addr       common.Address
	Activation *big.Int
}, error) {
	return _IRegistry.Contract.Records(&_IRegistry.CallOpts, arg0, arg1)
}

// Records is a free data retrieval call binding the contract method 0x3b51650d.
//
// Solidity: function records(string , uint256 ) view returns(address addr, uint256 activation)
func (_IRegistry *IRegistryCallerSession) Records(arg0 string, arg1 *big.Int) (struct {
	Addr       common.Address
	Activation *big.Int
}, error) {
	return _IRegistry.Contract.Records(&_IRegistry.CallOpts, arg0, arg1)
}

// Register is a paid mutator transaction binding the contract method 0xd393c871.
//
// Solidity: function register(string name, address addr, uint256 activation) returns()
func (_IRegistry *IRegistryTransactor) Register(opts *bind.TransactOpts, name string, addr common.Address, activation *big.Int) (*types.Transaction, error) {
	return _IRegistry.contract.Transact(opts, "register", name, addr, activation)
}

// Register is a paid mutator transaction binding the contract method 0xd393c871.
//
// Solidity: function register(string name, address addr, uint256 activation) returns()
func (_IRegistry *IRegistrySession) Register(name string, addr common.Address, activation *big.Int) (*types.Transaction, error) {
	return _IRegistry.Contract.Register(&_IRegistry.TransactOpts, name, addr, activation)
}

// Register is a paid mutator transaction binding the contract method 0xd393c871.
//
// Solidity: function register(string name, address addr, uint256 activation) returns()
func (_IRegistry *IRegistryTransactorSession) Register(name string, addr common.Address, activation *big.Int) (*types.Transaction, error) {
	return _IRegistry.Contract.Register(&_IRegistry.TransactOpts, name, addr, activation)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_IRegistry *IRegistryTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _IRegistry.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_IRegistry *IRegistrySession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _IRegistry.Contract.TransferOwnership(&_IRegistry.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_IRegistry *IRegistryTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _IRegistry.Contract.TransferOwnership(&_IRegistry.TransactOpts, newOwner)
}

// IRegistryOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the IRegistry contract.
type IRegistryOwnershipTransferredIterator struct {
	Event *IRegistryOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IRegistryOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IRegistryOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IRegistryOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IRegistryOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IRegistryOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IRegistryOwnershipTransferred represents a OwnershipTransferred event raised by the IRegistry contract.
type IRegistryOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_IRegistry *IRegistryFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*IRegistryOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _IRegistry.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &IRegistryOwnershipTransferredIterator{contract: _IRegistry.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_IRegistry *IRegistryFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *IRegistryOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _IRegistry.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IRegistryOwnershipTransferred)
				if err := _IRegistry.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_IRegistry *IRegistryFilterer) ParseOwnershipTransferred(log types.Log) (*IRegistryOwnershipTransferred, error) {
	event := new(IRegistryOwnershipTransferred)
	if err := _IRegistry.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IRegistryRegisteredIterator is returned from FilterRegistered and is used to iterate over the raw logs and unpacked data for Registered events raised by the IRegistry contract.
type IRegistryRegisteredIterator struct {
	Event *IRegistryRegistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IRegistryRegisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IRegistryRegistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IRegistryRegistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IRegistryRegisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IRegistryRegisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IRegistryRegistered represents a Registered event raised by the IRegistry contract.
type IRegistryRegistered struct {
	Name       string
	Addr       common.Address
	Activation *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRegistered is a free log retrieval operation binding the contract event 0x142e1fdac7ecccbc62af925f0b4039db26847b625602e56b1421dfbc8a0e4f30.
//
// Solidity: event Registered(string name, address indexed addr, uint256 indexed activation)
func (_IRegistry *IRegistryFilterer) FilterRegistered(opts *bind.FilterOpts, addr []common.Address, activation []*big.Int) (*IRegistryRegisteredIterator, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var activationRule []interface{}
	for _, activationItem := range activation {
		activationRule = append(activationRule, activationItem)
	}

	logs, sub, err := _IRegistry.contract.FilterLogs(opts, "Registered", addrRule, activationRule)
	if err != nil {
		return nil, err
	}
	return &IRegistryRegisteredIterator{contract: _IRegistry.contract, event: "Registered", logs: logs, sub: sub}, nil
}

// WatchRegistered is a free log subscription operation binding the contract event 0x142e1fdac7ecccbc62af925f0b4039db26847b625602e56b1421dfbc8a0e4f30.
//
// Solidity: event Registered(string name, address indexed addr, uint256 indexed activation)
func (_IRegistry *IRegistryFilterer) WatchRegistered(opts *bind.WatchOpts, sink chan<- *IRegistryRegistered, addr []common.Address, activation []*big.Int) (event.Subscription, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var activationRule []interface{}
	for _, activationItem := range activation {
		activationRule = append(activationRule, activationItem)
	}

	logs, sub, err := _IRegistry.contract.WatchLogs(opts, "Registered", addrRule, activationRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IRegistryRegistered)
				if err := _IRegistry.contract.UnpackLog(event, "Registered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRegistered is a log parse operation binding the contract event 0x142e1fdac7ecccbc62af925f0b4039db26847b625602e56b1421dfbc8a0e4f30.
//
// Solidity: event Registered(string name, address indexed addr, uint256 indexed activation)
func (_IRegistry *IRegistryFilterer) ParseRegistered(log types.Log) (*IRegistryRegistered, error) {
	event := new(IRegistryRegistered)
	if err := _IRegistry.contract.UnpackLog(event, "Registered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OwnableMetaData contains all meta data concerning the Ownable contract.
var OwnableMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"8da5cb5b": "owner()",
		"715018a6": "renounceOwnership()",
		"f2fde38b": "transferOwnership(address)",
	},
}

// OwnableABI is the input ABI used to generate the binding from.
// Deprecated: Use OwnableMetaData.ABI instead.
var OwnableABI = OwnableMetaData.ABI

// OwnableBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const OwnableBinRuntime = ``

// Deprecated: Use OwnableMetaData.Sigs instead.
// OwnableFuncSigs maps the 4-byte function signature to its string representation.
var OwnableFuncSigs = OwnableMetaData.Sigs

// Ownable is an auto generated Go binding around a Kaia contract.
type Ownable struct {
	OwnableCaller     // Read-only binding to the contract
	OwnableTransactor // Write-only binding to the contract
	OwnableFilterer   // Log filterer for contract events
}

// OwnableCaller is an auto generated read-only Go binding around a Kaia contract.
type OwnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableTransactor is an auto generated write-only Go binding around a Kaia contract.
type OwnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type OwnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type OwnableSession struct {
	Contract     *Ownable          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnableCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type OwnableCallerSession struct {
	Contract *OwnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// OwnableTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type OwnableTransactorSession struct {
	Contract     *OwnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// OwnableRaw is an auto generated low-level Go binding around a Kaia contract.
type OwnableRaw struct {
	Contract *Ownable // Generic contract binding to access the raw methods on
}

// OwnableCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type OwnableCallerRaw struct {
	Contract *OwnableCaller // Generic read-only contract binding to access the raw methods on
}

// OwnableTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type OwnableTransactorRaw struct {
	Contract *OwnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOwnable creates a new instance of Ownable, bound to a specific deployed contract.
func NewOwnable(address common.Address, backend bind.ContractBackend) (*Ownable, error) {
	contract, err := bindOwnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Ownable{OwnableCaller: OwnableCaller{contract: contract}, OwnableTransactor: OwnableTransactor{contract: contract}, OwnableFilterer: OwnableFilterer{contract: contract}}, nil
}

// NewOwnableCaller creates a new read-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableCaller(address common.Address, caller bind.ContractCaller) (*OwnableCaller, error) {
	contract, err := bindOwnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableCaller{contract: contract}, nil
}

// NewOwnableTransactor creates a new write-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableTransactor(address common.Address, transactor bind.ContractTransactor) (*OwnableTransactor, error) {
	contract, err := bindOwnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableTransactor{contract: contract}, nil
}

// NewOwnableFilterer creates a new log filterer instance of Ownable, bound to a specific deployed contract.
func NewOwnableFilterer(address common.Address, filterer bind.ContractFilterer) (*OwnableFilterer, error) {
	contract, err := bindOwnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OwnableFilterer{contract: contract}, nil
}

// bindOwnable binds a generic wrapper to an already deployed contract.
func bindOwnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := OwnableMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.OwnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transact(opts, method, params...)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Ownable.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCallerSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// OwnableOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Ownable contract.
type OwnableOwnershipTransferredIterator struct {
	Event *OwnableOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OwnableOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OwnableOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OwnableOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OwnableOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OwnableOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OwnableOwnershipTransferred represents a OwnershipTransferred event raised by the Ownable contract.
type OwnableOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OwnableOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OwnableOwnershipTransferredIterator{contract: _Ownable.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OwnableOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OwnableOwnershipTransferred)
				if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) ParseOwnershipTransferred(log types.Log) (*OwnableOwnershipTransferred, error) {
	event := new(OwnableOwnershipTransferred)
	if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
