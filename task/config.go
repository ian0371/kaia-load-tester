package task

import (
	"context"
	"fmt"
	"github.com/klaytn/klaytn/params"
	"log"
	"math/big"
	"net/http"
	"os"
	"strings"
	"syscall"
	"time"

	"github.com/klaytn/klaytn-load-tester/klayslave/account"
	klay "github.com/klaytn/klaytn/client"
	"github.com/myzhan/boomer"
	"github.com/urfave/cli"
)

type Config struct {
	// Directly from flags
	nUserForUnsigned    int
	nUserForSigned      int
	nUserForNewAccounts int
	activeUserPercent   int

	richWalletPrivateKey string
	localReservoir       *account.Account
	tcNameList           []string

	chargeKLAYAmount  int
	chargeParallelNum int

	gEndpoint string

	// Directly from connected node
	gasPrice *big.Int
	chainID  *big.Int
	baseFee  *big.Int

	// Additionally generated by this test code
	gCli                 *klay.Client
	accGrpForUnsignedTx  []*account.Account
	accGrpForSignedTx    []*account.Account
	accGrpForNewAccounts []*account.Account
	smartContractAccount *account.Account
}

func NewConfig(ctx *cli.Context) *Config {
	var config Config
	config.setConfigsFromFlag(ctx)
	config.setConfigsFromNode()

	// setup default http client
	if tr, ok := http.DefaultTransport.(*http.Transport); ok {
		maxIdleConns := ctx.Int("tc.maxidleconns")
		tr.MaxIdleConns = maxIdleConns
		tr.MaxIdleConnsPerHost = maxIdleConns
	}
	config.setBoomerFlags(ctx)
	return &config
}

func (cfg *Config) setBoomerFlags(ctx *cli.Context) {
	maxRPC := ctx.Int("max-rps")
	masterHost := ctx.String("master-host")
	masterPort := ctx.Int("master-port")

	os.Args = append([]string{os.Args[0]},
		"--max-rps", fmt.Sprintf("%d", maxRPC),
		"--master-host", masterHost,
		"--master-port", fmt.Sprintf("%d", masterPort),
	)
}
func (cfg *Config) setConfigsFromFlag(ctx *cli.Context) {
	// Directly store the flag value
	cfg.gEndpoint = ctx.String("endpoint")
	cfg.nUserForUnsigned = ctx.Int("vusigned")
	cfg.nUserForSigned = ctx.Int("vuunsigned")
	cfg.nUserForNewAccounts = 5
	cfg.activeUserPercent = ctx.Int("activeUserPercent")
	cfg.chargeKLAYAmount = ctx.Int("charge")
	cfg.chargeParallelNum = ctx.Int("chargeParallel")
	cfg.richWalletPrivateKey = ctx.String("key")

	// Do not allow null richWalletPrivateKey
	if cfg.richWalletPrivateKey == "" {
		log.Fatal("key argument is not defined. You should set the key for the rich account.\n example) klaytc -key='2ef07640fd8d3f568c23185799ee92e0154bf08ccfe5c509466d1d40baca3430'")
	}
	// Do not allow the activeUserPercent which value is less than 0 or larger than 100
	if cfg.activeUserPercent > 100 || cfg.activeUserPercent <= 0 {
		log.Fatalf("ActiveAccountPercent should be between 0 and 100, but it is %v", cfg.activeUserPercent)
	}
	// Parse tcNames
	tcNames := ctx.String("tc")
	for _, name := range strings.Split(tcNames, ",") {
		// skip unknown tc
		if _, ok := tcList[name]; !ok {
			continue
		}
		// add known tc
		cfg.tcNameList = append(cfg.tcNameList, name)
	}
	if len(cfg.tcNameList) == 0 {
		log.Fatal("No valid Tc is set. Please set valid TcList. \n Input tcList was '" + tcNames + "'")
	}

	fmt.Println("Arguments are set like the following:")
	fmt.Printf("- Target EndPoint = %v\n", cfg.gEndpoint)
	fmt.Printf("- nUserForSigned = %v\n", cfg.nUserForSigned)
	fmt.Printf("- nUserForUnsigned = %v\n", cfg.nUserForUnsigned)
	fmt.Printf("- activeUserPercent = %v\n", cfg.activeUserPercent)
	fmt.Printf("- coinbasePrivatekey = %v\n", cfg.richWalletPrivateKey)
	fmt.Printf("- charging KLAY Amount = %v\n", cfg.chargeKLAYAmount)
	fmt.Printf("- tc = %v\n", cfg.tcNameList)
}

func (cfg *Config) setConfigsFromNode() {
	var err error

	// Create Cli pool
	if cfg.gCli, err = klay.Dial(cfg.gEndpoint); err != nil {
		log.Fatalf("Failed to connect RPC: %v", err)
	}

	// TODO: refactor to updating gasPrice with goverance.magma.upperboundbasefee
	cfg.gasPrice = big.NewInt(750000000000)
	cfg.chainID = big.NewInt(2018)
	cfg.baseFee = big.NewInt(0)

	// update ChainID
	fmt.Println("Updating ChainID from RPC")
	for {
		ctx := context.Background()
		chainID, err := cfg.gCli.ChainID(ctx)

		if err == nil {
			fmt.Println("chainID :", chainID)
			cfg.chainID = chainID
			break
		}
		fmt.Println("Retrying updating chainID... ERR: ", err)

		time.Sleep(2 * time.Second)
	}

	// update
	// TODO: Uncomment below when klaytn 1.8.0 is released.
	//for {
	//	ctx := context.Background()
	//	h, err := gCli.HeaderByNumber(ctx, nil)
	//
	//	if err == nil {
	//		baseFee = h.BaseFee
	//		fmt.Println("base fee :", baseFee.String())
	//		break
	//	}
	//	fmt.Println("Retrying updating BaseFee... ERR: ", err)
	//
	//	time.Sleep(2 * time.Second)
	//}

	account.SetChainID(cfg.chainID)
	account.SetGasPrice(cfg.gasPrice)
	account.SetBaseFee(cfg.baseFee)
}

func (cfg *Config) GetBoomerTasksList() []*boomer.Task {
	var tasks []*boomer.Task
	for _, name := range cfg.tcNameList {
		// skip unknown tc
		if _, ok := tcList[name]; !ok {
			continue
		}
		// add known tc
		extendedTask := tcList[name]
		tasks = append(tasks, &boomer.Task{Weight: extendedTask.Weight, Fn: extendedTask.Fn, Name: extendedTask.Name})
	}
	return tasks
}

func (cfg *Config) GetExtendedTasksList() []*ExtendedTask {
	var tasks []*ExtendedTask
	for _, name := range cfg.tcNameList {
		tasks = append(tasks, tcList[name])
	}
	return tasks
}

func (cfg *Config) InitTasks() {
	for _, task := range cfg.GetExtendedTasksList() {
		accGrp := cfg.accGrpForSignedTx
		if task.Name == "transferUnsignedTx" {
			accGrp = cfg.accGrpForUnsignedTx
		}
		task.Init(accGrp, cfg.gEndpoint, cfg.gasPrice)
		println("=> " + task.Name + " task is initialized.")
	}
}

func (cfg *Config) GetActiveUserPercent() int           { return cfg.activeUserPercent }
func (cfg *Config) GetTcStrList() []string              { return cfg.tcNameList }
func (cfg *Config) GetRichWalletPrivateKey() string     { return cfg.richWalletPrivateKey }
func (cfg *Config) GetGCli() *klay.Client               { return cfg.gCli }
func (cfg *Config) GetLocalReservoir() *account.Account { return cfg.localReservoir }
func (cfg *Config) GetAllAccGrp() []*account.Account {
	var accGrp []*account.Account
	for _, acc := range cfg.accGrpForSignedTx {
		accGrp = append(accGrp, acc)
	}
	if !cfg.InTheTcList("transferUnsignedTx") {
		return accGrp
	}
	for _, acc := range cfg.accGrpForUnsignedTx {
		accGrp = append(accGrp, acc)
	}
	return accGrp
}
func (cfg *Config) InTheTcList(tcName string) bool {
	for _, tc := range cfg.tcNameList {
		if tcName == tc {
			return true
		}
	}
	return false
}
func (cfg *Config) GetChargeValue() *big.Int {
	return new(big.Int).Mul(big.NewInt(int64(cfg.chargeKLAYAmount)), big.NewInt(params.KLAY))
}
func (cfg *Config) GetTotalChargeValue() *big.Int {
	return new(big.Int).Mul(cfg.GetChargeValue(), big.NewInt(int64(cfg.nUserForUnsigned+cfg.nUserForSigned+cfg.nUserForNewAccounts+1)))
}
func (cfg *Config) InitAccGrp() {
	println("Unsigned Account Group Preparation...")
	//bar := pb.StartNew(nUserForUnsigned)

	// Create test account pool
	for i := 0; i < cfg.nUserForUnsigned; i++ {
		cfg.accGrpForUnsignedTx = append(cfg.accGrpForUnsignedTx, account.NewAccount(i))
		fmt.Printf("%v\n", cfg.accGrpForUnsignedTx[i].GetAddress().String())
		//bar.Increment()
	}
	//bar.Finish()	//bar.FinishPrint("Completed.")
	//
	println("Signed Account Group Preparation...")
	//bar = pb.StartNew(nUserForSigned)

	for i := 0; i < cfg.nUserForSigned; i++ {
		cfg.accGrpForSignedTx = append(cfg.accGrpForSignedTx, account.NewAccount(i))
		fmt.Printf("%v\n", cfg.accGrpForSignedTx[i].GetAddress().String())
		//bar.Increment()
	}

	println("New account group preparation...")
	for i := 0; i < cfg.nUserForNewAccounts; i++ {
		cfg.accGrpForNewAccounts = append(cfg.accGrpForNewAccounts, account.NewKlaytnAccount(i))
	}
}

func (cfg *Config) SetLocalReservoirAccount(acc *account.Account) {
	cfg.localReservoir = acc
}

func (cfg *Config) SetAccGrpByActivePercent() {
	for _, accGrp := range [][]*account.Account{cfg.accGrpForSignedTx, cfg.accGrpForUnsignedTx, cfg.accGrpForNewAccounts} {
		numActiveAccGrpForSignedTx := len(accGrp) * cfg.activeUserPercent / 100
		// Not to assign 0 account for some cases.
		if numActiveAccGrpForSignedTx == 0 {
			numActiveAccGrpForSignedTx = 1
		}

		accGrp = accGrp[:numActiveAccGrpForSignedTx]
	}
}

func (cfg *Config) UnlockAccGrpForUnsignedIfNeeded() {
	for _, tcName := range cfg.tcNameList {
		if tcName != "transferUnsignedTx" {
			continue
		}
		// If at least one task needs unlocking, unlock the accGrp for unsignedTx.
		for _, acc := range cfg.accGrpForUnsignedTx {
			acc.ImportUnLockAccount(cfg.gEndpoint)
		}
		break
	}
	return
}

// Flags TODO-kaia-load-tester: add env.var
var Flags = []cli.Flag{
	cli.StringFlag{Name: "endpoint", Value: "http://localhost:8551", Usage: "Target EndPoint"},
	cli.IntFlag{Name: "vusigned", Value: 5, Usage: "num of test account for signed Tx TC"},
	cli.IntFlag{Name: "vuunsigned", Value: 5, Usage: "num of test account for unsigned Tx TC"},
	//cli.IntFlag{Name: "acc.nUserForNewAccounts", Value: 5, Usage: "num of new accounts"}, // TODO-kaia-load-tester: find out what this value for
	cli.IntFlag{Name: "activeUserPercent", Value: 100, Usage: "percent of active accounts"},
	cli.IntFlag{Name: "charge", Value: 1000000000, Usage: "charging amount for each test account in KLAY"},
	cli.IntFlag{Name: "maxidleconns", Value: 100, Usage: "maximum number of idle connections in default http client"},
	cli.StringFlag{Name: "key", Usage: "private key of rich account for kaia charging of test accounts"},
	cli.StringFlag{Name: "tc", Value: "", Usage: "tasks which user want to run, multiple tasks are separated by comma."},
}

var BoomerFlags = []cli.Flag{
	cli.IntFlag{Name: "max-rps", Usage: "Maximum number of RPC calls"},
	cli.StringFlag{Name: "master-host", Usage: "Url for the locust master"},
	cli.StringFlag{Name: "master-port", Usage: "Port for the locust master"},
}

func SetRLimit() error {
	var rLimit syscall.Rlimit
	// TODO-kaia-load-tester: no need
	err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &rLimit)
	if err != nil {
		return err
	}
	rLimit.Cur = 1024 * 400
	err = syscall.Setrlimit(syscall.RLIMIT_NOFILE, &rLimit)
	if err != nil {
		return err
	}
	return nil
}
