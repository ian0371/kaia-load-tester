// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package auction

import (
	"errors"
	"math/big"
	"strings"

	"github.com/kaiachain/kaia"
	"github.com/kaiachain/kaia/accounts/abi"
	"github.com/kaiachain/kaia/accounts/abi/bind"
	"github.com/kaiachain/kaia/blockchain/types"
	"github.com/kaiachain/kaia/common"
	"github.com/kaiachain/kaia/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = kaia.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// IAuctionEntryPointAuctionTx is an auto generated low-level Go binding around an user-defined struct.
type IAuctionEntryPointAuctionTx struct {
	TargetTxHash  [32]byte
	BlockNumber   *big.Int
	Sender        common.Address
	To            common.Address
	Nonce         *big.Int
	Bid           *big.Int
	CallGasLimit  *big.Int
	Data          []byte
	SearcherSig   []byte
	AuctioneerSig []byte
}

// AuctionEntryPointMetaData contains all meta data concerning the AuctionEntryPoint contract.
var AuctionEntryPointMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_auctioneer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EmptyDepositVault\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentNonce\",\"type\":\"uint256\"}],\"name\":\"InvalidAccountNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinDepositNotOver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAuctionDepositVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyEntryPoint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyProposer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyStakingAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawReservationExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalNotAllowedYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroDepositAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Call\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"CallFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAuctioneer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAuctioneer\",\"type\":\"address\"}],\"name\":\"ChangeAuctioneer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDepositVault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDepositVault\",\"type\":\"address\"}],\"name\":\"ChangeDepositVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"UseNonce\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AUCTION_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AUCTION_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_BUFFER_ESTIMATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_BUFFER_UNMEASURED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_CONTRACT_EXECUTION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_PER_BYTE_EIP_7623\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_PER_BYTE_INTRINSIC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctioneer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"targetTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"searcherSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auctioneerSig\",\"type\":\"bytes\"}],\"internalType\":\"structIAuctionEntryPoint.AuctionTx\",\"name\":\"auctionTx\",\"type\":\"tuple\"}],\"name\":\"call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_auctioneer\",\"type\":\"address\"}],\"name\":\"changeAuctioneer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositVault\",\"type\":\"address\"}],\"name\":\"changeDepositVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositVault\",\"outputs\":[{\"internalType\":\"contractIAuctionDepositVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"targetTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"searcherSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auctioneerSig\",\"type\":\"bytes\"}],\"internalType\":\"structIAuctionEntryPoint.AuctionTx\",\"name\":\"auctionTx\",\"type\":\"tuple\"}],\"name\":\"getAuctionTxHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"searchers\",\"type\":\"address[]\"}],\"name\":\"getNonceAndBids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nonces_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bids_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"d2da236e": "AUCTION_NAME()",
		"9fc99426": "AUCTION_VERSION()",
		"e4a973dd": "GAS_BUFFER_ESTIMATE()",
		"eb322e74": "GAS_BUFFER_UNMEASURED()",
		"0a409e29": "GAS_CONTRACT_EXECUTION()",
		"b2f5f4ca": "GAS_PER_BYTE_EIP_7623()",
		"aa65b344": "GAS_PER_BYTE_INTRINSIC()",
		"5ec2c7bf": "auctioneer()",
		"ca157554": "call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes))",
		"774f45ec": "changeAuctioneer(address)",
		"9d59928b": "changeDepositVault(address)",
		"d7cd3949": "depositVault()",
		"84b0196e": "eip712Domain()",
		"a8aa9450": "getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes))",
		"287ca78e": "getNonceAndBids(address[])",
		"7ecebe00": "nonces(address)",
		"8da5cb5b": "owner()",
		"715018a6": "renounceOwnership()",
		"f2fde38b": "transferOwnership(address)",
	},
	Bin: "0x610160604052348015610010575f80fd5b50604051611b98380380611b9883398101604081905261002f91610264565b604080518082018252600c81526b25a0a4a0afa0aaa1aa24a7a760a11b60208083019190915282518084019093526005835264302e302e3160d81b90830152849161007b826001610189565b6101205261008a816002610189565b61014052815160208084019190912060e052815190820120610100524660a05261011660e05161010051604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60208201529081019290925260608201524660808201523060a08201525f9060c00160405160208183030381529060405280519060200120905090565b60805250503060c0526001600160a01b03811661014d57604051631e4fbdf760e01b81525f60048201526024015b60405180910390fd5b610156816101bb565b50600480546001600160a01b039384166001600160a01b0319918216179091556005805492909316911617905550610453565b5f6020835110156101a45761019d8361020c565b90506101b5565b816101af848261033c565b5060ff90505b92915050565b600380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b5f80829050601f81511115610236578260405163305a27a960e01b815260040161014491906103fb565b805161024182610430565b179392505050565b80516001600160a01b038116811461025f575f80fd5b919050565b5f805f60608486031215610276575f80fd5b61027f84610249565b925061028d60208501610249565b915061029b60408501610249565b90509250925092565b634e487b7160e01b5f52604160045260245ffd5b600181811c908216806102cc57607f821691505b6020821081036102ea57634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561033757805f5260205f20601f840160051c810160208510156103155750805b601f840160051c820191505b81811015610334575f8155600101610321565b50505b505050565b81516001600160401b03811115610355576103556102a4565b6103698161036384546102b8565b846102f0565b602080601f83116001811461039c575f84156103855750858301515b5f19600386901b1c1916600185901b1785556103f3565b5f85815260208120601f198616915b828110156103ca578886015182559484019460019091019084016103ab565b50858210156103e757878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b805160208083015191908110156102ea575f1960209190910360031b1b16919050565b60805160a05160c05160e0516101005161012051610140516116f46104a45f395f6108b101525f61087f01525f61118501525f61115d01525f6110b801525f6110e201525f61110c01526116f45ff3fe608060405234801561000f575f80fd5b506004361061011c575f3560e01c80639fc99426116100a9578063d2da236e1161006e578063d2da236e14610273578063d7cd39491461029e578063e4a973dd146102b1578063eb322e74146102bb578063f2fde38b146102c4575f80fd5b80639fc994261461020c578063a8aa94501461023d578063aa65b34414610250578063b2f5f4ca14610258578063ca15755414610260575f80fd5b8063774f45ec116100ef578063774f45ec146101925780637ecebe00146101a557806384b0196e146101cd5780638da5cb5b146101e85780639d59928b146101f9575f80fd5b80630a409e2914610120578063287ca78e1461013c5780635ec2c7bf1461015d578063715018a614610188575b5f80fd5b61012961520881565b6040519081526020015b60405180910390f35b61014f61014a36600461131a565b6102d7565b604051610133929190611414565b600554610170906001600160a01b031681565b6040516001600160a01b039091168152602001610133565b610190610463565b005b6101906101a0366004611441565b610476565b6101296101b3366004611441565b6001600160a01b03165f9081526020819052604090205490565b6101d5610510565b6040516101339796959493929190611488565b6003546001600160a01b0316610170565b610190610207366004611441565b610552565b61023060405180604001604052806005815260200164302e302e3160d81b81525081565b60405161013391906114f7565b61012961024b366004611509565b6105ec565b610129601081565b610129602881565b61019061026e366004611509565b6105fc565b6102306040518060400160405280600c81526020016b25a0a4a0afa0aaa1aa24a7a760a11b81525081565b600454610170906001600160a01b031681565b6101296202bf2081565b610129614e2081565b6101906102d2366004611441565b6107b8565b606080825167ffffffffffffffff8111156102f4576102f46112eb565b60405190808252806020026020018201604052801561031d578160200160208202803683370190505b509150825167ffffffffffffffff81111561033a5761033a6112eb565b604051908082528060200260200182016040528015610363578160200160208202803683370190505b5090505f5b835181101561045d575f84828151811061038457610384611541565b602002602001015190506103ac816001600160a01b03165f9081526020819052604090205490565b8483815181106103be576103be611541565b602090810291909101015260048054604051631eb903cf60e01b81526001600160a01b0384811693820193909352911690631eb903cf90602401602060405180830381865afa158015610413573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104379190611555565b83838151811061044957610449611541565b602090810291909101015250600101610368565b50915091565b61046b6107fa565b6104745f610827565b565b61047e6107fa565b806001600160a01b0381166104a65760405163d92e233d60e01b815260040160405180910390fd5b600554604080516001600160a01b03928316815291841660208301527fc8a0473779a405800019e7658500d0930d92f78e776b553d286baeefb9c9a0f1910160405180910390a150600580546001600160a01b0319166001600160a01b0392909216919091179055565b5f6060805f805f6060610521610878565b6105296108aa565b604080515f80825260208201909252600f60f81b9b939a50919850469750309650945092509050565b61055a6107fa565b806001600160a01b0381166105825760405163d92e233d60e01b815260040160405180910390fd5b600454604080516001600160a01b03928316815291841660208301527f32718750012b831b1e21ea05c1ed833c9365fc94e7316126303f6d09f41beb5d910160405180910390a150600480546001600160a01b0319166001600160a01b0392909216919091179055565b5f6105f6826108d7565b92915050565b33411461061c57604051630608c7c960e51b815260040160405180910390fd5b6004546001600160a01b031661064557604051637941e9ad60e01b815260040160405180910390fd5b5f5a90505f61065a6060840160408501611441565b905060c083013561066a846109be565b610672575f80fd5b610681828560a0013583610b60565b610689575f80fd5b5f61069383610c91565b90505f6106a66080870160608801611441565b6001600160a01b0316836106bd60e089018961156c565b6040516106cb9291906115b6565b5f604051808303815f8787f1925050503d805f8114610705576040519150601f19603f3d011682016040523d82523d5f602084013e61070a565b606091505b50509050801561075b57604080516001600160a01b0386168152602081018490527f9e4369a013b5e45a103a959d8eb70f15c55dc496e8335f245690393dfb4b71d4910160405180910390a161079e565b604080516001600160a01b0386168152602081018490527fb9eaeae386d339f8115782f297a9e5f0e13fb587cd6b0d502f113cb8dd4d6cb0910160405180910390a15b6107a88486610d06565b6107b0575f80fd5b505050505050565b6107c06107fa565b6001600160a01b0381166107ee57604051631e4fbdf760e01b81525f60048201526024015b60405180910390fd5b6107f781610827565b50565b6003546001600160a01b031633146104745760405163118cdaa760e01b81523360048201526024016107e5565b600380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b60606108a57f00000000000000000000000000000000000000000000000000000000000000006001610da3565b905090565b60606108a57f00000000000000000000000000000000000000000000000000000000000000006002610da3565b5f7f76991d1c87749d29787e5ad5e05218607b00b6b1bd07277e6061cf4456f0b2b0823560208401356109106060860160408701611441565b6109206080870160608801611441565b608087013560a088013560c089013561093c60e08b018b61156c565b60405161094a9291906115b6565b60408051918290038220602083019a909a5281019790975260608701959095526001600160a01b0393841660808701529290911660a085015260c084015260e0830152610100820152610120810191909152610140015b604051602081830303815290604052805190602001209050919050565b5f438260200135146109d157505f919050565b5f8260a00135116109e357505f919050565b5f610a2e6109f561010085018561156c565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610e4c92505050565b90505f610a7e610a4261012086018661156c565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508693925050610e699050565b50506005549091506001600160a01b03808316911614610aa157505f9392505050565b5f610aab856108d7565b9050610ab681610eb2565b9250610b05610ac961010087018761156c565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508793925050610e699050565b50909250610b1b90506060860160408701611441565b6001600160a01b0316826001600160a01b031614610b3d57505f949350505050565b610b506101b36060870160408801611441565b8560800135149350505050919050565b5f80610b77610b726202bf20856115d9565b610ede565b90505f610b843a836115ec565b610b8e90866115d9565b60048054604051631eb903cf60e01b81526001600160a01b038a8116938201939093529293501690631eb903cf90602401602060405180830381865afa158015610bda573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bfe9190611555565b811115610c0f575f92505050610c8a565b600480546040516308bf759d60e01b81526001600160a01b0389811693820193909352602481018890529116906308bf759d906044016020604051808303815f875af1158015610c61573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610c859190611603565b925050505b9392505050565b6001600160a01b0381165f9081526020819052604081208054600181019091557f7243aab3c75cebfd96dc41ece7762eb023fc8c81e9ba2ce1d487876419b918b583610cde8360016115d9565b604080516001600160a01b03909316835260208301919091520160405180910390a192915050565b5f80610d23614e205a610d199086611622565b610b7291906115d9565b6004805460405163b4fdfae560e01b81526001600160a01b038881169382019390935260248101849052929350169063b4fdfae5906044016020604051808303815f875af1158015610d77573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d9b9190611603565b949350505050565b606060ff8314610dbd57610db683610f17565b90506105f6565b818054610dc990611635565b80601f0160208091040260200160405190810160405280929190818152602001828054610df590611635565b8015610e405780601f10610e1757610100808354040283529160200191610e40565b820191905f5260205f20905b815481529060010190602001808311610e2357829003601f168201915b505050505090506105f6565b5f610e578251610f54565b826040516020016109a1929190611684565b5f805f8351604103610ea0576020840151604085015160608601515f1a610e9288828585610fe4565b955095509550505050610eab565b505081515f91506002905b9250925092565b5f6105f6610ebe6110ac565b8360405161190160f01b8152600281019290925260228201526042902090565b5f80610eea60106111d5565b610ef490846115d9565b90505f610f0160286111d5565b9050808211610f105780610d9b565b5092915050565b60605f610f23836111ed565b6040805160208082528183019092529192505f91906020820181803683375050509182525060208101929092525090565b60605f610f6083611214565b60010190505f8167ffffffffffffffff811115610f7f57610f7f6112eb565b6040519080825280601f01601f191660200182016040528015610fa9576020820181803683370190505b5090508181016020015b5f19016f181899199a1a9b1b9c1cb0b131b232b360811b600a86061a8153600a8504945084610fb357509392505050565b5f80807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a084111561101d57505f915060039050826110a2565b604080515f808252602082018084528a905260ff891692820192909252606081018790526080810186905260019060a0016020604051602081039080840390855afa15801561106e573d5f803e3d5ffd5b5050604051601f1901519150506001600160a01b03811661109957505f9250600191508290506110a2565b92505f91508190505b9450945094915050565b5f306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614801561110457507f000000000000000000000000000000000000000000000000000000000000000046145b1561112e57507f000000000000000000000000000000000000000000000000000000000000000090565b6108a5604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60208201527f0000000000000000000000000000000000000000000000000000000000000000918101919091527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a08201525f9060c00160405160208183030381529060405280519060200120905090565b5f6152086111e383366115ec565b6105f691906115d9565b5f60ff8216601f8111156105f657604051632cd44ac360e21b815260040160405180910390fd5b5f8072184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b83106112525772184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b830492506040015b6d04ee2d6d415b85acef8100000000831061127e576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc10000831061129c57662386f26fc10000830492506010015b6305f5e10083106112b4576305f5e100830492506008015b61271083106112c857612710830492506004015b606483106112da576064830492506002015b600a83106105f65760010192915050565b634e487b7160e01b5f52604160045260245ffd5b80356001600160a01b0381168114611315575f80fd5b919050565b5f602080838503121561132b575f80fd5b823567ffffffffffffffff80821115611342575f80fd5b818501915085601f830112611355575f80fd5b813581811115611367576113676112eb565b8060051b604051601f19603f8301168101818110858211171561138c5761138c6112eb565b6040529182528482019250838101850191888311156113a9575f80fd5b938501935b828510156113ce576113bf856112ff565b845293850193928501926113ae565b98975050505050505050565b5f815180845260208085019450602084015f5b83811015611409578151875295820195908201906001016113ed565b509495945050505050565b604081525f61142660408301856113da565b828103602084015261143881856113da565b95945050505050565b5f60208284031215611451575f80fd5b610c8a826112ff565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b60ff60f81b8816815260e060208201525f6114a660e083018961145a565b82810360408401526114b8818961145a565b606084018890526001600160a01b038716608085015260a0840186905283810360c085015290506114e981856113da565b9a9950505050505050505050565b602081525f610c8a602083018461145a565b5f60208284031215611519575f80fd5b813567ffffffffffffffff81111561152f575f80fd5b82016101408185031215610c8a575f80fd5b634e487b7160e01b5f52603260045260245ffd5b5f60208284031215611565575f80fd5b5051919050565b5f808335601e19843603018112611581575f80fd5b83018035915067ffffffffffffffff82111561159b575f80fd5b6020019150368190038213156115af575f80fd5b9250929050565b818382375f9101908152919050565b634e487b7160e01b5f52601160045260245ffd5b808201808211156105f6576105f66115c5565b80820281158282048414176105f6576105f66115c5565b5f60208284031215611613575f80fd5b81518015158114610c8a575f80fd5b818103818111156105f6576105f66115c5565b600181811c9082168061164957607f821691505b60208210810361166757634e487b7160e01b5f52602260045260245ffd5b50919050565b5f81518060208401855e5f93019283525090919050565b7f19457468657265756d205369676e6564204d6573736167653a0a00000000000081525f610d9b6116b8601a84018661166d565b8461166d56fea2646970667358221220ce68802868ab34fb3e09566b2636ccb2fceeff989ea4ce1e07d475c2daf469ba64736f6c63430008190033",
}

// AuctionEntryPointABI is the input ABI used to generate the binding from.
// Deprecated: Use AuctionEntryPointMetaData.ABI instead.
var AuctionEntryPointABI = AuctionEntryPointMetaData.ABI

// AuctionEntryPointBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const AuctionEntryPointBinRuntime = `608060405234801561000f575f80fd5b506004361061011c575f3560e01c80639fc99426116100a9578063d2da236e1161006e578063d2da236e14610273578063d7cd39491461029e578063e4a973dd146102b1578063eb322e74146102bb578063f2fde38b146102c4575f80fd5b80639fc994261461020c578063a8aa94501461023d578063aa65b34414610250578063b2f5f4ca14610258578063ca15755414610260575f80fd5b8063774f45ec116100ef578063774f45ec146101925780637ecebe00146101a557806384b0196e146101cd5780638da5cb5b146101e85780639d59928b146101f9575f80fd5b80630a409e2914610120578063287ca78e1461013c5780635ec2c7bf1461015d578063715018a614610188575b5f80fd5b61012961520881565b6040519081526020015b60405180910390f35b61014f61014a36600461131a565b6102d7565b604051610133929190611414565b600554610170906001600160a01b031681565b6040516001600160a01b039091168152602001610133565b610190610463565b005b6101906101a0366004611441565b610476565b6101296101b3366004611441565b6001600160a01b03165f9081526020819052604090205490565b6101d5610510565b6040516101339796959493929190611488565b6003546001600160a01b0316610170565b610190610207366004611441565b610552565b61023060405180604001604052806005815260200164302e302e3160d81b81525081565b60405161013391906114f7565b61012961024b366004611509565b6105ec565b610129601081565b610129602881565b61019061026e366004611509565b6105fc565b6102306040518060400160405280600c81526020016b25a0a4a0afa0aaa1aa24a7a760a11b81525081565b600454610170906001600160a01b031681565b6101296202bf2081565b610129614e2081565b6101906102d2366004611441565b6107b8565b606080825167ffffffffffffffff8111156102f4576102f46112eb565b60405190808252806020026020018201604052801561031d578160200160208202803683370190505b509150825167ffffffffffffffff81111561033a5761033a6112eb565b604051908082528060200260200182016040528015610363578160200160208202803683370190505b5090505f5b835181101561045d575f84828151811061038457610384611541565b602002602001015190506103ac816001600160a01b03165f9081526020819052604090205490565b8483815181106103be576103be611541565b602090810291909101015260048054604051631eb903cf60e01b81526001600160a01b0384811693820193909352911690631eb903cf90602401602060405180830381865afa158015610413573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104379190611555565b83838151811061044957610449611541565b602090810291909101015250600101610368565b50915091565b61046b6107fa565b6104745f610827565b565b61047e6107fa565b806001600160a01b0381166104a65760405163d92e233d60e01b815260040160405180910390fd5b600554604080516001600160a01b03928316815291841660208301527fc8a0473779a405800019e7658500d0930d92f78e776b553d286baeefb9c9a0f1910160405180910390a150600580546001600160a01b0319166001600160a01b0392909216919091179055565b5f6060805f805f6060610521610878565b6105296108aa565b604080515f80825260208201909252600f60f81b9b939a50919850469750309650945092509050565b61055a6107fa565b806001600160a01b0381166105825760405163d92e233d60e01b815260040160405180910390fd5b600454604080516001600160a01b03928316815291841660208301527f32718750012b831b1e21ea05c1ed833c9365fc94e7316126303f6d09f41beb5d910160405180910390a150600480546001600160a01b0319166001600160a01b0392909216919091179055565b5f6105f6826108d7565b92915050565b33411461061c57604051630608c7c960e51b815260040160405180910390fd5b6004546001600160a01b031661064557604051637941e9ad60e01b815260040160405180910390fd5b5f5a90505f61065a6060840160408501611441565b905060c083013561066a846109be565b610672575f80fd5b610681828560a0013583610b60565b610689575f80fd5b5f61069383610c91565b90505f6106a66080870160608801611441565b6001600160a01b0316836106bd60e089018961156c565b6040516106cb9291906115b6565b5f604051808303815f8787f1925050503d805f8114610705576040519150601f19603f3d011682016040523d82523d5f602084013e61070a565b606091505b50509050801561075b57604080516001600160a01b0386168152602081018490527f9e4369a013b5e45a103a959d8eb70f15c55dc496e8335f245690393dfb4b71d4910160405180910390a161079e565b604080516001600160a01b0386168152602081018490527fb9eaeae386d339f8115782f297a9e5f0e13fb587cd6b0d502f113cb8dd4d6cb0910160405180910390a15b6107a88486610d06565b6107b0575f80fd5b505050505050565b6107c06107fa565b6001600160a01b0381166107ee57604051631e4fbdf760e01b81525f60048201526024015b60405180910390fd5b6107f781610827565b50565b6003546001600160a01b031633146104745760405163118cdaa760e01b81523360048201526024016107e5565b600380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b60606108a57f00000000000000000000000000000000000000000000000000000000000000006001610da3565b905090565b60606108a57f00000000000000000000000000000000000000000000000000000000000000006002610da3565b5f7f76991d1c87749d29787e5ad5e05218607b00b6b1bd07277e6061cf4456f0b2b0823560208401356109106060860160408701611441565b6109206080870160608801611441565b608087013560a088013560c089013561093c60e08b018b61156c565b60405161094a9291906115b6565b60408051918290038220602083019a909a5281019790975260608701959095526001600160a01b0393841660808701529290911660a085015260c084015260e0830152610100820152610120810191909152610140015b604051602081830303815290604052805190602001209050919050565b5f438260200135146109d157505f919050565b5f8260a00135116109e357505f919050565b5f610a2e6109f561010085018561156c565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610e4c92505050565b90505f610a7e610a4261012086018661156c565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508693925050610e699050565b50506005549091506001600160a01b03808316911614610aa157505f9392505050565b5f610aab856108d7565b9050610ab681610eb2565b9250610b05610ac961010087018761156c565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508793925050610e699050565b50909250610b1b90506060860160408701611441565b6001600160a01b0316826001600160a01b031614610b3d57505f949350505050565b610b506101b36060870160408801611441565b8560800135149350505050919050565b5f80610b77610b726202bf20856115d9565b610ede565b90505f610b843a836115ec565b610b8e90866115d9565b60048054604051631eb903cf60e01b81526001600160a01b038a8116938201939093529293501690631eb903cf90602401602060405180830381865afa158015610bda573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bfe9190611555565b811115610c0f575f92505050610c8a565b600480546040516308bf759d60e01b81526001600160a01b0389811693820193909352602481018890529116906308bf759d906044016020604051808303815f875af1158015610c61573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610c859190611603565b925050505b9392505050565b6001600160a01b0381165f9081526020819052604081208054600181019091557f7243aab3c75cebfd96dc41ece7762eb023fc8c81e9ba2ce1d487876419b918b583610cde8360016115d9565b604080516001600160a01b03909316835260208301919091520160405180910390a192915050565b5f80610d23614e205a610d199086611622565b610b7291906115d9565b6004805460405163b4fdfae560e01b81526001600160a01b038881169382019390935260248101849052929350169063b4fdfae5906044016020604051808303815f875af1158015610d77573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d9b9190611603565b949350505050565b606060ff8314610dbd57610db683610f17565b90506105f6565b818054610dc990611635565b80601f0160208091040260200160405190810160405280929190818152602001828054610df590611635565b8015610e405780601f10610e1757610100808354040283529160200191610e40565b820191905f5260205f20905b815481529060010190602001808311610e2357829003601f168201915b505050505090506105f6565b5f610e578251610f54565b826040516020016109a1929190611684565b5f805f8351604103610ea0576020840151604085015160608601515f1a610e9288828585610fe4565b955095509550505050610eab565b505081515f91506002905b9250925092565b5f6105f6610ebe6110ac565b8360405161190160f01b8152600281019290925260228201526042902090565b5f80610eea60106111d5565b610ef490846115d9565b90505f610f0160286111d5565b9050808211610f105780610d9b565b5092915050565b60605f610f23836111ed565b6040805160208082528183019092529192505f91906020820181803683375050509182525060208101929092525090565b60605f610f6083611214565b60010190505f8167ffffffffffffffff811115610f7f57610f7f6112eb565b6040519080825280601f01601f191660200182016040528015610fa9576020820181803683370190505b5090508181016020015b5f19016f181899199a1a9b1b9c1cb0b131b232b360811b600a86061a8153600a8504945084610fb357509392505050565b5f80807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a084111561101d57505f915060039050826110a2565b604080515f808252602082018084528a905260ff891692820192909252606081018790526080810186905260019060a0016020604051602081039080840390855afa15801561106e573d5f803e3d5ffd5b5050604051601f1901519150506001600160a01b03811661109957505f9250600191508290506110a2565b92505f91508190505b9450945094915050565b5f306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614801561110457507f000000000000000000000000000000000000000000000000000000000000000046145b1561112e57507f000000000000000000000000000000000000000000000000000000000000000090565b6108a5604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60208201527f0000000000000000000000000000000000000000000000000000000000000000918101919091527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a08201525f9060c00160405160208183030381529060405280519060200120905090565b5f6152086111e383366115ec565b6105f691906115d9565b5f60ff8216601f8111156105f657604051632cd44ac360e21b815260040160405180910390fd5b5f8072184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b83106112525772184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b830492506040015b6d04ee2d6d415b85acef8100000000831061127e576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc10000831061129c57662386f26fc10000830492506010015b6305f5e10083106112b4576305f5e100830492506008015b61271083106112c857612710830492506004015b606483106112da576064830492506002015b600a83106105f65760010192915050565b634e487b7160e01b5f52604160045260245ffd5b80356001600160a01b0381168114611315575f80fd5b919050565b5f602080838503121561132b575f80fd5b823567ffffffffffffffff80821115611342575f80fd5b818501915085601f830112611355575f80fd5b813581811115611367576113676112eb565b8060051b604051601f19603f8301168101818110858211171561138c5761138c6112eb565b6040529182528482019250838101850191888311156113a9575f80fd5b938501935b828510156113ce576113bf856112ff565b845293850193928501926113ae565b98975050505050505050565b5f815180845260208085019450602084015f5b83811015611409578151875295820195908201906001016113ed565b509495945050505050565b604081525f61142660408301856113da565b828103602084015261143881856113da565b95945050505050565b5f60208284031215611451575f80fd5b610c8a826112ff565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b60ff60f81b8816815260e060208201525f6114a660e083018961145a565b82810360408401526114b8818961145a565b606084018890526001600160a01b038716608085015260a0840186905283810360c085015290506114e981856113da565b9a9950505050505050505050565b602081525f610c8a602083018461145a565b5f60208284031215611519575f80fd5b813567ffffffffffffffff81111561152f575f80fd5b82016101408185031215610c8a575f80fd5b634e487b7160e01b5f52603260045260245ffd5b5f60208284031215611565575f80fd5b5051919050565b5f808335601e19843603018112611581575f80fd5b83018035915067ffffffffffffffff82111561159b575f80fd5b6020019150368190038213156115af575f80fd5b9250929050565b818382375f9101908152919050565b634e487b7160e01b5f52601160045260245ffd5b808201808211156105f6576105f66115c5565b80820281158282048414176105f6576105f66115c5565b5f60208284031215611613575f80fd5b81518015158114610c8a575f80fd5b818103818111156105f6576105f66115c5565b600181811c9082168061164957607f821691505b60208210810361166757634e487b7160e01b5f52602260045260245ffd5b50919050565b5f81518060208401855e5f93019283525090919050565b7f19457468657265756d205369676e6564204d6573736167653a0a00000000000081525f610d9b6116b8601a84018661166d565b8461166d56fea2646970667358221220ce68802868ab34fb3e09566b2636ccb2fceeff989ea4ce1e07d475c2daf469ba64736f6c63430008190033`

// Deprecated: Use AuctionEntryPointMetaData.Sigs instead.
// AuctionEntryPointFuncSigs maps the 4-byte function signature to its string representation.
var AuctionEntryPointFuncSigs = AuctionEntryPointMetaData.Sigs

// AuctionEntryPointBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AuctionEntryPointMetaData.Bin instead.
var AuctionEntryPointBin = AuctionEntryPointMetaData.Bin

// DeployAuctionEntryPoint deploys a new Kaia contract, binding an instance of AuctionEntryPoint to it.
func DeployAuctionEntryPoint(auth *bind.TransactOpts, backend bind.ContractBackend, initialOwner common.Address, _depositVault common.Address, _auctioneer common.Address) (common.Address, *types.Transaction, *AuctionEntryPoint, error) {
	parsed, err := AuctionEntryPointMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AuctionEntryPointBin), backend, initialOwner, _depositVault, _auctioneer)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AuctionEntryPoint{AuctionEntryPointCaller: AuctionEntryPointCaller{contract: contract}, AuctionEntryPointTransactor: AuctionEntryPointTransactor{contract: contract}, AuctionEntryPointFilterer: AuctionEntryPointFilterer{contract: contract}}, nil
}

// AuctionEntryPoint is an auto generated Go binding around a Kaia contract.
type AuctionEntryPoint struct {
	AuctionEntryPointCaller     // Read-only binding to the contract
	AuctionEntryPointTransactor // Write-only binding to the contract
	AuctionEntryPointFilterer   // Log filterer for contract events
}

// AuctionEntryPointCaller is an auto generated read-only Go binding around a Kaia contract.
type AuctionEntryPointCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionEntryPointTransactor is an auto generated write-only Go binding around a Kaia contract.
type AuctionEntryPointTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionEntryPointFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type AuctionEntryPointFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionEntryPointSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type AuctionEntryPointSession struct {
	Contract     *AuctionEntryPoint // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// AuctionEntryPointCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type AuctionEntryPointCallerSession struct {
	Contract *AuctionEntryPointCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// AuctionEntryPointTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type AuctionEntryPointTransactorSession struct {
	Contract     *AuctionEntryPointTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// AuctionEntryPointRaw is an auto generated low-level Go binding around a Kaia contract.
type AuctionEntryPointRaw struct {
	Contract *AuctionEntryPoint // Generic contract binding to access the raw methods on
}

// AuctionEntryPointCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type AuctionEntryPointCallerRaw struct {
	Contract *AuctionEntryPointCaller // Generic read-only contract binding to access the raw methods on
}

// AuctionEntryPointTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type AuctionEntryPointTransactorRaw struct {
	Contract *AuctionEntryPointTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAuctionEntryPoint creates a new instance of AuctionEntryPoint, bound to a specific deployed contract.
func NewAuctionEntryPoint(address common.Address, backend bind.ContractBackend) (*AuctionEntryPoint, error) {
	contract, err := bindAuctionEntryPoint(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AuctionEntryPoint{AuctionEntryPointCaller: AuctionEntryPointCaller{contract: contract}, AuctionEntryPointTransactor: AuctionEntryPointTransactor{contract: contract}, AuctionEntryPointFilterer: AuctionEntryPointFilterer{contract: contract}}, nil
}

// NewAuctionEntryPointCaller creates a new read-only instance of AuctionEntryPoint, bound to a specific deployed contract.
func NewAuctionEntryPointCaller(address common.Address, caller bind.ContractCaller) (*AuctionEntryPointCaller, error) {
	contract, err := bindAuctionEntryPoint(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AuctionEntryPointCaller{contract: contract}, nil
}

// NewAuctionEntryPointTransactor creates a new write-only instance of AuctionEntryPoint, bound to a specific deployed contract.
func NewAuctionEntryPointTransactor(address common.Address, transactor bind.ContractTransactor) (*AuctionEntryPointTransactor, error) {
	contract, err := bindAuctionEntryPoint(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AuctionEntryPointTransactor{contract: contract}, nil
}

// NewAuctionEntryPointFilterer creates a new log filterer instance of AuctionEntryPoint, bound to a specific deployed contract.
func NewAuctionEntryPointFilterer(address common.Address, filterer bind.ContractFilterer) (*AuctionEntryPointFilterer, error) {
	contract, err := bindAuctionEntryPoint(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AuctionEntryPointFilterer{contract: contract}, nil
}

// bindAuctionEntryPoint binds a generic wrapper to an already deployed contract.
func bindAuctionEntryPoint(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AuctionEntryPointMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AuctionEntryPoint *AuctionEntryPointRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AuctionEntryPoint.Contract.AuctionEntryPointCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AuctionEntryPoint *AuctionEntryPointRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.AuctionEntryPointTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AuctionEntryPoint *AuctionEntryPointRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.AuctionEntryPointTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AuctionEntryPoint *AuctionEntryPointCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AuctionEntryPoint.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AuctionEntryPoint *AuctionEntryPointTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AuctionEntryPoint *AuctionEntryPointTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.contract.Transact(opts, method, params...)
}

// AUCTIONNAME is a free data retrieval call binding the contract method 0xd2da236e.
//
// Solidity: function AUCTION_NAME() view returns(string)
func (_AuctionEntryPoint *AuctionEntryPointCaller) AUCTIONNAME(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "AUCTION_NAME")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// AUCTIONNAME is a free data retrieval call binding the contract method 0xd2da236e.
//
// Solidity: function AUCTION_NAME() view returns(string)
func (_AuctionEntryPoint *AuctionEntryPointSession) AUCTIONNAME() (string, error) {
	return _AuctionEntryPoint.Contract.AUCTIONNAME(&_AuctionEntryPoint.CallOpts)
}

// AUCTIONNAME is a free data retrieval call binding the contract method 0xd2da236e.
//
// Solidity: function AUCTION_NAME() view returns(string)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) AUCTIONNAME() (string, error) {
	return _AuctionEntryPoint.Contract.AUCTIONNAME(&_AuctionEntryPoint.CallOpts)
}

// AUCTIONVERSION is a free data retrieval call binding the contract method 0x9fc99426.
//
// Solidity: function AUCTION_VERSION() view returns(string)
func (_AuctionEntryPoint *AuctionEntryPointCaller) AUCTIONVERSION(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "AUCTION_VERSION")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// AUCTIONVERSION is a free data retrieval call binding the contract method 0x9fc99426.
//
// Solidity: function AUCTION_VERSION() view returns(string)
func (_AuctionEntryPoint *AuctionEntryPointSession) AUCTIONVERSION() (string, error) {
	return _AuctionEntryPoint.Contract.AUCTIONVERSION(&_AuctionEntryPoint.CallOpts)
}

// AUCTIONVERSION is a free data retrieval call binding the contract method 0x9fc99426.
//
// Solidity: function AUCTION_VERSION() view returns(string)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) AUCTIONVERSION() (string, error) {
	return _AuctionEntryPoint.Contract.AUCTIONVERSION(&_AuctionEntryPoint.CallOpts)
}

// GASBUFFERESTIMATE is a free data retrieval call binding the contract method 0xe4a973dd.
//
// Solidity: function GAS_BUFFER_ESTIMATE() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCaller) GASBUFFERESTIMATE(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "GAS_BUFFER_ESTIMATE")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GASBUFFERESTIMATE is a free data retrieval call binding the contract method 0xe4a973dd.
//
// Solidity: function GAS_BUFFER_ESTIMATE() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointSession) GASBUFFERESTIMATE() (*big.Int, error) {
	return _AuctionEntryPoint.Contract.GASBUFFERESTIMATE(&_AuctionEntryPoint.CallOpts)
}

// GASBUFFERESTIMATE is a free data retrieval call binding the contract method 0xe4a973dd.
//
// Solidity: function GAS_BUFFER_ESTIMATE() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) GASBUFFERESTIMATE() (*big.Int, error) {
	return _AuctionEntryPoint.Contract.GASBUFFERESTIMATE(&_AuctionEntryPoint.CallOpts)
}

// GASBUFFERUNMEASURED is a free data retrieval call binding the contract method 0xeb322e74.
//
// Solidity: function GAS_BUFFER_UNMEASURED() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCaller) GASBUFFERUNMEASURED(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "GAS_BUFFER_UNMEASURED")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GASBUFFERUNMEASURED is a free data retrieval call binding the contract method 0xeb322e74.
//
// Solidity: function GAS_BUFFER_UNMEASURED() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointSession) GASBUFFERUNMEASURED() (*big.Int, error) {
	return _AuctionEntryPoint.Contract.GASBUFFERUNMEASURED(&_AuctionEntryPoint.CallOpts)
}

// GASBUFFERUNMEASURED is a free data retrieval call binding the contract method 0xeb322e74.
//
// Solidity: function GAS_BUFFER_UNMEASURED() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) GASBUFFERUNMEASURED() (*big.Int, error) {
	return _AuctionEntryPoint.Contract.GASBUFFERUNMEASURED(&_AuctionEntryPoint.CallOpts)
}

// GASCONTRACTEXECUTION is a free data retrieval call binding the contract method 0x0a409e29.
//
// Solidity: function GAS_CONTRACT_EXECUTION() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCaller) GASCONTRACTEXECUTION(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "GAS_CONTRACT_EXECUTION")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GASCONTRACTEXECUTION is a free data retrieval call binding the contract method 0x0a409e29.
//
// Solidity: function GAS_CONTRACT_EXECUTION() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointSession) GASCONTRACTEXECUTION() (*big.Int, error) {
	return _AuctionEntryPoint.Contract.GASCONTRACTEXECUTION(&_AuctionEntryPoint.CallOpts)
}

// GASCONTRACTEXECUTION is a free data retrieval call binding the contract method 0x0a409e29.
//
// Solidity: function GAS_CONTRACT_EXECUTION() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) GASCONTRACTEXECUTION() (*big.Int, error) {
	return _AuctionEntryPoint.Contract.GASCONTRACTEXECUTION(&_AuctionEntryPoint.CallOpts)
}

// GASPERBYTEEIP7623 is a free data retrieval call binding the contract method 0xb2f5f4ca.
//
// Solidity: function GAS_PER_BYTE_EIP_7623() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCaller) GASPERBYTEEIP7623(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "GAS_PER_BYTE_EIP_7623")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GASPERBYTEEIP7623 is a free data retrieval call binding the contract method 0xb2f5f4ca.
//
// Solidity: function GAS_PER_BYTE_EIP_7623() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointSession) GASPERBYTEEIP7623() (*big.Int, error) {
	return _AuctionEntryPoint.Contract.GASPERBYTEEIP7623(&_AuctionEntryPoint.CallOpts)
}

// GASPERBYTEEIP7623 is a free data retrieval call binding the contract method 0xb2f5f4ca.
//
// Solidity: function GAS_PER_BYTE_EIP_7623() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) GASPERBYTEEIP7623() (*big.Int, error) {
	return _AuctionEntryPoint.Contract.GASPERBYTEEIP7623(&_AuctionEntryPoint.CallOpts)
}

// GASPERBYTEINTRINSIC is a free data retrieval call binding the contract method 0xaa65b344.
//
// Solidity: function GAS_PER_BYTE_INTRINSIC() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCaller) GASPERBYTEINTRINSIC(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "GAS_PER_BYTE_INTRINSIC")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GASPERBYTEINTRINSIC is a free data retrieval call binding the contract method 0xaa65b344.
//
// Solidity: function GAS_PER_BYTE_INTRINSIC() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointSession) GASPERBYTEINTRINSIC() (*big.Int, error) {
	return _AuctionEntryPoint.Contract.GASPERBYTEINTRINSIC(&_AuctionEntryPoint.CallOpts)
}

// GASPERBYTEINTRINSIC is a free data retrieval call binding the contract method 0xaa65b344.
//
// Solidity: function GAS_PER_BYTE_INTRINSIC() view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) GASPERBYTEINTRINSIC() (*big.Int, error) {
	return _AuctionEntryPoint.Contract.GASPERBYTEINTRINSIC(&_AuctionEntryPoint.CallOpts)
}

// Auctioneer is a free data retrieval call binding the contract method 0x5ec2c7bf.
//
// Solidity: function auctioneer() view returns(address)
func (_AuctionEntryPoint *AuctionEntryPointCaller) Auctioneer(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "auctioneer")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Auctioneer is a free data retrieval call binding the contract method 0x5ec2c7bf.
//
// Solidity: function auctioneer() view returns(address)
func (_AuctionEntryPoint *AuctionEntryPointSession) Auctioneer() (common.Address, error) {
	return _AuctionEntryPoint.Contract.Auctioneer(&_AuctionEntryPoint.CallOpts)
}

// Auctioneer is a free data retrieval call binding the contract method 0x5ec2c7bf.
//
// Solidity: function auctioneer() view returns(address)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) Auctioneer() (common.Address, error) {
	return _AuctionEntryPoint.Contract.Auctioneer(&_AuctionEntryPoint.CallOpts)
}

// DepositVault is a free data retrieval call binding the contract method 0xd7cd3949.
//
// Solidity: function depositVault() view returns(address)
func (_AuctionEntryPoint *AuctionEntryPointCaller) DepositVault(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "depositVault")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// DepositVault is a free data retrieval call binding the contract method 0xd7cd3949.
//
// Solidity: function depositVault() view returns(address)
func (_AuctionEntryPoint *AuctionEntryPointSession) DepositVault() (common.Address, error) {
	return _AuctionEntryPoint.Contract.DepositVault(&_AuctionEntryPoint.CallOpts)
}

// DepositVault is a free data retrieval call binding the contract method 0xd7cd3949.
//
// Solidity: function depositVault() view returns(address)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) DepositVault() (common.Address, error) {
	return _AuctionEntryPoint.Contract.DepositVault(&_AuctionEntryPoint.CallOpts)
}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_AuctionEntryPoint *AuctionEntryPointCaller) Eip712Domain(opts *bind.CallOpts) (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "eip712Domain")

	outstruct := new(struct {
		Fields            [1]byte
		Name              string
		Version           string
		ChainId           *big.Int
		VerifyingContract common.Address
		Salt              [32]byte
		Extensions        []*big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Fields = *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)
	outstruct.Name = *abi.ConvertType(out[1], new(string)).(*string)
	outstruct.Version = *abi.ConvertType(out[2], new(string)).(*string)
	outstruct.ChainId = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.VerifyingContract = *abi.ConvertType(out[4], new(common.Address)).(*common.Address)
	outstruct.Salt = *abi.ConvertType(out[5], new([32]byte)).(*[32]byte)
	outstruct.Extensions = *abi.ConvertType(out[6], new([]*big.Int)).(*[]*big.Int)

	return *outstruct, err

}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_AuctionEntryPoint *AuctionEntryPointSession) Eip712Domain() (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	return _AuctionEntryPoint.Contract.Eip712Domain(&_AuctionEntryPoint.CallOpts)
}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) Eip712Domain() (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	return _AuctionEntryPoint.Contract.Eip712Domain(&_AuctionEntryPoint.CallOpts)
}

// GetAuctionTxHash is a free data retrieval call binding the contract method 0xa8aa9450.
//
// Solidity: function getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) pure returns(bytes32)
func (_AuctionEntryPoint *AuctionEntryPointCaller) GetAuctionTxHash(opts *bind.CallOpts, auctionTx IAuctionEntryPointAuctionTx) ([32]byte, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "getAuctionTxHash", auctionTx)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetAuctionTxHash is a free data retrieval call binding the contract method 0xa8aa9450.
//
// Solidity: function getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) pure returns(bytes32)
func (_AuctionEntryPoint *AuctionEntryPointSession) GetAuctionTxHash(auctionTx IAuctionEntryPointAuctionTx) ([32]byte, error) {
	return _AuctionEntryPoint.Contract.GetAuctionTxHash(&_AuctionEntryPoint.CallOpts, auctionTx)
}

// GetAuctionTxHash is a free data retrieval call binding the contract method 0xa8aa9450.
//
// Solidity: function getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) pure returns(bytes32)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) GetAuctionTxHash(auctionTx IAuctionEntryPointAuctionTx) ([32]byte, error) {
	return _AuctionEntryPoint.Contract.GetAuctionTxHash(&_AuctionEntryPoint.CallOpts, auctionTx)
}

// GetNonceAndBids is a free data retrieval call binding the contract method 0x287ca78e.
//
// Solidity: function getNonceAndBids(address[] searchers) view returns(uint256[] nonces_, uint256[] bids_)
func (_AuctionEntryPoint *AuctionEntryPointCaller) GetNonceAndBids(opts *bind.CallOpts, searchers []common.Address) (struct {
	Nonces []*big.Int
	Bids   []*big.Int
}, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "getNonceAndBids", searchers)

	outstruct := new(struct {
		Nonces []*big.Int
		Bids   []*big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Nonces = *abi.ConvertType(out[0], new([]*big.Int)).(*[]*big.Int)
	outstruct.Bids = *abi.ConvertType(out[1], new([]*big.Int)).(*[]*big.Int)

	return *outstruct, err

}

// GetNonceAndBids is a free data retrieval call binding the contract method 0x287ca78e.
//
// Solidity: function getNonceAndBids(address[] searchers) view returns(uint256[] nonces_, uint256[] bids_)
func (_AuctionEntryPoint *AuctionEntryPointSession) GetNonceAndBids(searchers []common.Address) (struct {
	Nonces []*big.Int
	Bids   []*big.Int
}, error) {
	return _AuctionEntryPoint.Contract.GetNonceAndBids(&_AuctionEntryPoint.CallOpts, searchers)
}

// GetNonceAndBids is a free data retrieval call binding the contract method 0x287ca78e.
//
// Solidity: function getNonceAndBids(address[] searchers) view returns(uint256[] nonces_, uint256[] bids_)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) GetNonceAndBids(searchers []common.Address) (struct {
	Nonces []*big.Int
	Bids   []*big.Int
}, error) {
	return _AuctionEntryPoint.Contract.GetNonceAndBids(&_AuctionEntryPoint.CallOpts, searchers)
}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCaller) Nonces(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "nonces", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointSession) Nonces(owner common.Address) (*big.Int, error) {
	return _AuctionEntryPoint.Contract.Nonces(&_AuctionEntryPoint.CallOpts, owner)
}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) Nonces(owner common.Address) (*big.Int, error) {
	return _AuctionEntryPoint.Contract.Nonces(&_AuctionEntryPoint.CallOpts, owner)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AuctionEntryPoint *AuctionEntryPointCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AuctionEntryPoint.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AuctionEntryPoint *AuctionEntryPointSession) Owner() (common.Address, error) {
	return _AuctionEntryPoint.Contract.Owner(&_AuctionEntryPoint.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AuctionEntryPoint *AuctionEntryPointCallerSession) Owner() (common.Address, error) {
	return _AuctionEntryPoint.Contract.Owner(&_AuctionEntryPoint.CallOpts)
}

// Call is a paid mutator transaction binding the contract method 0xca157554.
//
// Solidity: function call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) returns()
func (_AuctionEntryPoint *AuctionEntryPointTransactor) Call(opts *bind.TransactOpts, auctionTx IAuctionEntryPointAuctionTx) (*types.Transaction, error) {
	return _AuctionEntryPoint.contract.Transact(opts, "call", auctionTx)
}

// Call is a paid mutator transaction binding the contract method 0xca157554.
//
// Solidity: function call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) returns()
func (_AuctionEntryPoint *AuctionEntryPointSession) Call(auctionTx IAuctionEntryPointAuctionTx) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.Call(&_AuctionEntryPoint.TransactOpts, auctionTx)
}

// Call is a paid mutator transaction binding the contract method 0xca157554.
//
// Solidity: function call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) returns()
func (_AuctionEntryPoint *AuctionEntryPointTransactorSession) Call(auctionTx IAuctionEntryPointAuctionTx) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.Call(&_AuctionEntryPoint.TransactOpts, auctionTx)
}

// ChangeAuctioneer is a paid mutator transaction binding the contract method 0x774f45ec.
//
// Solidity: function changeAuctioneer(address _auctioneer) returns()
func (_AuctionEntryPoint *AuctionEntryPointTransactor) ChangeAuctioneer(opts *bind.TransactOpts, _auctioneer common.Address) (*types.Transaction, error) {
	return _AuctionEntryPoint.contract.Transact(opts, "changeAuctioneer", _auctioneer)
}

// ChangeAuctioneer is a paid mutator transaction binding the contract method 0x774f45ec.
//
// Solidity: function changeAuctioneer(address _auctioneer) returns()
func (_AuctionEntryPoint *AuctionEntryPointSession) ChangeAuctioneer(_auctioneer common.Address) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.ChangeAuctioneer(&_AuctionEntryPoint.TransactOpts, _auctioneer)
}

// ChangeAuctioneer is a paid mutator transaction binding the contract method 0x774f45ec.
//
// Solidity: function changeAuctioneer(address _auctioneer) returns()
func (_AuctionEntryPoint *AuctionEntryPointTransactorSession) ChangeAuctioneer(_auctioneer common.Address) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.ChangeAuctioneer(&_AuctionEntryPoint.TransactOpts, _auctioneer)
}

// ChangeDepositVault is a paid mutator transaction binding the contract method 0x9d59928b.
//
// Solidity: function changeDepositVault(address _depositVault) returns()
func (_AuctionEntryPoint *AuctionEntryPointTransactor) ChangeDepositVault(opts *bind.TransactOpts, _depositVault common.Address) (*types.Transaction, error) {
	return _AuctionEntryPoint.contract.Transact(opts, "changeDepositVault", _depositVault)
}

// ChangeDepositVault is a paid mutator transaction binding the contract method 0x9d59928b.
//
// Solidity: function changeDepositVault(address _depositVault) returns()
func (_AuctionEntryPoint *AuctionEntryPointSession) ChangeDepositVault(_depositVault common.Address) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.ChangeDepositVault(&_AuctionEntryPoint.TransactOpts, _depositVault)
}

// ChangeDepositVault is a paid mutator transaction binding the contract method 0x9d59928b.
//
// Solidity: function changeDepositVault(address _depositVault) returns()
func (_AuctionEntryPoint *AuctionEntryPointTransactorSession) ChangeDepositVault(_depositVault common.Address) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.ChangeDepositVault(&_AuctionEntryPoint.TransactOpts, _depositVault)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_AuctionEntryPoint *AuctionEntryPointTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionEntryPoint.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_AuctionEntryPoint *AuctionEntryPointSession) RenounceOwnership() (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.RenounceOwnership(&_AuctionEntryPoint.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_AuctionEntryPoint *AuctionEntryPointTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.RenounceOwnership(&_AuctionEntryPoint.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AuctionEntryPoint *AuctionEntryPointTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _AuctionEntryPoint.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AuctionEntryPoint *AuctionEntryPointSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.TransferOwnership(&_AuctionEntryPoint.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AuctionEntryPoint *AuctionEntryPointTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _AuctionEntryPoint.Contract.TransferOwnership(&_AuctionEntryPoint.TransactOpts, newOwner)
}

// AuctionEntryPointCallIterator is returned from FilterCall and is used to iterate over the raw logs and unpacked data for Call events raised by the AuctionEntryPoint contract.
type AuctionEntryPointCallIterator struct {
	Event *AuctionEntryPointCall // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionEntryPointCallIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionEntryPointCall)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionEntryPointCall)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionEntryPointCallIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionEntryPointCallIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionEntryPointCall represents a Call event raised by the AuctionEntryPoint contract.
type AuctionEntryPointCall struct {
	Sender common.Address
	Nonce  *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterCall is a free log retrieval operation binding the contract event 0x9e4369a013b5e45a103a959d8eb70f15c55dc496e8335f245690393dfb4b71d4.
//
// Solidity: event Call(address sender, uint256 nonce)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) FilterCall(opts *bind.FilterOpts) (*AuctionEntryPointCallIterator, error) {

	logs, sub, err := _AuctionEntryPoint.contract.FilterLogs(opts, "Call")
	if err != nil {
		return nil, err
	}
	return &AuctionEntryPointCallIterator{contract: _AuctionEntryPoint.contract, event: "Call", logs: logs, sub: sub}, nil
}

// WatchCall is a free log subscription operation binding the contract event 0x9e4369a013b5e45a103a959d8eb70f15c55dc496e8335f245690393dfb4b71d4.
//
// Solidity: event Call(address sender, uint256 nonce)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) WatchCall(opts *bind.WatchOpts, sink chan<- *AuctionEntryPointCall) (event.Subscription, error) {

	logs, sub, err := _AuctionEntryPoint.contract.WatchLogs(opts, "Call")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionEntryPointCall)
				if err := _AuctionEntryPoint.contract.UnpackLog(event, "Call", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCall is a log parse operation binding the contract event 0x9e4369a013b5e45a103a959d8eb70f15c55dc496e8335f245690393dfb4b71d4.
//
// Solidity: event Call(address sender, uint256 nonce)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) ParseCall(log types.Log) (*AuctionEntryPointCall, error) {
	event := new(AuctionEntryPointCall)
	if err := _AuctionEntryPoint.contract.UnpackLog(event, "Call", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionEntryPointCallFailedIterator is returned from FilterCallFailed and is used to iterate over the raw logs and unpacked data for CallFailed events raised by the AuctionEntryPoint contract.
type AuctionEntryPointCallFailedIterator struct {
	Event *AuctionEntryPointCallFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionEntryPointCallFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionEntryPointCallFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionEntryPointCallFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionEntryPointCallFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionEntryPointCallFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionEntryPointCallFailed represents a CallFailed event raised by the AuctionEntryPoint contract.
type AuctionEntryPointCallFailed struct {
	Sender common.Address
	Nonce  *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterCallFailed is a free log retrieval operation binding the contract event 0xb9eaeae386d339f8115782f297a9e5f0e13fb587cd6b0d502f113cb8dd4d6cb0.
//
// Solidity: event CallFailed(address sender, uint256 nonce)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) FilterCallFailed(opts *bind.FilterOpts) (*AuctionEntryPointCallFailedIterator, error) {

	logs, sub, err := _AuctionEntryPoint.contract.FilterLogs(opts, "CallFailed")
	if err != nil {
		return nil, err
	}
	return &AuctionEntryPointCallFailedIterator{contract: _AuctionEntryPoint.contract, event: "CallFailed", logs: logs, sub: sub}, nil
}

// WatchCallFailed is a free log subscription operation binding the contract event 0xb9eaeae386d339f8115782f297a9e5f0e13fb587cd6b0d502f113cb8dd4d6cb0.
//
// Solidity: event CallFailed(address sender, uint256 nonce)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) WatchCallFailed(opts *bind.WatchOpts, sink chan<- *AuctionEntryPointCallFailed) (event.Subscription, error) {

	logs, sub, err := _AuctionEntryPoint.contract.WatchLogs(opts, "CallFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionEntryPointCallFailed)
				if err := _AuctionEntryPoint.contract.UnpackLog(event, "CallFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCallFailed is a log parse operation binding the contract event 0xb9eaeae386d339f8115782f297a9e5f0e13fb587cd6b0d502f113cb8dd4d6cb0.
//
// Solidity: event CallFailed(address sender, uint256 nonce)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) ParseCallFailed(log types.Log) (*AuctionEntryPointCallFailed, error) {
	event := new(AuctionEntryPointCallFailed)
	if err := _AuctionEntryPoint.contract.UnpackLog(event, "CallFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionEntryPointChangeAuctioneerIterator is returned from FilterChangeAuctioneer and is used to iterate over the raw logs and unpacked data for ChangeAuctioneer events raised by the AuctionEntryPoint contract.
type AuctionEntryPointChangeAuctioneerIterator struct {
	Event *AuctionEntryPointChangeAuctioneer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionEntryPointChangeAuctioneerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionEntryPointChangeAuctioneer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionEntryPointChangeAuctioneer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionEntryPointChangeAuctioneerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionEntryPointChangeAuctioneerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionEntryPointChangeAuctioneer represents a ChangeAuctioneer event raised by the AuctionEntryPoint contract.
type AuctionEntryPointChangeAuctioneer struct {
	OldAuctioneer common.Address
	NewAuctioneer common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterChangeAuctioneer is a free log retrieval operation binding the contract event 0xc8a0473779a405800019e7658500d0930d92f78e776b553d286baeefb9c9a0f1.
//
// Solidity: event ChangeAuctioneer(address oldAuctioneer, address newAuctioneer)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) FilterChangeAuctioneer(opts *bind.FilterOpts) (*AuctionEntryPointChangeAuctioneerIterator, error) {

	logs, sub, err := _AuctionEntryPoint.contract.FilterLogs(opts, "ChangeAuctioneer")
	if err != nil {
		return nil, err
	}
	return &AuctionEntryPointChangeAuctioneerIterator{contract: _AuctionEntryPoint.contract, event: "ChangeAuctioneer", logs: logs, sub: sub}, nil
}

// WatchChangeAuctioneer is a free log subscription operation binding the contract event 0xc8a0473779a405800019e7658500d0930d92f78e776b553d286baeefb9c9a0f1.
//
// Solidity: event ChangeAuctioneer(address oldAuctioneer, address newAuctioneer)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) WatchChangeAuctioneer(opts *bind.WatchOpts, sink chan<- *AuctionEntryPointChangeAuctioneer) (event.Subscription, error) {

	logs, sub, err := _AuctionEntryPoint.contract.WatchLogs(opts, "ChangeAuctioneer")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionEntryPointChangeAuctioneer)
				if err := _AuctionEntryPoint.contract.UnpackLog(event, "ChangeAuctioneer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeAuctioneer is a log parse operation binding the contract event 0xc8a0473779a405800019e7658500d0930d92f78e776b553d286baeefb9c9a0f1.
//
// Solidity: event ChangeAuctioneer(address oldAuctioneer, address newAuctioneer)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) ParseChangeAuctioneer(log types.Log) (*AuctionEntryPointChangeAuctioneer, error) {
	event := new(AuctionEntryPointChangeAuctioneer)
	if err := _AuctionEntryPoint.contract.UnpackLog(event, "ChangeAuctioneer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionEntryPointChangeDepositVaultIterator is returned from FilterChangeDepositVault and is used to iterate over the raw logs and unpacked data for ChangeDepositVault events raised by the AuctionEntryPoint contract.
type AuctionEntryPointChangeDepositVaultIterator struct {
	Event *AuctionEntryPointChangeDepositVault // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionEntryPointChangeDepositVaultIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionEntryPointChangeDepositVault)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionEntryPointChangeDepositVault)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionEntryPointChangeDepositVaultIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionEntryPointChangeDepositVaultIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionEntryPointChangeDepositVault represents a ChangeDepositVault event raised by the AuctionEntryPoint contract.
type AuctionEntryPointChangeDepositVault struct {
	OldDepositVault common.Address
	NewDepositVault common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterChangeDepositVault is a free log retrieval operation binding the contract event 0x32718750012b831b1e21ea05c1ed833c9365fc94e7316126303f6d09f41beb5d.
//
// Solidity: event ChangeDepositVault(address oldDepositVault, address newDepositVault)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) FilterChangeDepositVault(opts *bind.FilterOpts) (*AuctionEntryPointChangeDepositVaultIterator, error) {

	logs, sub, err := _AuctionEntryPoint.contract.FilterLogs(opts, "ChangeDepositVault")
	if err != nil {
		return nil, err
	}
	return &AuctionEntryPointChangeDepositVaultIterator{contract: _AuctionEntryPoint.contract, event: "ChangeDepositVault", logs: logs, sub: sub}, nil
}

// WatchChangeDepositVault is a free log subscription operation binding the contract event 0x32718750012b831b1e21ea05c1ed833c9365fc94e7316126303f6d09f41beb5d.
//
// Solidity: event ChangeDepositVault(address oldDepositVault, address newDepositVault)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) WatchChangeDepositVault(opts *bind.WatchOpts, sink chan<- *AuctionEntryPointChangeDepositVault) (event.Subscription, error) {

	logs, sub, err := _AuctionEntryPoint.contract.WatchLogs(opts, "ChangeDepositVault")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionEntryPointChangeDepositVault)
				if err := _AuctionEntryPoint.contract.UnpackLog(event, "ChangeDepositVault", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeDepositVault is a log parse operation binding the contract event 0x32718750012b831b1e21ea05c1ed833c9365fc94e7316126303f6d09f41beb5d.
//
// Solidity: event ChangeDepositVault(address oldDepositVault, address newDepositVault)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) ParseChangeDepositVault(log types.Log) (*AuctionEntryPointChangeDepositVault, error) {
	event := new(AuctionEntryPointChangeDepositVault)
	if err := _AuctionEntryPoint.contract.UnpackLog(event, "ChangeDepositVault", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionEntryPointEIP712DomainChangedIterator is returned from FilterEIP712DomainChanged and is used to iterate over the raw logs and unpacked data for EIP712DomainChanged events raised by the AuctionEntryPoint contract.
type AuctionEntryPointEIP712DomainChangedIterator struct {
	Event *AuctionEntryPointEIP712DomainChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionEntryPointEIP712DomainChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionEntryPointEIP712DomainChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionEntryPointEIP712DomainChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionEntryPointEIP712DomainChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionEntryPointEIP712DomainChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionEntryPointEIP712DomainChanged represents a EIP712DomainChanged event raised by the AuctionEntryPoint contract.
type AuctionEntryPointEIP712DomainChanged struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterEIP712DomainChanged is a free log retrieval operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_AuctionEntryPoint *AuctionEntryPointFilterer) FilterEIP712DomainChanged(opts *bind.FilterOpts) (*AuctionEntryPointEIP712DomainChangedIterator, error) {

	logs, sub, err := _AuctionEntryPoint.contract.FilterLogs(opts, "EIP712DomainChanged")
	if err != nil {
		return nil, err
	}
	return &AuctionEntryPointEIP712DomainChangedIterator{contract: _AuctionEntryPoint.contract, event: "EIP712DomainChanged", logs: logs, sub: sub}, nil
}

// WatchEIP712DomainChanged is a free log subscription operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_AuctionEntryPoint *AuctionEntryPointFilterer) WatchEIP712DomainChanged(opts *bind.WatchOpts, sink chan<- *AuctionEntryPointEIP712DomainChanged) (event.Subscription, error) {

	logs, sub, err := _AuctionEntryPoint.contract.WatchLogs(opts, "EIP712DomainChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionEntryPointEIP712DomainChanged)
				if err := _AuctionEntryPoint.contract.UnpackLog(event, "EIP712DomainChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEIP712DomainChanged is a log parse operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_AuctionEntryPoint *AuctionEntryPointFilterer) ParseEIP712DomainChanged(log types.Log) (*AuctionEntryPointEIP712DomainChanged, error) {
	event := new(AuctionEntryPointEIP712DomainChanged)
	if err := _AuctionEntryPoint.contract.UnpackLog(event, "EIP712DomainChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionEntryPointOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the AuctionEntryPoint contract.
type AuctionEntryPointOwnershipTransferredIterator struct {
	Event *AuctionEntryPointOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionEntryPointOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionEntryPointOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionEntryPointOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionEntryPointOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionEntryPointOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionEntryPointOwnershipTransferred represents a OwnershipTransferred event raised by the AuctionEntryPoint contract.
type AuctionEntryPointOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*AuctionEntryPointOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _AuctionEntryPoint.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &AuctionEntryPointOwnershipTransferredIterator{contract: _AuctionEntryPoint.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *AuctionEntryPointOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _AuctionEntryPoint.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionEntryPointOwnershipTransferred)
				if err := _AuctionEntryPoint.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) ParseOwnershipTransferred(log types.Log) (*AuctionEntryPointOwnershipTransferred, error) {
	event := new(AuctionEntryPointOwnershipTransferred)
	if err := _AuctionEntryPoint.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionEntryPointUseNonceIterator is returned from FilterUseNonce and is used to iterate over the raw logs and unpacked data for UseNonce events raised by the AuctionEntryPoint contract.
type AuctionEntryPointUseNonceIterator struct {
	Event *AuctionEntryPointUseNonce // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AuctionEntryPointUseNonceIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AuctionEntryPointUseNonce)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AuctionEntryPointUseNonce)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AuctionEntryPointUseNonceIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AuctionEntryPointUseNonceIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AuctionEntryPointUseNonce represents a UseNonce event raised by the AuctionEntryPoint contract.
type AuctionEntryPointUseNonce struct {
	Searcher common.Address
	Nonce    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterUseNonce is a free log retrieval operation binding the contract event 0x7243aab3c75cebfd96dc41ece7762eb023fc8c81e9ba2ce1d487876419b918b5.
//
// Solidity: event UseNonce(address searcher, uint256 nonce)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) FilterUseNonce(opts *bind.FilterOpts) (*AuctionEntryPointUseNonceIterator, error) {

	logs, sub, err := _AuctionEntryPoint.contract.FilterLogs(opts, "UseNonce")
	if err != nil {
		return nil, err
	}
	return &AuctionEntryPointUseNonceIterator{contract: _AuctionEntryPoint.contract, event: "UseNonce", logs: logs, sub: sub}, nil
}

// WatchUseNonce is a free log subscription operation binding the contract event 0x7243aab3c75cebfd96dc41ece7762eb023fc8c81e9ba2ce1d487876419b918b5.
//
// Solidity: event UseNonce(address searcher, uint256 nonce)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) WatchUseNonce(opts *bind.WatchOpts, sink chan<- *AuctionEntryPointUseNonce) (event.Subscription, error) {

	logs, sub, err := _AuctionEntryPoint.contract.WatchLogs(opts, "UseNonce")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AuctionEntryPointUseNonce)
				if err := _AuctionEntryPoint.contract.UnpackLog(event, "UseNonce", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUseNonce is a log parse operation binding the contract event 0x7243aab3c75cebfd96dc41ece7762eb023fc8c81e9ba2ce1d487876419b918b5.
//
// Solidity: event UseNonce(address searcher, uint256 nonce)
func (_AuctionEntryPoint *AuctionEntryPointFilterer) ParseUseNonce(log types.Log) (*AuctionEntryPointUseNonce, error) {
	event := new(AuctionEntryPointUseNonce)
	if err := _AuctionEntryPoint.contract.UnpackLog(event, "UseNonce", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AuctionErrorMetaData contains all meta data concerning the AuctionError contract.
var AuctionErrorMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"EmptyDepositVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinDepositNotOver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAuctionDepositVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyEntryPoint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyProposer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyStakingAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawReservationExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalNotAllowedYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroDepositAmount\",\"type\":\"error\"}]",
	Bin: "0x6080604052348015600e575f80fd5b50603e80601a5f395ff3fe60806040525f80fdfea26469706673582212207528d0d43ae476e30651a0be079c16a1af03532761e8a907f228cacf87ea7d1264736f6c63430008190033",
}

// AuctionErrorABI is the input ABI used to generate the binding from.
// Deprecated: Use AuctionErrorMetaData.ABI instead.
var AuctionErrorABI = AuctionErrorMetaData.ABI

// AuctionErrorBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const AuctionErrorBinRuntime = `60806040525f80fdfea26469706673582212207528d0d43ae476e30651a0be079c16a1af03532761e8a907f228cacf87ea7d1264736f6c63430008190033`

// AuctionErrorBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AuctionErrorMetaData.Bin instead.
var AuctionErrorBin = AuctionErrorMetaData.Bin

// DeployAuctionError deploys a new Kaia contract, binding an instance of AuctionError to it.
func DeployAuctionError(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *AuctionError, error) {
	parsed, err := AuctionErrorMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AuctionErrorBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AuctionError{AuctionErrorCaller: AuctionErrorCaller{contract: contract}, AuctionErrorTransactor: AuctionErrorTransactor{contract: contract}, AuctionErrorFilterer: AuctionErrorFilterer{contract: contract}}, nil
}

// AuctionError is an auto generated Go binding around a Kaia contract.
type AuctionError struct {
	AuctionErrorCaller     // Read-only binding to the contract
	AuctionErrorTransactor // Write-only binding to the contract
	AuctionErrorFilterer   // Log filterer for contract events
}

// AuctionErrorCaller is an auto generated read-only Go binding around a Kaia contract.
type AuctionErrorCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionErrorTransactor is an auto generated write-only Go binding around a Kaia contract.
type AuctionErrorTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionErrorFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type AuctionErrorFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AuctionErrorSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type AuctionErrorSession struct {
	Contract     *AuctionError     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AuctionErrorCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type AuctionErrorCallerSession struct {
	Contract *AuctionErrorCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// AuctionErrorTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type AuctionErrorTransactorSession struct {
	Contract     *AuctionErrorTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// AuctionErrorRaw is an auto generated low-level Go binding around a Kaia contract.
type AuctionErrorRaw struct {
	Contract *AuctionError // Generic contract binding to access the raw methods on
}

// AuctionErrorCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type AuctionErrorCallerRaw struct {
	Contract *AuctionErrorCaller // Generic read-only contract binding to access the raw methods on
}

// AuctionErrorTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type AuctionErrorTransactorRaw struct {
	Contract *AuctionErrorTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAuctionError creates a new instance of AuctionError, bound to a specific deployed contract.
func NewAuctionError(address common.Address, backend bind.ContractBackend) (*AuctionError, error) {
	contract, err := bindAuctionError(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AuctionError{AuctionErrorCaller: AuctionErrorCaller{contract: contract}, AuctionErrorTransactor: AuctionErrorTransactor{contract: contract}, AuctionErrorFilterer: AuctionErrorFilterer{contract: contract}}, nil
}

// NewAuctionErrorCaller creates a new read-only instance of AuctionError, bound to a specific deployed contract.
func NewAuctionErrorCaller(address common.Address, caller bind.ContractCaller) (*AuctionErrorCaller, error) {
	contract, err := bindAuctionError(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AuctionErrorCaller{contract: contract}, nil
}

// NewAuctionErrorTransactor creates a new write-only instance of AuctionError, bound to a specific deployed contract.
func NewAuctionErrorTransactor(address common.Address, transactor bind.ContractTransactor) (*AuctionErrorTransactor, error) {
	contract, err := bindAuctionError(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AuctionErrorTransactor{contract: contract}, nil
}

// NewAuctionErrorFilterer creates a new log filterer instance of AuctionError, bound to a specific deployed contract.
func NewAuctionErrorFilterer(address common.Address, filterer bind.ContractFilterer) (*AuctionErrorFilterer, error) {
	contract, err := bindAuctionError(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AuctionErrorFilterer{contract: contract}, nil
}

// bindAuctionError binds a generic wrapper to an already deployed contract.
func bindAuctionError(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AuctionErrorMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AuctionError *AuctionErrorRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AuctionError.Contract.AuctionErrorCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AuctionError *AuctionErrorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionError.Contract.AuctionErrorTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AuctionError *AuctionErrorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AuctionError.Contract.AuctionErrorTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AuctionError *AuctionErrorCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AuctionError.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AuctionError *AuctionErrorTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AuctionError.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AuctionError *AuctionErrorTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AuctionError.Contract.contract.Transact(opts, method, params...)
}

// ContextMetaData contains all meta data concerning the Context contract.
var ContextMetaData = &bind.MetaData{
	ABI: "[]",
}

// ContextABI is the input ABI used to generate the binding from.
// Deprecated: Use ContextMetaData.ABI instead.
var ContextABI = ContextMetaData.ABI

// ContextBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ContextBinRuntime = ``

// Context is an auto generated Go binding around a Kaia contract.
type Context struct {
	ContextCaller     // Read-only binding to the contract
	ContextTransactor // Write-only binding to the contract
	ContextFilterer   // Log filterer for contract events
}

// ContextCaller is an auto generated read-only Go binding around a Kaia contract.
type ContextCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextTransactor is an auto generated write-only Go binding around a Kaia contract.
type ContextTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type ContextFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type ContextSession struct {
	Contract     *Context          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ContextCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type ContextCallerSession struct {
	Contract *ContextCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// ContextTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type ContextTransactorSession struct {
	Contract     *ContextTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ContextRaw is an auto generated low-level Go binding around a Kaia contract.
type ContextRaw struct {
	Contract *Context // Generic contract binding to access the raw methods on
}

// ContextCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type ContextCallerRaw struct {
	Contract *ContextCaller // Generic read-only contract binding to access the raw methods on
}

// ContextTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type ContextTransactorRaw struct {
	Contract *ContextTransactor // Generic write-only contract binding to access the raw methods on
}

// NewContext creates a new instance of Context, bound to a specific deployed contract.
func NewContext(address common.Address, backend bind.ContractBackend) (*Context, error) {
	contract, err := bindContext(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Context{ContextCaller: ContextCaller{contract: contract}, ContextTransactor: ContextTransactor{contract: contract}, ContextFilterer: ContextFilterer{contract: contract}}, nil
}

// NewContextCaller creates a new read-only instance of Context, bound to a specific deployed contract.
func NewContextCaller(address common.Address, caller bind.ContractCaller) (*ContextCaller, error) {
	contract, err := bindContext(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ContextCaller{contract: contract}, nil
}

// NewContextTransactor creates a new write-only instance of Context, bound to a specific deployed contract.
func NewContextTransactor(address common.Address, transactor bind.ContractTransactor) (*ContextTransactor, error) {
	contract, err := bindContext(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ContextTransactor{contract: contract}, nil
}

// NewContextFilterer creates a new log filterer instance of Context, bound to a specific deployed contract.
func NewContextFilterer(address common.Address, filterer bind.ContractFilterer) (*ContextFilterer, error) {
	contract, err := bindContext(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ContextFilterer{contract: contract}, nil
}

// bindContext binds a generic wrapper to an already deployed contract.
func bindContext(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ContextMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.ContextCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.contract.Transact(opts, method, params...)
}

// ECDSAMetaData contains all meta data concerning the ECDSA contract.
var ECDSAMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"}]",
	Bin: "0x60556032600b8282823980515f1a607314602657634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f80fdfea264697066735822122092ee4afc25ab77dae770f319dd10c304eeb3f50074c051f31b14d5af756c479d64736f6c63430008190033",
}

// ECDSAABI is the input ABI used to generate the binding from.
// Deprecated: Use ECDSAMetaData.ABI instead.
var ECDSAABI = ECDSAMetaData.ABI

// ECDSABinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ECDSABinRuntime = `730000000000000000000000000000000000000000301460806040525f80fdfea264697066735822122092ee4afc25ab77dae770f319dd10c304eeb3f50074c051f31b14d5af756c479d64736f6c63430008190033`

// ECDSABin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ECDSAMetaData.Bin instead.
var ECDSABin = ECDSAMetaData.Bin

// DeployECDSA deploys a new Kaia contract, binding an instance of ECDSA to it.
func DeployECDSA(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ECDSA, error) {
	parsed, err := ECDSAMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ECDSABin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ECDSA{ECDSACaller: ECDSACaller{contract: contract}, ECDSATransactor: ECDSATransactor{contract: contract}, ECDSAFilterer: ECDSAFilterer{contract: contract}}, nil
}

// ECDSA is an auto generated Go binding around a Kaia contract.
type ECDSA struct {
	ECDSACaller     // Read-only binding to the contract
	ECDSATransactor // Write-only binding to the contract
	ECDSAFilterer   // Log filterer for contract events
}

// ECDSACaller is an auto generated read-only Go binding around a Kaia contract.
type ECDSACaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ECDSATransactor is an auto generated write-only Go binding around a Kaia contract.
type ECDSATransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ECDSAFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type ECDSAFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ECDSASession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type ECDSASession struct {
	Contract     *ECDSA            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ECDSACallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type ECDSACallerSession struct {
	Contract *ECDSACaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ECDSATransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type ECDSATransactorSession struct {
	Contract     *ECDSATransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ECDSARaw is an auto generated low-level Go binding around a Kaia contract.
type ECDSARaw struct {
	Contract *ECDSA // Generic contract binding to access the raw methods on
}

// ECDSACallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type ECDSACallerRaw struct {
	Contract *ECDSACaller // Generic read-only contract binding to access the raw methods on
}

// ECDSATransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type ECDSATransactorRaw struct {
	Contract *ECDSATransactor // Generic write-only contract binding to access the raw methods on
}

// NewECDSA creates a new instance of ECDSA, bound to a specific deployed contract.
func NewECDSA(address common.Address, backend bind.ContractBackend) (*ECDSA, error) {
	contract, err := bindECDSA(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ECDSA{ECDSACaller: ECDSACaller{contract: contract}, ECDSATransactor: ECDSATransactor{contract: contract}, ECDSAFilterer: ECDSAFilterer{contract: contract}}, nil
}

// NewECDSACaller creates a new read-only instance of ECDSA, bound to a specific deployed contract.
func NewECDSACaller(address common.Address, caller bind.ContractCaller) (*ECDSACaller, error) {
	contract, err := bindECDSA(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ECDSACaller{contract: contract}, nil
}

// NewECDSATransactor creates a new write-only instance of ECDSA, bound to a specific deployed contract.
func NewECDSATransactor(address common.Address, transactor bind.ContractTransactor) (*ECDSATransactor, error) {
	contract, err := bindECDSA(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ECDSATransactor{contract: contract}, nil
}

// NewECDSAFilterer creates a new log filterer instance of ECDSA, bound to a specific deployed contract.
func NewECDSAFilterer(address common.Address, filterer bind.ContractFilterer) (*ECDSAFilterer, error) {
	contract, err := bindECDSA(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ECDSAFilterer{contract: contract}, nil
}

// bindECDSA binds a generic wrapper to an already deployed contract.
func bindECDSA(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ECDSAMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ECDSA *ECDSARaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ECDSA.Contract.ECDSACaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ECDSA *ECDSARaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ECDSA.Contract.ECDSATransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ECDSA *ECDSARaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ECDSA.Contract.ECDSATransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ECDSA *ECDSACallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ECDSA.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ECDSA *ECDSATransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ECDSA.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ECDSA *ECDSATransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ECDSA.Contract.contract.Transact(opts, method, params...)
}

// EIP712MetaData contains all meta data concerning the EIP712 contract.
var EIP712MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"84b0196e": "eip712Domain()",
	},
}

// EIP712ABI is the input ABI used to generate the binding from.
// Deprecated: Use EIP712MetaData.ABI instead.
var EIP712ABI = EIP712MetaData.ABI

// EIP712BinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const EIP712BinRuntime = ``

// Deprecated: Use EIP712MetaData.Sigs instead.
// EIP712FuncSigs maps the 4-byte function signature to its string representation.
var EIP712FuncSigs = EIP712MetaData.Sigs

// EIP712 is an auto generated Go binding around a Kaia contract.
type EIP712 struct {
	EIP712Caller     // Read-only binding to the contract
	EIP712Transactor // Write-only binding to the contract
	EIP712Filterer   // Log filterer for contract events
}

// EIP712Caller is an auto generated read-only Go binding around a Kaia contract.
type EIP712Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EIP712Transactor is an auto generated write-only Go binding around a Kaia contract.
type EIP712Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EIP712Filterer is an auto generated log filtering Go binding around a Kaia contract events.
type EIP712Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EIP712Session is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type EIP712Session struct {
	Contract     *EIP712           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// EIP712CallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type EIP712CallerSession struct {
	Contract *EIP712Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// EIP712TransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type EIP712TransactorSession struct {
	Contract     *EIP712Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// EIP712Raw is an auto generated low-level Go binding around a Kaia contract.
type EIP712Raw struct {
	Contract *EIP712 // Generic contract binding to access the raw methods on
}

// EIP712CallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type EIP712CallerRaw struct {
	Contract *EIP712Caller // Generic read-only contract binding to access the raw methods on
}

// EIP712TransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type EIP712TransactorRaw struct {
	Contract *EIP712Transactor // Generic write-only contract binding to access the raw methods on
}

// NewEIP712 creates a new instance of EIP712, bound to a specific deployed contract.
func NewEIP712(address common.Address, backend bind.ContractBackend) (*EIP712, error) {
	contract, err := bindEIP712(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &EIP712{EIP712Caller: EIP712Caller{contract: contract}, EIP712Transactor: EIP712Transactor{contract: contract}, EIP712Filterer: EIP712Filterer{contract: contract}}, nil
}

// NewEIP712Caller creates a new read-only instance of EIP712, bound to a specific deployed contract.
func NewEIP712Caller(address common.Address, caller bind.ContractCaller) (*EIP712Caller, error) {
	contract, err := bindEIP712(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &EIP712Caller{contract: contract}, nil
}

// NewEIP712Transactor creates a new write-only instance of EIP712, bound to a specific deployed contract.
func NewEIP712Transactor(address common.Address, transactor bind.ContractTransactor) (*EIP712Transactor, error) {
	contract, err := bindEIP712(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &EIP712Transactor{contract: contract}, nil
}

// NewEIP712Filterer creates a new log filterer instance of EIP712, bound to a specific deployed contract.
func NewEIP712Filterer(address common.Address, filterer bind.ContractFilterer) (*EIP712Filterer, error) {
	contract, err := bindEIP712(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &EIP712Filterer{contract: contract}, nil
}

// bindEIP712 binds a generic wrapper to an already deployed contract.
func bindEIP712(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := EIP712MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EIP712 *EIP712Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EIP712.Contract.EIP712Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EIP712 *EIP712Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EIP712.Contract.EIP712Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EIP712 *EIP712Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EIP712.Contract.EIP712Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EIP712 *EIP712CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EIP712.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EIP712 *EIP712TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EIP712.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EIP712 *EIP712TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EIP712.Contract.contract.Transact(opts, method, params...)
}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_EIP712 *EIP712Caller) Eip712Domain(opts *bind.CallOpts) (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	var out []interface{}
	err := _EIP712.contract.Call(opts, &out, "eip712Domain")

	outstruct := new(struct {
		Fields            [1]byte
		Name              string
		Version           string
		ChainId           *big.Int
		VerifyingContract common.Address
		Salt              [32]byte
		Extensions        []*big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Fields = *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)
	outstruct.Name = *abi.ConvertType(out[1], new(string)).(*string)
	outstruct.Version = *abi.ConvertType(out[2], new(string)).(*string)
	outstruct.ChainId = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.VerifyingContract = *abi.ConvertType(out[4], new(common.Address)).(*common.Address)
	outstruct.Salt = *abi.ConvertType(out[5], new([32]byte)).(*[32]byte)
	outstruct.Extensions = *abi.ConvertType(out[6], new([]*big.Int)).(*[]*big.Int)

	return *outstruct, err

}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_EIP712 *EIP712Session) Eip712Domain() (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	return _EIP712.Contract.Eip712Domain(&_EIP712.CallOpts)
}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_EIP712 *EIP712CallerSession) Eip712Domain() (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	return _EIP712.Contract.Eip712Domain(&_EIP712.CallOpts)
}

// EIP712EIP712DomainChangedIterator is returned from FilterEIP712DomainChanged and is used to iterate over the raw logs and unpacked data for EIP712DomainChanged events raised by the EIP712 contract.
type EIP712EIP712DomainChangedIterator struct {
	Event *EIP712EIP712DomainChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EIP712EIP712DomainChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EIP712EIP712DomainChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EIP712EIP712DomainChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EIP712EIP712DomainChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EIP712EIP712DomainChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EIP712EIP712DomainChanged represents a EIP712DomainChanged event raised by the EIP712 contract.
type EIP712EIP712DomainChanged struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterEIP712DomainChanged is a free log retrieval operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_EIP712 *EIP712Filterer) FilterEIP712DomainChanged(opts *bind.FilterOpts) (*EIP712EIP712DomainChangedIterator, error) {

	logs, sub, err := _EIP712.contract.FilterLogs(opts, "EIP712DomainChanged")
	if err != nil {
		return nil, err
	}
	return &EIP712EIP712DomainChangedIterator{contract: _EIP712.contract, event: "EIP712DomainChanged", logs: logs, sub: sub}, nil
}

// WatchEIP712DomainChanged is a free log subscription operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_EIP712 *EIP712Filterer) WatchEIP712DomainChanged(opts *bind.WatchOpts, sink chan<- *EIP712EIP712DomainChanged) (event.Subscription, error) {

	logs, sub, err := _EIP712.contract.WatchLogs(opts, "EIP712DomainChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EIP712EIP712DomainChanged)
				if err := _EIP712.contract.UnpackLog(event, "EIP712DomainChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEIP712DomainChanged is a log parse operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_EIP712 *EIP712Filterer) ParseEIP712DomainChanged(log types.Log) (*EIP712EIP712DomainChanged, error) {
	event := new(EIP712EIP712DomainChanged)
	if err := _EIP712.contract.UnpackLog(event, "EIP712DomainChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultMetaData contains all meta data concerning the IAuctionDepositVault contract.
var IAuctionDepositVaultMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeeVault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeVault\",\"type\":\"address\"}],\"name\":\"ChangeAuctionFeeVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ChangeMinDepositAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLocktime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLocktime\",\"type\":\"uint256\"}],\"name\":\"ChangeMinWithdrawLocktime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TakenBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TakenBidFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasAmount\",\"type\":\"uint256\"}],\"name\":\"TakenGas\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasAmount\",\"type\":\"uint256\"}],\"name\":\"TakenGasFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"VaultDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"VaultReserveWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"VaultWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAuctionFeeVault\",\"type\":\"address\"}],\"name\":\"changeAuctionFeeVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinAmount\",\"type\":\"uint256\"}],\"name\":\"changeMinDepositAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLocktime\",\"type\":\"uint256\"}],\"name\":\"changeMinWithdrawLocktime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"}],\"name\":\"depositBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"}],\"name\":\"depositFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getAllAddrsOverMinDeposit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"searchers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"depositAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nonces\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getDepositAddrs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"searchers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositAddrsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"}],\"name\":\"isMinDepositOver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"takeBid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"name\":\"takeGas\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"c2cf75ec": "changeAuctionFeeVault(address)",
		"8caad7b5": "changeMinDepositAmount(uint256)",
		"39253624": "changeMinWithdrawLocktime(uint256)",
		"d0e30db0": "deposit()",
		"1eb903cf": "depositBalances(address)",
		"aa67c919": "depositFor(address)",
		"5be1a55e": "getAllAddrsOverMinDeposit(uint256,uint256)",
		"e45076ac": "getDepositAddrs(uint256,uint256)",
		"84792e0b": "getDepositAddrsLength()",
		"48f928e8": "isMinDepositOver(address)",
		"bea39cab": "reserveWithdraw()",
		"08bf759d": "takeBid(address,uint256)",
		"b4fdfae5": "takeGas(address,uint256)",
		"3ccfd60b": "withdraw()",
	},
}

// IAuctionDepositVaultABI is the input ABI used to generate the binding from.
// Deprecated: Use IAuctionDepositVaultMetaData.ABI instead.
var IAuctionDepositVaultABI = IAuctionDepositVaultMetaData.ABI

// IAuctionDepositVaultBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IAuctionDepositVaultBinRuntime = ``

// Deprecated: Use IAuctionDepositVaultMetaData.Sigs instead.
// IAuctionDepositVaultFuncSigs maps the 4-byte function signature to its string representation.
var IAuctionDepositVaultFuncSigs = IAuctionDepositVaultMetaData.Sigs

// IAuctionDepositVault is an auto generated Go binding around a Kaia contract.
type IAuctionDepositVault struct {
	IAuctionDepositVaultCaller     // Read-only binding to the contract
	IAuctionDepositVaultTransactor // Write-only binding to the contract
	IAuctionDepositVaultFilterer   // Log filterer for contract events
}

// IAuctionDepositVaultCaller is an auto generated read-only Go binding around a Kaia contract.
type IAuctionDepositVaultCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionDepositVaultTransactor is an auto generated write-only Go binding around a Kaia contract.
type IAuctionDepositVaultTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionDepositVaultFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type IAuctionDepositVaultFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionDepositVaultSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type IAuctionDepositVaultSession struct {
	Contract     *IAuctionDepositVault // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IAuctionDepositVaultCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type IAuctionDepositVaultCallerSession struct {
	Contract *IAuctionDepositVaultCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// IAuctionDepositVaultTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type IAuctionDepositVaultTransactorSession struct {
	Contract     *IAuctionDepositVaultTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// IAuctionDepositVaultRaw is an auto generated low-level Go binding around a Kaia contract.
type IAuctionDepositVaultRaw struct {
	Contract *IAuctionDepositVault // Generic contract binding to access the raw methods on
}

// IAuctionDepositVaultCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type IAuctionDepositVaultCallerRaw struct {
	Contract *IAuctionDepositVaultCaller // Generic read-only contract binding to access the raw methods on
}

// IAuctionDepositVaultTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type IAuctionDepositVaultTransactorRaw struct {
	Contract *IAuctionDepositVaultTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAuctionDepositVault creates a new instance of IAuctionDepositVault, bound to a specific deployed contract.
func NewIAuctionDepositVault(address common.Address, backend bind.ContractBackend) (*IAuctionDepositVault, error) {
	contract, err := bindIAuctionDepositVault(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVault{IAuctionDepositVaultCaller: IAuctionDepositVaultCaller{contract: contract}, IAuctionDepositVaultTransactor: IAuctionDepositVaultTransactor{contract: contract}, IAuctionDepositVaultFilterer: IAuctionDepositVaultFilterer{contract: contract}}, nil
}

// NewIAuctionDepositVaultCaller creates a new read-only instance of IAuctionDepositVault, bound to a specific deployed contract.
func NewIAuctionDepositVaultCaller(address common.Address, caller bind.ContractCaller) (*IAuctionDepositVaultCaller, error) {
	contract, err := bindIAuctionDepositVault(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultCaller{contract: contract}, nil
}

// NewIAuctionDepositVaultTransactor creates a new write-only instance of IAuctionDepositVault, bound to a specific deployed contract.
func NewIAuctionDepositVaultTransactor(address common.Address, transactor bind.ContractTransactor) (*IAuctionDepositVaultTransactor, error) {
	contract, err := bindIAuctionDepositVault(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultTransactor{contract: contract}, nil
}

// NewIAuctionDepositVaultFilterer creates a new log filterer instance of IAuctionDepositVault, bound to a specific deployed contract.
func NewIAuctionDepositVaultFilterer(address common.Address, filterer bind.ContractFilterer) (*IAuctionDepositVaultFilterer, error) {
	contract, err := bindIAuctionDepositVault(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultFilterer{contract: contract}, nil
}

// bindIAuctionDepositVault binds a generic wrapper to an already deployed contract.
func bindIAuctionDepositVault(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IAuctionDepositVaultMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuctionDepositVault *IAuctionDepositVaultRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuctionDepositVault.Contract.IAuctionDepositVaultCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuctionDepositVault *IAuctionDepositVaultRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.IAuctionDepositVaultTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuctionDepositVault *IAuctionDepositVaultRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.IAuctionDepositVaultTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuctionDepositVault *IAuctionDepositVaultCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuctionDepositVault.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.contract.Transact(opts, method, params...)
}

// DepositBalances is a free data retrieval call binding the contract method 0x1eb903cf.
//
// Solidity: function depositBalances(address searcher) view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultCaller) DepositBalances(opts *bind.CallOpts, searcher common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IAuctionDepositVault.contract.Call(opts, &out, "depositBalances", searcher)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DepositBalances is a free data retrieval call binding the contract method 0x1eb903cf.
//
// Solidity: function depositBalances(address searcher) view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) DepositBalances(searcher common.Address) (*big.Int, error) {
	return _IAuctionDepositVault.Contract.DepositBalances(&_IAuctionDepositVault.CallOpts, searcher)
}

// DepositBalances is a free data retrieval call binding the contract method 0x1eb903cf.
//
// Solidity: function depositBalances(address searcher) view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultCallerSession) DepositBalances(searcher common.Address) (*big.Int, error) {
	return _IAuctionDepositVault.Contract.DepositBalances(&_IAuctionDepositVault.CallOpts, searcher)
}

// GetAllAddrsOverMinDeposit is a free data retrieval call binding the contract method 0x5be1a55e.
//
// Solidity: function getAllAddrsOverMinDeposit(uint256 start, uint256 limit) view returns(address[] searchers, uint256[] depositAmounts, uint256[] nonces)
func (_IAuctionDepositVault *IAuctionDepositVaultCaller) GetAllAddrsOverMinDeposit(opts *bind.CallOpts, start *big.Int, limit *big.Int) (struct {
	Searchers      []common.Address
	DepositAmounts []*big.Int
	Nonces         []*big.Int
}, error) {
	var out []interface{}
	err := _IAuctionDepositVault.contract.Call(opts, &out, "getAllAddrsOverMinDeposit", start, limit)

	outstruct := new(struct {
		Searchers      []common.Address
		DepositAmounts []*big.Int
		Nonces         []*big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Searchers = *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)
	outstruct.DepositAmounts = *abi.ConvertType(out[1], new([]*big.Int)).(*[]*big.Int)
	outstruct.Nonces = *abi.ConvertType(out[2], new([]*big.Int)).(*[]*big.Int)

	return *outstruct, err

}

// GetAllAddrsOverMinDeposit is a free data retrieval call binding the contract method 0x5be1a55e.
//
// Solidity: function getAllAddrsOverMinDeposit(uint256 start, uint256 limit) view returns(address[] searchers, uint256[] depositAmounts, uint256[] nonces)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) GetAllAddrsOverMinDeposit(start *big.Int, limit *big.Int) (struct {
	Searchers      []common.Address
	DepositAmounts []*big.Int
	Nonces         []*big.Int
}, error) {
	return _IAuctionDepositVault.Contract.GetAllAddrsOverMinDeposit(&_IAuctionDepositVault.CallOpts, start, limit)
}

// GetAllAddrsOverMinDeposit is a free data retrieval call binding the contract method 0x5be1a55e.
//
// Solidity: function getAllAddrsOverMinDeposit(uint256 start, uint256 limit) view returns(address[] searchers, uint256[] depositAmounts, uint256[] nonces)
func (_IAuctionDepositVault *IAuctionDepositVaultCallerSession) GetAllAddrsOverMinDeposit(start *big.Int, limit *big.Int) (struct {
	Searchers      []common.Address
	DepositAmounts []*big.Int
	Nonces         []*big.Int
}, error) {
	return _IAuctionDepositVault.Contract.GetAllAddrsOverMinDeposit(&_IAuctionDepositVault.CallOpts, start, limit)
}

// GetDepositAddrs is a free data retrieval call binding the contract method 0xe45076ac.
//
// Solidity: function getDepositAddrs(uint256 start, uint256 limit) view returns(address[] searchers)
func (_IAuctionDepositVault *IAuctionDepositVaultCaller) GetDepositAddrs(opts *bind.CallOpts, start *big.Int, limit *big.Int) ([]common.Address, error) {
	var out []interface{}
	err := _IAuctionDepositVault.contract.Call(opts, &out, "getDepositAddrs", start, limit)

	if err != nil {
		return *new([]common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)

	return out0, err

}

// GetDepositAddrs is a free data retrieval call binding the contract method 0xe45076ac.
//
// Solidity: function getDepositAddrs(uint256 start, uint256 limit) view returns(address[] searchers)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) GetDepositAddrs(start *big.Int, limit *big.Int) ([]common.Address, error) {
	return _IAuctionDepositVault.Contract.GetDepositAddrs(&_IAuctionDepositVault.CallOpts, start, limit)
}

// GetDepositAddrs is a free data retrieval call binding the contract method 0xe45076ac.
//
// Solidity: function getDepositAddrs(uint256 start, uint256 limit) view returns(address[] searchers)
func (_IAuctionDepositVault *IAuctionDepositVaultCallerSession) GetDepositAddrs(start *big.Int, limit *big.Int) ([]common.Address, error) {
	return _IAuctionDepositVault.Contract.GetDepositAddrs(&_IAuctionDepositVault.CallOpts, start, limit)
}

// GetDepositAddrsLength is a free data retrieval call binding the contract method 0x84792e0b.
//
// Solidity: function getDepositAddrsLength() view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultCaller) GetDepositAddrsLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IAuctionDepositVault.contract.Call(opts, &out, "getDepositAddrsLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetDepositAddrsLength is a free data retrieval call binding the contract method 0x84792e0b.
//
// Solidity: function getDepositAddrsLength() view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) GetDepositAddrsLength() (*big.Int, error) {
	return _IAuctionDepositVault.Contract.GetDepositAddrsLength(&_IAuctionDepositVault.CallOpts)
}

// GetDepositAddrsLength is a free data retrieval call binding the contract method 0x84792e0b.
//
// Solidity: function getDepositAddrsLength() view returns(uint256)
func (_IAuctionDepositVault *IAuctionDepositVaultCallerSession) GetDepositAddrsLength() (*big.Int, error) {
	return _IAuctionDepositVault.Contract.GetDepositAddrsLength(&_IAuctionDepositVault.CallOpts)
}

// IsMinDepositOver is a free data retrieval call binding the contract method 0x48f928e8.
//
// Solidity: function isMinDepositOver(address searcher) view returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultCaller) IsMinDepositOver(opts *bind.CallOpts, searcher common.Address) (bool, error) {
	var out []interface{}
	err := _IAuctionDepositVault.contract.Call(opts, &out, "isMinDepositOver", searcher)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsMinDepositOver is a free data retrieval call binding the contract method 0x48f928e8.
//
// Solidity: function isMinDepositOver(address searcher) view returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) IsMinDepositOver(searcher common.Address) (bool, error) {
	return _IAuctionDepositVault.Contract.IsMinDepositOver(&_IAuctionDepositVault.CallOpts, searcher)
}

// IsMinDepositOver is a free data retrieval call binding the contract method 0x48f928e8.
//
// Solidity: function isMinDepositOver(address searcher) view returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultCallerSession) IsMinDepositOver(searcher common.Address) (bool, error) {
	return _IAuctionDepositVault.Contract.IsMinDepositOver(&_IAuctionDepositVault.CallOpts, searcher)
}

// ChangeAuctionFeeVault is a paid mutator transaction binding the contract method 0xc2cf75ec.
//
// Solidity: function changeAuctionFeeVault(address newAuctionFeeVault) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) ChangeAuctionFeeVault(opts *bind.TransactOpts, newAuctionFeeVault common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "changeAuctionFeeVault", newAuctionFeeVault)
}

// ChangeAuctionFeeVault is a paid mutator transaction binding the contract method 0xc2cf75ec.
//
// Solidity: function changeAuctionFeeVault(address newAuctionFeeVault) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) ChangeAuctionFeeVault(newAuctionFeeVault common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeAuctionFeeVault(&_IAuctionDepositVault.TransactOpts, newAuctionFeeVault)
}

// ChangeAuctionFeeVault is a paid mutator transaction binding the contract method 0xc2cf75ec.
//
// Solidity: function changeAuctionFeeVault(address newAuctionFeeVault) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) ChangeAuctionFeeVault(newAuctionFeeVault common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeAuctionFeeVault(&_IAuctionDepositVault.TransactOpts, newAuctionFeeVault)
}

// ChangeMinDepositAmount is a paid mutator transaction binding the contract method 0x8caad7b5.
//
// Solidity: function changeMinDepositAmount(uint256 newMinAmount) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) ChangeMinDepositAmount(opts *bind.TransactOpts, newMinAmount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "changeMinDepositAmount", newMinAmount)
}

// ChangeMinDepositAmount is a paid mutator transaction binding the contract method 0x8caad7b5.
//
// Solidity: function changeMinDepositAmount(uint256 newMinAmount) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) ChangeMinDepositAmount(newMinAmount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeMinDepositAmount(&_IAuctionDepositVault.TransactOpts, newMinAmount)
}

// ChangeMinDepositAmount is a paid mutator transaction binding the contract method 0x8caad7b5.
//
// Solidity: function changeMinDepositAmount(uint256 newMinAmount) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) ChangeMinDepositAmount(newMinAmount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeMinDepositAmount(&_IAuctionDepositVault.TransactOpts, newMinAmount)
}

// ChangeMinWithdrawLocktime is a paid mutator transaction binding the contract method 0x39253624.
//
// Solidity: function changeMinWithdrawLocktime(uint256 newLocktime) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) ChangeMinWithdrawLocktime(opts *bind.TransactOpts, newLocktime *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "changeMinWithdrawLocktime", newLocktime)
}

// ChangeMinWithdrawLocktime is a paid mutator transaction binding the contract method 0x39253624.
//
// Solidity: function changeMinWithdrawLocktime(uint256 newLocktime) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) ChangeMinWithdrawLocktime(newLocktime *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeMinWithdrawLocktime(&_IAuctionDepositVault.TransactOpts, newLocktime)
}

// ChangeMinWithdrawLocktime is a paid mutator transaction binding the contract method 0x39253624.
//
// Solidity: function changeMinWithdrawLocktime(uint256 newLocktime) returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) ChangeMinWithdrawLocktime(newLocktime *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ChangeMinWithdrawLocktime(&_IAuctionDepositVault.TransactOpts, newLocktime)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) Deposit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "deposit")
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) Deposit() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.Deposit(&_IAuctionDepositVault.TransactOpts)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) Deposit() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.Deposit(&_IAuctionDepositVault.TransactOpts)
}

// DepositFor is a paid mutator transaction binding the contract method 0xaa67c919.
//
// Solidity: function depositFor(address searcher) payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) DepositFor(opts *bind.TransactOpts, searcher common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "depositFor", searcher)
}

// DepositFor is a paid mutator transaction binding the contract method 0xaa67c919.
//
// Solidity: function depositFor(address searcher) payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) DepositFor(searcher common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.DepositFor(&_IAuctionDepositVault.TransactOpts, searcher)
}

// DepositFor is a paid mutator transaction binding the contract method 0xaa67c919.
//
// Solidity: function depositFor(address searcher) payable returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) DepositFor(searcher common.Address) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.DepositFor(&_IAuctionDepositVault.TransactOpts, searcher)
}

// ReserveWithdraw is a paid mutator transaction binding the contract method 0xbea39cab.
//
// Solidity: function reserveWithdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) ReserveWithdraw(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "reserveWithdraw")
}

// ReserveWithdraw is a paid mutator transaction binding the contract method 0xbea39cab.
//
// Solidity: function reserveWithdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) ReserveWithdraw() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ReserveWithdraw(&_IAuctionDepositVault.TransactOpts)
}

// ReserveWithdraw is a paid mutator transaction binding the contract method 0xbea39cab.
//
// Solidity: function reserveWithdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) ReserveWithdraw() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.ReserveWithdraw(&_IAuctionDepositVault.TransactOpts)
}

// TakeBid is a paid mutator transaction binding the contract method 0x08bf759d.
//
// Solidity: function takeBid(address searcher, uint256 amount) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) TakeBid(opts *bind.TransactOpts, searcher common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "takeBid", searcher, amount)
}

// TakeBid is a paid mutator transaction binding the contract method 0x08bf759d.
//
// Solidity: function takeBid(address searcher, uint256 amount) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) TakeBid(searcher common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.TakeBid(&_IAuctionDepositVault.TransactOpts, searcher, amount)
}

// TakeBid is a paid mutator transaction binding the contract method 0x08bf759d.
//
// Solidity: function takeBid(address searcher, uint256 amount) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) TakeBid(searcher common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.TakeBid(&_IAuctionDepositVault.TransactOpts, searcher, amount)
}

// TakeGas is a paid mutator transaction binding the contract method 0xb4fdfae5.
//
// Solidity: function takeGas(address searcher, uint256 gasUsed) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) TakeGas(opts *bind.TransactOpts, searcher common.Address, gasUsed *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "takeGas", searcher, gasUsed)
}

// TakeGas is a paid mutator transaction binding the contract method 0xb4fdfae5.
//
// Solidity: function takeGas(address searcher, uint256 gasUsed) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultSession) TakeGas(searcher common.Address, gasUsed *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.TakeGas(&_IAuctionDepositVault.TransactOpts, searcher, gasUsed)
}

// TakeGas is a paid mutator transaction binding the contract method 0xb4fdfae5.
//
// Solidity: function takeGas(address searcher, uint256 gasUsed) returns(bool)
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) TakeGas(searcher common.Address, gasUsed *big.Int) (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.TakeGas(&_IAuctionDepositVault.TransactOpts, searcher, gasUsed)
}

// Withdraw is a paid mutator transaction binding the contract method 0x3ccfd60b.
//
// Solidity: function withdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactor) Withdraw(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionDepositVault.contract.Transact(opts, "withdraw")
}

// Withdraw is a paid mutator transaction binding the contract method 0x3ccfd60b.
//
// Solidity: function withdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultSession) Withdraw() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.Withdraw(&_IAuctionDepositVault.TransactOpts)
}

// Withdraw is a paid mutator transaction binding the contract method 0x3ccfd60b.
//
// Solidity: function withdraw() returns()
func (_IAuctionDepositVault *IAuctionDepositVaultTransactorSession) Withdraw() (*types.Transaction, error) {
	return _IAuctionDepositVault.Contract.Withdraw(&_IAuctionDepositVault.TransactOpts)
}

// IAuctionDepositVaultChangeAuctionFeeVaultIterator is returned from FilterChangeAuctionFeeVault and is used to iterate over the raw logs and unpacked data for ChangeAuctionFeeVault events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeAuctionFeeVaultIterator struct {
	Event *IAuctionDepositVaultChangeAuctionFeeVault // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultChangeAuctionFeeVaultIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultChangeAuctionFeeVault)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultChangeAuctionFeeVault)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultChangeAuctionFeeVaultIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultChangeAuctionFeeVaultIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultChangeAuctionFeeVault represents a ChangeAuctionFeeVault event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeAuctionFeeVault struct {
	OldFeeVault common.Address
	NewFeeVault common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterChangeAuctionFeeVault is a free log retrieval operation binding the contract event 0x384b2820c6944bcf938c3d8c170a4421377f8e7a397ffb5ff321b8dce59bb97d.
//
// Solidity: event ChangeAuctionFeeVault(address oldFeeVault, address newFeeVault)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterChangeAuctionFeeVault(opts *bind.FilterOpts) (*IAuctionDepositVaultChangeAuctionFeeVaultIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "ChangeAuctionFeeVault")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultChangeAuctionFeeVaultIterator{contract: _IAuctionDepositVault.contract, event: "ChangeAuctionFeeVault", logs: logs, sub: sub}, nil
}

// WatchChangeAuctionFeeVault is a free log subscription operation binding the contract event 0x384b2820c6944bcf938c3d8c170a4421377f8e7a397ffb5ff321b8dce59bb97d.
//
// Solidity: event ChangeAuctionFeeVault(address oldFeeVault, address newFeeVault)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchChangeAuctionFeeVault(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultChangeAuctionFeeVault) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "ChangeAuctionFeeVault")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultChangeAuctionFeeVault)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeAuctionFeeVault", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeAuctionFeeVault is a log parse operation binding the contract event 0x384b2820c6944bcf938c3d8c170a4421377f8e7a397ffb5ff321b8dce59bb97d.
//
// Solidity: event ChangeAuctionFeeVault(address oldFeeVault, address newFeeVault)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseChangeAuctionFeeVault(log types.Log) (*IAuctionDepositVaultChangeAuctionFeeVault, error) {
	event := new(IAuctionDepositVaultChangeAuctionFeeVault)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeAuctionFeeVault", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultChangeMinDepositAmountIterator is returned from FilterChangeMinDepositAmount and is used to iterate over the raw logs and unpacked data for ChangeMinDepositAmount events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeMinDepositAmountIterator struct {
	Event *IAuctionDepositVaultChangeMinDepositAmount // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultChangeMinDepositAmountIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultChangeMinDepositAmount)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultChangeMinDepositAmount)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultChangeMinDepositAmountIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultChangeMinDepositAmountIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultChangeMinDepositAmount represents a ChangeMinDepositAmount event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeMinDepositAmount struct {
	OldAmount *big.Int
	NewAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterChangeMinDepositAmount is a free log retrieval operation binding the contract event 0x404f17a8e681362e0d411e6b9b82111f6f7657596601fbe44eb9e2c960438f54.
//
// Solidity: event ChangeMinDepositAmount(uint256 oldAmount, uint256 newAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterChangeMinDepositAmount(opts *bind.FilterOpts) (*IAuctionDepositVaultChangeMinDepositAmountIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "ChangeMinDepositAmount")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultChangeMinDepositAmountIterator{contract: _IAuctionDepositVault.contract, event: "ChangeMinDepositAmount", logs: logs, sub: sub}, nil
}

// WatchChangeMinDepositAmount is a free log subscription operation binding the contract event 0x404f17a8e681362e0d411e6b9b82111f6f7657596601fbe44eb9e2c960438f54.
//
// Solidity: event ChangeMinDepositAmount(uint256 oldAmount, uint256 newAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchChangeMinDepositAmount(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultChangeMinDepositAmount) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "ChangeMinDepositAmount")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultChangeMinDepositAmount)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeMinDepositAmount", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeMinDepositAmount is a log parse operation binding the contract event 0x404f17a8e681362e0d411e6b9b82111f6f7657596601fbe44eb9e2c960438f54.
//
// Solidity: event ChangeMinDepositAmount(uint256 oldAmount, uint256 newAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseChangeMinDepositAmount(log types.Log) (*IAuctionDepositVaultChangeMinDepositAmount, error) {
	event := new(IAuctionDepositVaultChangeMinDepositAmount)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeMinDepositAmount", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultChangeMinWithdrawLocktimeIterator is returned from FilterChangeMinWithdrawLocktime and is used to iterate over the raw logs and unpacked data for ChangeMinWithdrawLocktime events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeMinWithdrawLocktimeIterator struct {
	Event *IAuctionDepositVaultChangeMinWithdrawLocktime // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultChangeMinWithdrawLocktimeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultChangeMinWithdrawLocktime)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultChangeMinWithdrawLocktime)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultChangeMinWithdrawLocktimeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultChangeMinWithdrawLocktimeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultChangeMinWithdrawLocktime represents a ChangeMinWithdrawLocktime event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultChangeMinWithdrawLocktime struct {
	OldLocktime *big.Int
	NewLocktime *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterChangeMinWithdrawLocktime is a free log retrieval operation binding the contract event 0x5e273c905caf5b3f4d3a98caf8814cdccb3860b2b334a58140b692fcf28b286d.
//
// Solidity: event ChangeMinWithdrawLocktime(uint256 oldLocktime, uint256 newLocktime)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterChangeMinWithdrawLocktime(opts *bind.FilterOpts) (*IAuctionDepositVaultChangeMinWithdrawLocktimeIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "ChangeMinWithdrawLocktime")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultChangeMinWithdrawLocktimeIterator{contract: _IAuctionDepositVault.contract, event: "ChangeMinWithdrawLocktime", logs: logs, sub: sub}, nil
}

// WatchChangeMinWithdrawLocktime is a free log subscription operation binding the contract event 0x5e273c905caf5b3f4d3a98caf8814cdccb3860b2b334a58140b692fcf28b286d.
//
// Solidity: event ChangeMinWithdrawLocktime(uint256 oldLocktime, uint256 newLocktime)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchChangeMinWithdrawLocktime(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultChangeMinWithdrawLocktime) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "ChangeMinWithdrawLocktime")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultChangeMinWithdrawLocktime)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeMinWithdrawLocktime", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeMinWithdrawLocktime is a log parse operation binding the contract event 0x5e273c905caf5b3f4d3a98caf8814cdccb3860b2b334a58140b692fcf28b286d.
//
// Solidity: event ChangeMinWithdrawLocktime(uint256 oldLocktime, uint256 newLocktime)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseChangeMinWithdrawLocktime(log types.Log) (*IAuctionDepositVaultChangeMinWithdrawLocktime, error) {
	event := new(IAuctionDepositVaultChangeMinWithdrawLocktime)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "ChangeMinWithdrawLocktime", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultInsufficientBalanceIterator is returned from FilterInsufficientBalance and is used to iterate over the raw logs and unpacked data for InsufficientBalance events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultInsufficientBalanceIterator struct {
	Event *IAuctionDepositVaultInsufficientBalance // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultInsufficientBalanceIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultInsufficientBalance)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultInsufficientBalance)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultInsufficientBalanceIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultInsufficientBalanceIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultInsufficientBalance represents a InsufficientBalance event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultInsufficientBalance struct {
	Searcher common.Address
	Balance  *big.Int
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterInsufficientBalance is a free log retrieval operation binding the contract event 0xdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c4.
//
// Solidity: event InsufficientBalance(address searcher, uint256 balance, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterInsufficientBalance(opts *bind.FilterOpts) (*IAuctionDepositVaultInsufficientBalanceIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "InsufficientBalance")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultInsufficientBalanceIterator{contract: _IAuctionDepositVault.contract, event: "InsufficientBalance", logs: logs, sub: sub}, nil
}

// WatchInsufficientBalance is a free log subscription operation binding the contract event 0xdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c4.
//
// Solidity: event InsufficientBalance(address searcher, uint256 balance, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchInsufficientBalance(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultInsufficientBalance) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "InsufficientBalance")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultInsufficientBalance)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "InsufficientBalance", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInsufficientBalance is a log parse operation binding the contract event 0xdb42144d928cd19733b9dfeead8bc02ed403845c274e06a6eee0944fb25ca5c4.
//
// Solidity: event InsufficientBalance(address searcher, uint256 balance, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseInsufficientBalance(log types.Log) (*IAuctionDepositVaultInsufficientBalance, error) {
	event := new(IAuctionDepositVaultInsufficientBalance)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "InsufficientBalance", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultTakenBidIterator is returned from FilterTakenBid and is used to iterate over the raw logs and unpacked data for TakenBid events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenBidIterator struct {
	Event *IAuctionDepositVaultTakenBid // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultTakenBidIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultTakenBid)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultTakenBid)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultTakenBidIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultTakenBidIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultTakenBid represents a TakenBid event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenBid struct {
	Searcher common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTakenBid is a free log retrieval operation binding the contract event 0xbf3f09205213cdb412585918db004ac3947fcd2db1f85fdbb20faaa950e08d2e.
//
// Solidity: event TakenBid(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterTakenBid(opts *bind.FilterOpts) (*IAuctionDepositVaultTakenBidIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "TakenBid")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultTakenBidIterator{contract: _IAuctionDepositVault.contract, event: "TakenBid", logs: logs, sub: sub}, nil
}

// WatchTakenBid is a free log subscription operation binding the contract event 0xbf3f09205213cdb412585918db004ac3947fcd2db1f85fdbb20faaa950e08d2e.
//
// Solidity: event TakenBid(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchTakenBid(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultTakenBid) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "TakenBid")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultTakenBid)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenBid", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenBid is a log parse operation binding the contract event 0xbf3f09205213cdb412585918db004ac3947fcd2db1f85fdbb20faaa950e08d2e.
//
// Solidity: event TakenBid(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseTakenBid(log types.Log) (*IAuctionDepositVaultTakenBid, error) {
	event := new(IAuctionDepositVaultTakenBid)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenBid", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultTakenBidFailedIterator is returned from FilterTakenBidFailed and is used to iterate over the raw logs and unpacked data for TakenBidFailed events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenBidFailedIterator struct {
	Event *IAuctionDepositVaultTakenBidFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultTakenBidFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultTakenBidFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultTakenBidFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultTakenBidFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultTakenBidFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultTakenBidFailed represents a TakenBidFailed event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenBidFailed struct {
	Searcher common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTakenBidFailed is a free log retrieval operation binding the contract event 0xd26b9fcb04629bad3365ea66f0f4d563e8c71753e7ee1a0c601f1a02ceebed8b.
//
// Solidity: event TakenBidFailed(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterTakenBidFailed(opts *bind.FilterOpts) (*IAuctionDepositVaultTakenBidFailedIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "TakenBidFailed")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultTakenBidFailedIterator{contract: _IAuctionDepositVault.contract, event: "TakenBidFailed", logs: logs, sub: sub}, nil
}

// WatchTakenBidFailed is a free log subscription operation binding the contract event 0xd26b9fcb04629bad3365ea66f0f4d563e8c71753e7ee1a0c601f1a02ceebed8b.
//
// Solidity: event TakenBidFailed(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchTakenBidFailed(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultTakenBidFailed) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "TakenBidFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultTakenBidFailed)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenBidFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenBidFailed is a log parse operation binding the contract event 0xd26b9fcb04629bad3365ea66f0f4d563e8c71753e7ee1a0c601f1a02ceebed8b.
//
// Solidity: event TakenBidFailed(address searcher, uint256 amount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseTakenBidFailed(log types.Log) (*IAuctionDepositVaultTakenBidFailed, error) {
	event := new(IAuctionDepositVaultTakenBidFailed)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenBidFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultTakenGasIterator is returned from FilterTakenGas and is used to iterate over the raw logs and unpacked data for TakenGas events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenGasIterator struct {
	Event *IAuctionDepositVaultTakenGas // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultTakenGasIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultTakenGas)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultTakenGas)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultTakenGasIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultTakenGasIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultTakenGas represents a TakenGas event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenGas struct {
	Searcher  common.Address
	GasAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterTakenGas is a free log retrieval operation binding the contract event 0x672970b97597bfb4460c604bb4adc66538c7b00a40bfb2cb9b6566f1692266fd.
//
// Solidity: event TakenGas(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterTakenGas(opts *bind.FilterOpts) (*IAuctionDepositVaultTakenGasIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "TakenGas")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultTakenGasIterator{contract: _IAuctionDepositVault.contract, event: "TakenGas", logs: logs, sub: sub}, nil
}

// WatchTakenGas is a free log subscription operation binding the contract event 0x672970b97597bfb4460c604bb4adc66538c7b00a40bfb2cb9b6566f1692266fd.
//
// Solidity: event TakenGas(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchTakenGas(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultTakenGas) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "TakenGas")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultTakenGas)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenGas", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenGas is a log parse operation binding the contract event 0x672970b97597bfb4460c604bb4adc66538c7b00a40bfb2cb9b6566f1692266fd.
//
// Solidity: event TakenGas(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseTakenGas(log types.Log) (*IAuctionDepositVaultTakenGas, error) {
	event := new(IAuctionDepositVaultTakenGas)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenGas", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultTakenGasFailedIterator is returned from FilterTakenGasFailed and is used to iterate over the raw logs and unpacked data for TakenGasFailed events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenGasFailedIterator struct {
	Event *IAuctionDepositVaultTakenGasFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultTakenGasFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultTakenGasFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultTakenGasFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultTakenGasFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultTakenGasFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultTakenGasFailed represents a TakenGasFailed event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultTakenGasFailed struct {
	Searcher  common.Address
	GasAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterTakenGasFailed is a free log retrieval operation binding the contract event 0x53605ab3492a9ae1542e049df64874ee628a589811e81b2594f416e9d092b7ca.
//
// Solidity: event TakenGasFailed(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterTakenGasFailed(opts *bind.FilterOpts) (*IAuctionDepositVaultTakenGasFailedIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "TakenGasFailed")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultTakenGasFailedIterator{contract: _IAuctionDepositVault.contract, event: "TakenGasFailed", logs: logs, sub: sub}, nil
}

// WatchTakenGasFailed is a free log subscription operation binding the contract event 0x53605ab3492a9ae1542e049df64874ee628a589811e81b2594f416e9d092b7ca.
//
// Solidity: event TakenGasFailed(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchTakenGasFailed(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultTakenGasFailed) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "TakenGasFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultTakenGasFailed)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenGasFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTakenGasFailed is a log parse operation binding the contract event 0x53605ab3492a9ae1542e049df64874ee628a589811e81b2594f416e9d092b7ca.
//
// Solidity: event TakenGasFailed(address searcher, uint256 gasAmount)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseTakenGasFailed(log types.Log) (*IAuctionDepositVaultTakenGasFailed, error) {
	event := new(IAuctionDepositVaultTakenGasFailed)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "TakenGasFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultVaultDepositIterator is returned from FilterVaultDeposit and is used to iterate over the raw logs and unpacked data for VaultDeposit events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultDepositIterator struct {
	Event *IAuctionDepositVaultVaultDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultVaultDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultVaultDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultVaultDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultVaultDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultVaultDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultVaultDeposit represents a VaultDeposit event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultDeposit struct {
	Searcher    common.Address
	Amount      *big.Int
	TotalAmount *big.Int
	Nonce       *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterVaultDeposit is a free log retrieval operation binding the contract event 0xb356f70fb7268cd9ebf6cd2c25e8628582435a3754305d2edade9b81c0961181.
//
// Solidity: event VaultDeposit(address searcher, uint256 amount, uint256 totalAmount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterVaultDeposit(opts *bind.FilterOpts) (*IAuctionDepositVaultVaultDepositIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "VaultDeposit")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultVaultDepositIterator{contract: _IAuctionDepositVault.contract, event: "VaultDeposit", logs: logs, sub: sub}, nil
}

// WatchVaultDeposit is a free log subscription operation binding the contract event 0xb356f70fb7268cd9ebf6cd2c25e8628582435a3754305d2edade9b81c0961181.
//
// Solidity: event VaultDeposit(address searcher, uint256 amount, uint256 totalAmount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchVaultDeposit(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultVaultDeposit) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "VaultDeposit")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultVaultDeposit)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultDeposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVaultDeposit is a log parse operation binding the contract event 0xb356f70fb7268cd9ebf6cd2c25e8628582435a3754305d2edade9b81c0961181.
//
// Solidity: event VaultDeposit(address searcher, uint256 amount, uint256 totalAmount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseVaultDeposit(log types.Log) (*IAuctionDepositVaultVaultDeposit, error) {
	event := new(IAuctionDepositVaultVaultDeposit)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultDeposit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultVaultReserveWithdrawIterator is returned from FilterVaultReserveWithdraw and is used to iterate over the raw logs and unpacked data for VaultReserveWithdraw events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultReserveWithdrawIterator struct {
	Event *IAuctionDepositVaultVaultReserveWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultVaultReserveWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultVaultReserveWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultVaultReserveWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultVaultReserveWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultVaultReserveWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultVaultReserveWithdraw represents a VaultReserveWithdraw event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultReserveWithdraw struct {
	Searcher common.Address
	Amount   *big.Int
	Nonce    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterVaultReserveWithdraw is a free log retrieval operation binding the contract event 0x89312dfc642f95af3c0376f434dd92d2ce54d713297a8df3921828edbd2ef1a1.
//
// Solidity: event VaultReserveWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterVaultReserveWithdraw(opts *bind.FilterOpts) (*IAuctionDepositVaultVaultReserveWithdrawIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "VaultReserveWithdraw")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultVaultReserveWithdrawIterator{contract: _IAuctionDepositVault.contract, event: "VaultReserveWithdraw", logs: logs, sub: sub}, nil
}

// WatchVaultReserveWithdraw is a free log subscription operation binding the contract event 0x89312dfc642f95af3c0376f434dd92d2ce54d713297a8df3921828edbd2ef1a1.
//
// Solidity: event VaultReserveWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchVaultReserveWithdraw(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultVaultReserveWithdraw) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "VaultReserveWithdraw")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultVaultReserveWithdraw)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultReserveWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVaultReserveWithdraw is a log parse operation binding the contract event 0x89312dfc642f95af3c0376f434dd92d2ce54d713297a8df3921828edbd2ef1a1.
//
// Solidity: event VaultReserveWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseVaultReserveWithdraw(log types.Log) (*IAuctionDepositVaultVaultReserveWithdraw, error) {
	event := new(IAuctionDepositVaultVaultReserveWithdraw)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultReserveWithdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionDepositVaultVaultWithdrawIterator is returned from FilterVaultWithdraw and is used to iterate over the raw logs and unpacked data for VaultWithdraw events raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultWithdrawIterator struct {
	Event *IAuctionDepositVaultVaultWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionDepositVaultVaultWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionDepositVaultVaultWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionDepositVaultVaultWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionDepositVaultVaultWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionDepositVaultVaultWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionDepositVaultVaultWithdraw represents a VaultWithdraw event raised by the IAuctionDepositVault contract.
type IAuctionDepositVaultVaultWithdraw struct {
	Searcher common.Address
	Amount   *big.Int
	Nonce    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterVaultWithdraw is a free log retrieval operation binding the contract event 0x97c7b889c23f0ecb7c22eac5c58266eae022989cfdbd9b6dcf63417338c787de.
//
// Solidity: event VaultWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) FilterVaultWithdraw(opts *bind.FilterOpts) (*IAuctionDepositVaultVaultWithdrawIterator, error) {

	logs, sub, err := _IAuctionDepositVault.contract.FilterLogs(opts, "VaultWithdraw")
	if err != nil {
		return nil, err
	}
	return &IAuctionDepositVaultVaultWithdrawIterator{contract: _IAuctionDepositVault.contract, event: "VaultWithdraw", logs: logs, sub: sub}, nil
}

// WatchVaultWithdraw is a free log subscription operation binding the contract event 0x97c7b889c23f0ecb7c22eac5c58266eae022989cfdbd9b6dcf63417338c787de.
//
// Solidity: event VaultWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) WatchVaultWithdraw(opts *bind.WatchOpts, sink chan<- *IAuctionDepositVaultVaultWithdraw) (event.Subscription, error) {

	logs, sub, err := _IAuctionDepositVault.contract.WatchLogs(opts, "VaultWithdraw")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionDepositVaultVaultWithdraw)
				if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVaultWithdraw is a log parse operation binding the contract event 0x97c7b889c23f0ecb7c22eac5c58266eae022989cfdbd9b6dcf63417338c787de.
//
// Solidity: event VaultWithdraw(address searcher, uint256 amount, uint256 nonce)
func (_IAuctionDepositVault *IAuctionDepositVaultFilterer) ParseVaultWithdraw(log types.Log) (*IAuctionDepositVaultVaultWithdraw, error) {
	event := new(IAuctionDepositVaultVaultWithdraw)
	if err := _IAuctionDepositVault.contract.UnpackLog(event, "VaultWithdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionEntryPointMetaData contains all meta data concerning the IAuctionEntryPoint contract.
var IAuctionEntryPointMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Call\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"CallFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAuctioneer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAuctioneer\",\"type\":\"address\"}],\"name\":\"ChangeAuctioneer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDepositVault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDepositVault\",\"type\":\"address\"}],\"name\":\"ChangeDepositVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"UseNonce\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"auctioneer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"targetTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"searcherSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auctioneerSig\",\"type\":\"bytes\"}],\"internalType\":\"structIAuctionEntryPoint.AuctionTx\",\"name\":\"auctionTx\",\"type\":\"tuple\"}],\"name\":\"call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_auctioneer\",\"type\":\"address\"}],\"name\":\"changeAuctioneer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositVault\",\"type\":\"address\"}],\"name\":\"changeDepositVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositVault\",\"outputs\":[{\"internalType\":\"contractIAuctionDepositVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"targetTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"searcherSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auctioneerSig\",\"type\":\"bytes\"}],\"internalType\":\"structIAuctionEntryPoint.AuctionTx\",\"name\":\"auctionTx\",\"type\":\"tuple\"}],\"name\":\"getAuctionTxHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"searchers\",\"type\":\"address[]\"}],\"name\":\"getNonceAndBids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nonces_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bids_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"5ec2c7bf": "auctioneer()",
		"ca157554": "call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes))",
		"774f45ec": "changeAuctioneer(address)",
		"9d59928b": "changeDepositVault(address)",
		"d7cd3949": "depositVault()",
		"a8aa9450": "getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes))",
		"287ca78e": "getNonceAndBids(address[])",
	},
}

// IAuctionEntryPointABI is the input ABI used to generate the binding from.
// Deprecated: Use IAuctionEntryPointMetaData.ABI instead.
var IAuctionEntryPointABI = IAuctionEntryPointMetaData.ABI

// IAuctionEntryPointBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IAuctionEntryPointBinRuntime = ``

// Deprecated: Use IAuctionEntryPointMetaData.Sigs instead.
// IAuctionEntryPointFuncSigs maps the 4-byte function signature to its string representation.
var IAuctionEntryPointFuncSigs = IAuctionEntryPointMetaData.Sigs

// IAuctionEntryPoint is an auto generated Go binding around a Kaia contract.
type IAuctionEntryPoint struct {
	IAuctionEntryPointCaller     // Read-only binding to the contract
	IAuctionEntryPointTransactor // Write-only binding to the contract
	IAuctionEntryPointFilterer   // Log filterer for contract events
}

// IAuctionEntryPointCaller is an auto generated read-only Go binding around a Kaia contract.
type IAuctionEntryPointCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionEntryPointTransactor is an auto generated write-only Go binding around a Kaia contract.
type IAuctionEntryPointTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionEntryPointFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type IAuctionEntryPointFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuctionEntryPointSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type IAuctionEntryPointSession struct {
	Contract     *IAuctionEntryPoint // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// IAuctionEntryPointCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type IAuctionEntryPointCallerSession struct {
	Contract *IAuctionEntryPointCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// IAuctionEntryPointTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type IAuctionEntryPointTransactorSession struct {
	Contract     *IAuctionEntryPointTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// IAuctionEntryPointRaw is an auto generated low-level Go binding around a Kaia contract.
type IAuctionEntryPointRaw struct {
	Contract *IAuctionEntryPoint // Generic contract binding to access the raw methods on
}

// IAuctionEntryPointCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type IAuctionEntryPointCallerRaw struct {
	Contract *IAuctionEntryPointCaller // Generic read-only contract binding to access the raw methods on
}

// IAuctionEntryPointTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type IAuctionEntryPointTransactorRaw struct {
	Contract *IAuctionEntryPointTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAuctionEntryPoint creates a new instance of IAuctionEntryPoint, bound to a specific deployed contract.
func NewIAuctionEntryPoint(address common.Address, backend bind.ContractBackend) (*IAuctionEntryPoint, error) {
	contract, err := bindIAuctionEntryPoint(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPoint{IAuctionEntryPointCaller: IAuctionEntryPointCaller{contract: contract}, IAuctionEntryPointTransactor: IAuctionEntryPointTransactor{contract: contract}, IAuctionEntryPointFilterer: IAuctionEntryPointFilterer{contract: contract}}, nil
}

// NewIAuctionEntryPointCaller creates a new read-only instance of IAuctionEntryPoint, bound to a specific deployed contract.
func NewIAuctionEntryPointCaller(address common.Address, caller bind.ContractCaller) (*IAuctionEntryPointCaller, error) {
	contract, err := bindIAuctionEntryPoint(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointCaller{contract: contract}, nil
}

// NewIAuctionEntryPointTransactor creates a new write-only instance of IAuctionEntryPoint, bound to a specific deployed contract.
func NewIAuctionEntryPointTransactor(address common.Address, transactor bind.ContractTransactor) (*IAuctionEntryPointTransactor, error) {
	contract, err := bindIAuctionEntryPoint(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointTransactor{contract: contract}, nil
}

// NewIAuctionEntryPointFilterer creates a new log filterer instance of IAuctionEntryPoint, bound to a specific deployed contract.
func NewIAuctionEntryPointFilterer(address common.Address, filterer bind.ContractFilterer) (*IAuctionEntryPointFilterer, error) {
	contract, err := bindIAuctionEntryPoint(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointFilterer{contract: contract}, nil
}

// bindIAuctionEntryPoint binds a generic wrapper to an already deployed contract.
func bindIAuctionEntryPoint(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IAuctionEntryPointMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuctionEntryPoint *IAuctionEntryPointRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuctionEntryPoint.Contract.IAuctionEntryPointCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuctionEntryPoint *IAuctionEntryPointRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.IAuctionEntryPointTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuctionEntryPoint *IAuctionEntryPointRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.IAuctionEntryPointTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuctionEntryPoint *IAuctionEntryPointCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuctionEntryPoint.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuctionEntryPoint *IAuctionEntryPointTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuctionEntryPoint *IAuctionEntryPointTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.contract.Transact(opts, method, params...)
}

// Auctioneer is a free data retrieval call binding the contract method 0x5ec2c7bf.
//
// Solidity: function auctioneer() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointCaller) Auctioneer(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IAuctionEntryPoint.contract.Call(opts, &out, "auctioneer")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Auctioneer is a free data retrieval call binding the contract method 0x5ec2c7bf.
//
// Solidity: function auctioneer() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointSession) Auctioneer() (common.Address, error) {
	return _IAuctionEntryPoint.Contract.Auctioneer(&_IAuctionEntryPoint.CallOpts)
}

// Auctioneer is a free data retrieval call binding the contract method 0x5ec2c7bf.
//
// Solidity: function auctioneer() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointCallerSession) Auctioneer() (common.Address, error) {
	return _IAuctionEntryPoint.Contract.Auctioneer(&_IAuctionEntryPoint.CallOpts)
}

// DepositVault is a free data retrieval call binding the contract method 0xd7cd3949.
//
// Solidity: function depositVault() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointCaller) DepositVault(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IAuctionEntryPoint.contract.Call(opts, &out, "depositVault")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// DepositVault is a free data retrieval call binding the contract method 0xd7cd3949.
//
// Solidity: function depositVault() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointSession) DepositVault() (common.Address, error) {
	return _IAuctionEntryPoint.Contract.DepositVault(&_IAuctionEntryPoint.CallOpts)
}

// DepositVault is a free data retrieval call binding the contract method 0xd7cd3949.
//
// Solidity: function depositVault() view returns(address)
func (_IAuctionEntryPoint *IAuctionEntryPointCallerSession) DepositVault() (common.Address, error) {
	return _IAuctionEntryPoint.Contract.DepositVault(&_IAuctionEntryPoint.CallOpts)
}

// GetAuctionTxHash is a free data retrieval call binding the contract method 0xa8aa9450.
//
// Solidity: function getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) view returns(bytes32)
func (_IAuctionEntryPoint *IAuctionEntryPointCaller) GetAuctionTxHash(opts *bind.CallOpts, auctionTx IAuctionEntryPointAuctionTx) ([32]byte, error) {
	var out []interface{}
	err := _IAuctionEntryPoint.contract.Call(opts, &out, "getAuctionTxHash", auctionTx)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetAuctionTxHash is a free data retrieval call binding the contract method 0xa8aa9450.
//
// Solidity: function getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) view returns(bytes32)
func (_IAuctionEntryPoint *IAuctionEntryPointSession) GetAuctionTxHash(auctionTx IAuctionEntryPointAuctionTx) ([32]byte, error) {
	return _IAuctionEntryPoint.Contract.GetAuctionTxHash(&_IAuctionEntryPoint.CallOpts, auctionTx)
}

// GetAuctionTxHash is a free data retrieval call binding the contract method 0xa8aa9450.
//
// Solidity: function getAuctionTxHash((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) view returns(bytes32)
func (_IAuctionEntryPoint *IAuctionEntryPointCallerSession) GetAuctionTxHash(auctionTx IAuctionEntryPointAuctionTx) ([32]byte, error) {
	return _IAuctionEntryPoint.Contract.GetAuctionTxHash(&_IAuctionEntryPoint.CallOpts, auctionTx)
}

// GetNonceAndBids is a free data retrieval call binding the contract method 0x287ca78e.
//
// Solidity: function getNonceAndBids(address[] searchers) view returns(uint256[] nonces_, uint256[] bids_)
func (_IAuctionEntryPoint *IAuctionEntryPointCaller) GetNonceAndBids(opts *bind.CallOpts, searchers []common.Address) (struct {
	Nonces []*big.Int
	Bids   []*big.Int
}, error) {
	var out []interface{}
	err := _IAuctionEntryPoint.contract.Call(opts, &out, "getNonceAndBids", searchers)

	outstruct := new(struct {
		Nonces []*big.Int
		Bids   []*big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Nonces = *abi.ConvertType(out[0], new([]*big.Int)).(*[]*big.Int)
	outstruct.Bids = *abi.ConvertType(out[1], new([]*big.Int)).(*[]*big.Int)

	return *outstruct, err

}

// GetNonceAndBids is a free data retrieval call binding the contract method 0x287ca78e.
//
// Solidity: function getNonceAndBids(address[] searchers) view returns(uint256[] nonces_, uint256[] bids_)
func (_IAuctionEntryPoint *IAuctionEntryPointSession) GetNonceAndBids(searchers []common.Address) (struct {
	Nonces []*big.Int
	Bids   []*big.Int
}, error) {
	return _IAuctionEntryPoint.Contract.GetNonceAndBids(&_IAuctionEntryPoint.CallOpts, searchers)
}

// GetNonceAndBids is a free data retrieval call binding the contract method 0x287ca78e.
//
// Solidity: function getNonceAndBids(address[] searchers) view returns(uint256[] nonces_, uint256[] bids_)
func (_IAuctionEntryPoint *IAuctionEntryPointCallerSession) GetNonceAndBids(searchers []common.Address) (struct {
	Nonces []*big.Int
	Bids   []*big.Int
}, error) {
	return _IAuctionEntryPoint.Contract.GetNonceAndBids(&_IAuctionEntryPoint.CallOpts, searchers)
}

// Call is a paid mutator transaction binding the contract method 0xca157554.
//
// Solidity: function call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactor) Call(opts *bind.TransactOpts, auctionTx IAuctionEntryPointAuctionTx) (*types.Transaction, error) {
	return _IAuctionEntryPoint.contract.Transact(opts, "call", auctionTx)
}

// Call is a paid mutator transaction binding the contract method 0xca157554.
//
// Solidity: function call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointSession) Call(auctionTx IAuctionEntryPointAuctionTx) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.Call(&_IAuctionEntryPoint.TransactOpts, auctionTx)
}

// Call is a paid mutator transaction binding the contract method 0xca157554.
//
// Solidity: function call((bytes32,uint256,address,address,uint256,uint256,uint256,bytes,bytes,bytes) auctionTx) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactorSession) Call(auctionTx IAuctionEntryPointAuctionTx) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.Call(&_IAuctionEntryPoint.TransactOpts, auctionTx)
}

// ChangeAuctioneer is a paid mutator transaction binding the contract method 0x774f45ec.
//
// Solidity: function changeAuctioneer(address _auctioneer) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactor) ChangeAuctioneer(opts *bind.TransactOpts, _auctioneer common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.contract.Transact(opts, "changeAuctioneer", _auctioneer)
}

// ChangeAuctioneer is a paid mutator transaction binding the contract method 0x774f45ec.
//
// Solidity: function changeAuctioneer(address _auctioneer) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointSession) ChangeAuctioneer(_auctioneer common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.ChangeAuctioneer(&_IAuctionEntryPoint.TransactOpts, _auctioneer)
}

// ChangeAuctioneer is a paid mutator transaction binding the contract method 0x774f45ec.
//
// Solidity: function changeAuctioneer(address _auctioneer) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactorSession) ChangeAuctioneer(_auctioneer common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.ChangeAuctioneer(&_IAuctionEntryPoint.TransactOpts, _auctioneer)
}

// ChangeDepositVault is a paid mutator transaction binding the contract method 0x9d59928b.
//
// Solidity: function changeDepositVault(address _depositVault) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactor) ChangeDepositVault(opts *bind.TransactOpts, _depositVault common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.contract.Transact(opts, "changeDepositVault", _depositVault)
}

// ChangeDepositVault is a paid mutator transaction binding the contract method 0x9d59928b.
//
// Solidity: function changeDepositVault(address _depositVault) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointSession) ChangeDepositVault(_depositVault common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.ChangeDepositVault(&_IAuctionEntryPoint.TransactOpts, _depositVault)
}

// ChangeDepositVault is a paid mutator transaction binding the contract method 0x9d59928b.
//
// Solidity: function changeDepositVault(address _depositVault) returns()
func (_IAuctionEntryPoint *IAuctionEntryPointTransactorSession) ChangeDepositVault(_depositVault common.Address) (*types.Transaction, error) {
	return _IAuctionEntryPoint.Contract.ChangeDepositVault(&_IAuctionEntryPoint.TransactOpts, _depositVault)
}

// IAuctionEntryPointCallIterator is returned from FilterCall and is used to iterate over the raw logs and unpacked data for Call events raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointCallIterator struct {
	Event *IAuctionEntryPointCall // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionEntryPointCallIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionEntryPointCall)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionEntryPointCall)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionEntryPointCallIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionEntryPointCallIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionEntryPointCall represents a Call event raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointCall struct {
	Sender common.Address
	Nonce  *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterCall is a free log retrieval operation binding the contract event 0x9e4369a013b5e45a103a959d8eb70f15c55dc496e8335f245690393dfb4b71d4.
//
// Solidity: event Call(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) FilterCall(opts *bind.FilterOpts) (*IAuctionEntryPointCallIterator, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.FilterLogs(opts, "Call")
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointCallIterator{contract: _IAuctionEntryPoint.contract, event: "Call", logs: logs, sub: sub}, nil
}

// WatchCall is a free log subscription operation binding the contract event 0x9e4369a013b5e45a103a959d8eb70f15c55dc496e8335f245690393dfb4b71d4.
//
// Solidity: event Call(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) WatchCall(opts *bind.WatchOpts, sink chan<- *IAuctionEntryPointCall) (event.Subscription, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.WatchLogs(opts, "Call")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionEntryPointCall)
				if err := _IAuctionEntryPoint.contract.UnpackLog(event, "Call", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCall is a log parse operation binding the contract event 0x9e4369a013b5e45a103a959d8eb70f15c55dc496e8335f245690393dfb4b71d4.
//
// Solidity: event Call(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) ParseCall(log types.Log) (*IAuctionEntryPointCall, error) {
	event := new(IAuctionEntryPointCall)
	if err := _IAuctionEntryPoint.contract.UnpackLog(event, "Call", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionEntryPointCallFailedIterator is returned from FilterCallFailed and is used to iterate over the raw logs and unpacked data for CallFailed events raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointCallFailedIterator struct {
	Event *IAuctionEntryPointCallFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionEntryPointCallFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionEntryPointCallFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionEntryPointCallFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionEntryPointCallFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionEntryPointCallFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionEntryPointCallFailed represents a CallFailed event raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointCallFailed struct {
	Sender common.Address
	Nonce  *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterCallFailed is a free log retrieval operation binding the contract event 0xb9eaeae386d339f8115782f297a9e5f0e13fb587cd6b0d502f113cb8dd4d6cb0.
//
// Solidity: event CallFailed(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) FilterCallFailed(opts *bind.FilterOpts) (*IAuctionEntryPointCallFailedIterator, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.FilterLogs(opts, "CallFailed")
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointCallFailedIterator{contract: _IAuctionEntryPoint.contract, event: "CallFailed", logs: logs, sub: sub}, nil
}

// WatchCallFailed is a free log subscription operation binding the contract event 0xb9eaeae386d339f8115782f297a9e5f0e13fb587cd6b0d502f113cb8dd4d6cb0.
//
// Solidity: event CallFailed(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) WatchCallFailed(opts *bind.WatchOpts, sink chan<- *IAuctionEntryPointCallFailed) (event.Subscription, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.WatchLogs(opts, "CallFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionEntryPointCallFailed)
				if err := _IAuctionEntryPoint.contract.UnpackLog(event, "CallFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCallFailed is a log parse operation binding the contract event 0xb9eaeae386d339f8115782f297a9e5f0e13fb587cd6b0d502f113cb8dd4d6cb0.
//
// Solidity: event CallFailed(address sender, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) ParseCallFailed(log types.Log) (*IAuctionEntryPointCallFailed, error) {
	event := new(IAuctionEntryPointCallFailed)
	if err := _IAuctionEntryPoint.contract.UnpackLog(event, "CallFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionEntryPointChangeAuctioneerIterator is returned from FilterChangeAuctioneer and is used to iterate over the raw logs and unpacked data for ChangeAuctioneer events raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointChangeAuctioneerIterator struct {
	Event *IAuctionEntryPointChangeAuctioneer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionEntryPointChangeAuctioneerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionEntryPointChangeAuctioneer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionEntryPointChangeAuctioneer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionEntryPointChangeAuctioneerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionEntryPointChangeAuctioneerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionEntryPointChangeAuctioneer represents a ChangeAuctioneer event raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointChangeAuctioneer struct {
	OldAuctioneer common.Address
	NewAuctioneer common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterChangeAuctioneer is a free log retrieval operation binding the contract event 0xc8a0473779a405800019e7658500d0930d92f78e776b553d286baeefb9c9a0f1.
//
// Solidity: event ChangeAuctioneer(address oldAuctioneer, address newAuctioneer)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) FilterChangeAuctioneer(opts *bind.FilterOpts) (*IAuctionEntryPointChangeAuctioneerIterator, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.FilterLogs(opts, "ChangeAuctioneer")
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointChangeAuctioneerIterator{contract: _IAuctionEntryPoint.contract, event: "ChangeAuctioneer", logs: logs, sub: sub}, nil
}

// WatchChangeAuctioneer is a free log subscription operation binding the contract event 0xc8a0473779a405800019e7658500d0930d92f78e776b553d286baeefb9c9a0f1.
//
// Solidity: event ChangeAuctioneer(address oldAuctioneer, address newAuctioneer)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) WatchChangeAuctioneer(opts *bind.WatchOpts, sink chan<- *IAuctionEntryPointChangeAuctioneer) (event.Subscription, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.WatchLogs(opts, "ChangeAuctioneer")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionEntryPointChangeAuctioneer)
				if err := _IAuctionEntryPoint.contract.UnpackLog(event, "ChangeAuctioneer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeAuctioneer is a log parse operation binding the contract event 0xc8a0473779a405800019e7658500d0930d92f78e776b553d286baeefb9c9a0f1.
//
// Solidity: event ChangeAuctioneer(address oldAuctioneer, address newAuctioneer)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) ParseChangeAuctioneer(log types.Log) (*IAuctionEntryPointChangeAuctioneer, error) {
	event := new(IAuctionEntryPointChangeAuctioneer)
	if err := _IAuctionEntryPoint.contract.UnpackLog(event, "ChangeAuctioneer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionEntryPointChangeDepositVaultIterator is returned from FilterChangeDepositVault and is used to iterate over the raw logs and unpacked data for ChangeDepositVault events raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointChangeDepositVaultIterator struct {
	Event *IAuctionEntryPointChangeDepositVault // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionEntryPointChangeDepositVaultIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionEntryPointChangeDepositVault)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionEntryPointChangeDepositVault)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionEntryPointChangeDepositVaultIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionEntryPointChangeDepositVaultIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionEntryPointChangeDepositVault represents a ChangeDepositVault event raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointChangeDepositVault struct {
	OldDepositVault common.Address
	NewDepositVault common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterChangeDepositVault is a free log retrieval operation binding the contract event 0x32718750012b831b1e21ea05c1ed833c9365fc94e7316126303f6d09f41beb5d.
//
// Solidity: event ChangeDepositVault(address oldDepositVault, address newDepositVault)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) FilterChangeDepositVault(opts *bind.FilterOpts) (*IAuctionEntryPointChangeDepositVaultIterator, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.FilterLogs(opts, "ChangeDepositVault")
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointChangeDepositVaultIterator{contract: _IAuctionEntryPoint.contract, event: "ChangeDepositVault", logs: logs, sub: sub}, nil
}

// WatchChangeDepositVault is a free log subscription operation binding the contract event 0x32718750012b831b1e21ea05c1ed833c9365fc94e7316126303f6d09f41beb5d.
//
// Solidity: event ChangeDepositVault(address oldDepositVault, address newDepositVault)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) WatchChangeDepositVault(opts *bind.WatchOpts, sink chan<- *IAuctionEntryPointChangeDepositVault) (event.Subscription, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.WatchLogs(opts, "ChangeDepositVault")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionEntryPointChangeDepositVault)
				if err := _IAuctionEntryPoint.contract.UnpackLog(event, "ChangeDepositVault", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangeDepositVault is a log parse operation binding the contract event 0x32718750012b831b1e21ea05c1ed833c9365fc94e7316126303f6d09f41beb5d.
//
// Solidity: event ChangeDepositVault(address oldDepositVault, address newDepositVault)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) ParseChangeDepositVault(log types.Log) (*IAuctionEntryPointChangeDepositVault, error) {
	event := new(IAuctionEntryPointChangeDepositVault)
	if err := _IAuctionEntryPoint.contract.UnpackLog(event, "ChangeDepositVault", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuctionEntryPointUseNonceIterator is returned from FilterUseNonce and is used to iterate over the raw logs and unpacked data for UseNonce events raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointUseNonceIterator struct {
	Event *IAuctionEntryPointUseNonce // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAuctionEntryPointUseNonceIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAuctionEntryPointUseNonce)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAuctionEntryPointUseNonce)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAuctionEntryPointUseNonceIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAuctionEntryPointUseNonceIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAuctionEntryPointUseNonce represents a UseNonce event raised by the IAuctionEntryPoint contract.
type IAuctionEntryPointUseNonce struct {
	Searcher common.Address
	Nonce    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterUseNonce is a free log retrieval operation binding the contract event 0x7243aab3c75cebfd96dc41ece7762eb023fc8c81e9ba2ce1d487876419b918b5.
//
// Solidity: event UseNonce(address searcher, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) FilterUseNonce(opts *bind.FilterOpts) (*IAuctionEntryPointUseNonceIterator, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.FilterLogs(opts, "UseNonce")
	if err != nil {
		return nil, err
	}
	return &IAuctionEntryPointUseNonceIterator{contract: _IAuctionEntryPoint.contract, event: "UseNonce", logs: logs, sub: sub}, nil
}

// WatchUseNonce is a free log subscription operation binding the contract event 0x7243aab3c75cebfd96dc41ece7762eb023fc8c81e9ba2ce1d487876419b918b5.
//
// Solidity: event UseNonce(address searcher, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) WatchUseNonce(opts *bind.WatchOpts, sink chan<- *IAuctionEntryPointUseNonce) (event.Subscription, error) {

	logs, sub, err := _IAuctionEntryPoint.contract.WatchLogs(opts, "UseNonce")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAuctionEntryPointUseNonce)
				if err := _IAuctionEntryPoint.contract.UnpackLog(event, "UseNonce", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUseNonce is a log parse operation binding the contract event 0x7243aab3c75cebfd96dc41ece7762eb023fc8c81e9ba2ce1d487876419b918b5.
//
// Solidity: event UseNonce(address searcher, uint256 nonce)
func (_IAuctionEntryPoint *IAuctionEntryPointFilterer) ParseUseNonce(log types.Log) (*IAuctionEntryPointUseNonce, error) {
	event := new(IAuctionEntryPointUseNonce)
	if err := _IAuctionEntryPoint.contract.UnpackLog(event, "UseNonce", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC5267MetaData contains all meta data concerning the IERC5267 contract.
var IERC5267MetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"84b0196e": "eip712Domain()",
	},
}

// IERC5267ABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC5267MetaData.ABI instead.
var IERC5267ABI = IERC5267MetaData.ABI

// IERC5267BinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IERC5267BinRuntime = ``

// Deprecated: Use IERC5267MetaData.Sigs instead.
// IERC5267FuncSigs maps the 4-byte function signature to its string representation.
var IERC5267FuncSigs = IERC5267MetaData.Sigs

// IERC5267 is an auto generated Go binding around a Kaia contract.
type IERC5267 struct {
	IERC5267Caller     // Read-only binding to the contract
	IERC5267Transactor // Write-only binding to the contract
	IERC5267Filterer   // Log filterer for contract events
}

// IERC5267Caller is an auto generated read-only Go binding around a Kaia contract.
type IERC5267Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC5267Transactor is an auto generated write-only Go binding around a Kaia contract.
type IERC5267Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC5267Filterer is an auto generated log filtering Go binding around a Kaia contract events.
type IERC5267Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC5267Session is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type IERC5267Session struct {
	Contract     *IERC5267         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC5267CallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type IERC5267CallerSession struct {
	Contract *IERC5267Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// IERC5267TransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type IERC5267TransactorSession struct {
	Contract     *IERC5267Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// IERC5267Raw is an auto generated low-level Go binding around a Kaia contract.
type IERC5267Raw struct {
	Contract *IERC5267 // Generic contract binding to access the raw methods on
}

// IERC5267CallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type IERC5267CallerRaw struct {
	Contract *IERC5267Caller // Generic read-only contract binding to access the raw methods on
}

// IERC5267TransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type IERC5267TransactorRaw struct {
	Contract *IERC5267Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC5267 creates a new instance of IERC5267, bound to a specific deployed contract.
func NewIERC5267(address common.Address, backend bind.ContractBackend) (*IERC5267, error) {
	contract, err := bindIERC5267(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC5267{IERC5267Caller: IERC5267Caller{contract: contract}, IERC5267Transactor: IERC5267Transactor{contract: contract}, IERC5267Filterer: IERC5267Filterer{contract: contract}}, nil
}

// NewIERC5267Caller creates a new read-only instance of IERC5267, bound to a specific deployed contract.
func NewIERC5267Caller(address common.Address, caller bind.ContractCaller) (*IERC5267Caller, error) {
	contract, err := bindIERC5267(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC5267Caller{contract: contract}, nil
}

// NewIERC5267Transactor creates a new write-only instance of IERC5267, bound to a specific deployed contract.
func NewIERC5267Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC5267Transactor, error) {
	contract, err := bindIERC5267(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC5267Transactor{contract: contract}, nil
}

// NewIERC5267Filterer creates a new log filterer instance of IERC5267, bound to a specific deployed contract.
func NewIERC5267Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC5267Filterer, error) {
	contract, err := bindIERC5267(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC5267Filterer{contract: contract}, nil
}

// bindIERC5267 binds a generic wrapper to an already deployed contract.
func bindIERC5267(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC5267MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC5267 *IERC5267Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC5267.Contract.IERC5267Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC5267 *IERC5267Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC5267.Contract.IERC5267Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC5267 *IERC5267Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC5267.Contract.IERC5267Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC5267 *IERC5267CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC5267.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC5267 *IERC5267TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC5267.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC5267 *IERC5267TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC5267.Contract.contract.Transact(opts, method, params...)
}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_IERC5267 *IERC5267Caller) Eip712Domain(opts *bind.CallOpts) (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	var out []interface{}
	err := _IERC5267.contract.Call(opts, &out, "eip712Domain")

	outstruct := new(struct {
		Fields            [1]byte
		Name              string
		Version           string
		ChainId           *big.Int
		VerifyingContract common.Address
		Salt              [32]byte
		Extensions        []*big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Fields = *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)
	outstruct.Name = *abi.ConvertType(out[1], new(string)).(*string)
	outstruct.Version = *abi.ConvertType(out[2], new(string)).(*string)
	outstruct.ChainId = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.VerifyingContract = *abi.ConvertType(out[4], new(common.Address)).(*common.Address)
	outstruct.Salt = *abi.ConvertType(out[5], new([32]byte)).(*[32]byte)
	outstruct.Extensions = *abi.ConvertType(out[6], new([]*big.Int)).(*[]*big.Int)

	return *outstruct, err

}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_IERC5267 *IERC5267Session) Eip712Domain() (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	return _IERC5267.Contract.Eip712Domain(&_IERC5267.CallOpts)
}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_IERC5267 *IERC5267CallerSession) Eip712Domain() (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	return _IERC5267.Contract.Eip712Domain(&_IERC5267.CallOpts)
}

// IERC5267EIP712DomainChangedIterator is returned from FilterEIP712DomainChanged and is used to iterate over the raw logs and unpacked data for EIP712DomainChanged events raised by the IERC5267 contract.
type IERC5267EIP712DomainChangedIterator struct {
	Event *IERC5267EIP712DomainChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC5267EIP712DomainChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC5267EIP712DomainChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC5267EIP712DomainChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC5267EIP712DomainChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC5267EIP712DomainChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC5267EIP712DomainChanged represents a EIP712DomainChanged event raised by the IERC5267 contract.
type IERC5267EIP712DomainChanged struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterEIP712DomainChanged is a free log retrieval operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_IERC5267 *IERC5267Filterer) FilterEIP712DomainChanged(opts *bind.FilterOpts) (*IERC5267EIP712DomainChangedIterator, error) {

	logs, sub, err := _IERC5267.contract.FilterLogs(opts, "EIP712DomainChanged")
	if err != nil {
		return nil, err
	}
	return &IERC5267EIP712DomainChangedIterator{contract: _IERC5267.contract, event: "EIP712DomainChanged", logs: logs, sub: sub}, nil
}

// WatchEIP712DomainChanged is a free log subscription operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_IERC5267 *IERC5267Filterer) WatchEIP712DomainChanged(opts *bind.WatchOpts, sink chan<- *IERC5267EIP712DomainChanged) (event.Subscription, error) {

	logs, sub, err := _IERC5267.contract.WatchLogs(opts, "EIP712DomainChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC5267EIP712DomainChanged)
				if err := _IERC5267.contract.UnpackLog(event, "EIP712DomainChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEIP712DomainChanged is a log parse operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_IERC5267 *IERC5267Filterer) ParseEIP712DomainChanged(log types.Log) (*IERC5267EIP712DomainChanged, error) {
	event := new(IERC5267EIP712DomainChanged)
	if err := _IERC5267.contract.UnpackLog(event, "EIP712DomainChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MathMetaData contains all meta data concerning the Math contract.
var MathMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"MathOverflowedMulDiv\",\"type\":\"error\"}]",
	Bin: "0x60556032600b8282823980515f1a607314602657634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f80fdfea2646970667358221220712f35b86f21aa8557926c5f616fc23eca3635f3385ba733c156f4e283869c7064736f6c63430008190033",
}

// MathABI is the input ABI used to generate the binding from.
// Deprecated: Use MathMetaData.ABI instead.
var MathABI = MathMetaData.ABI

// MathBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const MathBinRuntime = `730000000000000000000000000000000000000000301460806040525f80fdfea2646970667358221220712f35b86f21aa8557926c5f616fc23eca3635f3385ba733c156f4e283869c7064736f6c63430008190033`

// MathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MathMetaData.Bin instead.
var MathBin = MathMetaData.Bin

// DeployMath deploys a new Kaia contract, binding an instance of Math to it.
func DeployMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Math, error) {
	parsed, err := MathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Math{MathCaller: MathCaller{contract: contract}, MathTransactor: MathTransactor{contract: contract}, MathFilterer: MathFilterer{contract: contract}}, nil
}

// Math is an auto generated Go binding around a Kaia contract.
type Math struct {
	MathCaller     // Read-only binding to the contract
	MathTransactor // Write-only binding to the contract
	MathFilterer   // Log filterer for contract events
}

// MathCaller is an auto generated read-only Go binding around a Kaia contract.
type MathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MathTransactor is an auto generated write-only Go binding around a Kaia contract.
type MathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MathFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type MathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MathSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type MathSession struct {
	Contract     *Math             // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MathCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type MathCallerSession struct {
	Contract *MathCaller   // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// MathTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type MathTransactorSession struct {
	Contract     *MathTransactor   // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MathRaw is an auto generated low-level Go binding around a Kaia contract.
type MathRaw struct {
	Contract *Math // Generic contract binding to access the raw methods on
}

// MathCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type MathCallerRaw struct {
	Contract *MathCaller // Generic read-only contract binding to access the raw methods on
}

// MathTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type MathTransactorRaw struct {
	Contract *MathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMath creates a new instance of Math, bound to a specific deployed contract.
func NewMath(address common.Address, backend bind.ContractBackend) (*Math, error) {
	contract, err := bindMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Math{MathCaller: MathCaller{contract: contract}, MathTransactor: MathTransactor{contract: contract}, MathFilterer: MathFilterer{contract: contract}}, nil
}

// NewMathCaller creates a new read-only instance of Math, bound to a specific deployed contract.
func NewMathCaller(address common.Address, caller bind.ContractCaller) (*MathCaller, error) {
	contract, err := bindMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MathCaller{contract: contract}, nil
}

// NewMathTransactor creates a new write-only instance of Math, bound to a specific deployed contract.
func NewMathTransactor(address common.Address, transactor bind.ContractTransactor) (*MathTransactor, error) {
	contract, err := bindMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MathTransactor{contract: contract}, nil
}

// NewMathFilterer creates a new log filterer instance of Math, bound to a specific deployed contract.
func NewMathFilterer(address common.Address, filterer bind.ContractFilterer) (*MathFilterer, error) {
	contract, err := bindMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MathFilterer{contract: contract}, nil
}

// bindMath binds a generic wrapper to an already deployed contract.
func bindMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Math *MathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Math.Contract.MathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Math *MathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Math.Contract.MathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Math *MathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Math.Contract.MathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Math *MathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Math.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Math *MathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Math.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Math *MathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Math.Contract.contract.Transact(opts, method, params...)
}

// MessageHashUtilsMetaData contains all meta data concerning the MessageHashUtils contract.
var MessageHashUtilsMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x60556032600b8282823980515f1a607314602657634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f80fdfea26469706673582212209e6fb9100e1402906dc6a46e888327a4ecf91c80abad06087f9d053a425888fb64736f6c63430008190033",
}

// MessageHashUtilsABI is the input ABI used to generate the binding from.
// Deprecated: Use MessageHashUtilsMetaData.ABI instead.
var MessageHashUtilsABI = MessageHashUtilsMetaData.ABI

// MessageHashUtilsBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const MessageHashUtilsBinRuntime = `730000000000000000000000000000000000000000301460806040525f80fdfea26469706673582212209e6fb9100e1402906dc6a46e888327a4ecf91c80abad06087f9d053a425888fb64736f6c63430008190033`

// MessageHashUtilsBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MessageHashUtilsMetaData.Bin instead.
var MessageHashUtilsBin = MessageHashUtilsMetaData.Bin

// DeployMessageHashUtils deploys a new Kaia contract, binding an instance of MessageHashUtils to it.
func DeployMessageHashUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MessageHashUtils, error) {
	parsed, err := MessageHashUtilsMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MessageHashUtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MessageHashUtils{MessageHashUtilsCaller: MessageHashUtilsCaller{contract: contract}, MessageHashUtilsTransactor: MessageHashUtilsTransactor{contract: contract}, MessageHashUtilsFilterer: MessageHashUtilsFilterer{contract: contract}}, nil
}

// MessageHashUtils is an auto generated Go binding around a Kaia contract.
type MessageHashUtils struct {
	MessageHashUtilsCaller     // Read-only binding to the contract
	MessageHashUtilsTransactor // Write-only binding to the contract
	MessageHashUtilsFilterer   // Log filterer for contract events
}

// MessageHashUtilsCaller is an auto generated read-only Go binding around a Kaia contract.
type MessageHashUtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageHashUtilsTransactor is an auto generated write-only Go binding around a Kaia contract.
type MessageHashUtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageHashUtilsFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type MessageHashUtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageHashUtilsSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type MessageHashUtilsSession struct {
	Contract     *MessageHashUtils // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MessageHashUtilsCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type MessageHashUtilsCallerSession struct {
	Contract *MessageHashUtilsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// MessageHashUtilsTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type MessageHashUtilsTransactorSession struct {
	Contract     *MessageHashUtilsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// MessageHashUtilsRaw is an auto generated low-level Go binding around a Kaia contract.
type MessageHashUtilsRaw struct {
	Contract *MessageHashUtils // Generic contract binding to access the raw methods on
}

// MessageHashUtilsCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type MessageHashUtilsCallerRaw struct {
	Contract *MessageHashUtilsCaller // Generic read-only contract binding to access the raw methods on
}

// MessageHashUtilsTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type MessageHashUtilsTransactorRaw struct {
	Contract *MessageHashUtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessageHashUtils creates a new instance of MessageHashUtils, bound to a specific deployed contract.
func NewMessageHashUtils(address common.Address, backend bind.ContractBackend) (*MessageHashUtils, error) {
	contract, err := bindMessageHashUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessageHashUtils{MessageHashUtilsCaller: MessageHashUtilsCaller{contract: contract}, MessageHashUtilsTransactor: MessageHashUtilsTransactor{contract: contract}, MessageHashUtilsFilterer: MessageHashUtilsFilterer{contract: contract}}, nil
}

// NewMessageHashUtilsCaller creates a new read-only instance of MessageHashUtils, bound to a specific deployed contract.
func NewMessageHashUtilsCaller(address common.Address, caller bind.ContractCaller) (*MessageHashUtilsCaller, error) {
	contract, err := bindMessageHashUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessageHashUtilsCaller{contract: contract}, nil
}

// NewMessageHashUtilsTransactor creates a new write-only instance of MessageHashUtils, bound to a specific deployed contract.
func NewMessageHashUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*MessageHashUtilsTransactor, error) {
	contract, err := bindMessageHashUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessageHashUtilsTransactor{contract: contract}, nil
}

// NewMessageHashUtilsFilterer creates a new log filterer instance of MessageHashUtils, bound to a specific deployed contract.
func NewMessageHashUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*MessageHashUtilsFilterer, error) {
	contract, err := bindMessageHashUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessageHashUtilsFilterer{contract: contract}, nil
}

// bindMessageHashUtils binds a generic wrapper to an already deployed contract.
func bindMessageHashUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessageHashUtilsMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageHashUtils *MessageHashUtilsRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageHashUtils.Contract.MessageHashUtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageHashUtils *MessageHashUtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageHashUtils.Contract.MessageHashUtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageHashUtils *MessageHashUtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageHashUtils.Contract.MessageHashUtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageHashUtils *MessageHashUtilsCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageHashUtils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageHashUtils *MessageHashUtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageHashUtils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageHashUtils *MessageHashUtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageHashUtils.Contract.contract.Transact(opts, method, params...)
}

// NoncesMetaData contains all meta data concerning the Nonces contract.
var NoncesMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentNonce\",\"type\":\"uint256\"}],\"name\":\"InvalidAccountNonce\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"7ecebe00": "nonces(address)",
	},
}

// NoncesABI is the input ABI used to generate the binding from.
// Deprecated: Use NoncesMetaData.ABI instead.
var NoncesABI = NoncesMetaData.ABI

// NoncesBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const NoncesBinRuntime = ``

// Deprecated: Use NoncesMetaData.Sigs instead.
// NoncesFuncSigs maps the 4-byte function signature to its string representation.
var NoncesFuncSigs = NoncesMetaData.Sigs

// Nonces is an auto generated Go binding around a Kaia contract.
type Nonces struct {
	NoncesCaller     // Read-only binding to the contract
	NoncesTransactor // Write-only binding to the contract
	NoncesFilterer   // Log filterer for contract events
}

// NoncesCaller is an auto generated read-only Go binding around a Kaia contract.
type NoncesCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NoncesTransactor is an auto generated write-only Go binding around a Kaia contract.
type NoncesTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NoncesFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type NoncesFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NoncesSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type NoncesSession struct {
	Contract     *Nonces           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// NoncesCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type NoncesCallerSession struct {
	Contract *NoncesCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// NoncesTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type NoncesTransactorSession struct {
	Contract     *NoncesTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// NoncesRaw is an auto generated low-level Go binding around a Kaia contract.
type NoncesRaw struct {
	Contract *Nonces // Generic contract binding to access the raw methods on
}

// NoncesCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type NoncesCallerRaw struct {
	Contract *NoncesCaller // Generic read-only contract binding to access the raw methods on
}

// NoncesTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type NoncesTransactorRaw struct {
	Contract *NoncesTransactor // Generic write-only contract binding to access the raw methods on
}

// NewNonces creates a new instance of Nonces, bound to a specific deployed contract.
func NewNonces(address common.Address, backend bind.ContractBackend) (*Nonces, error) {
	contract, err := bindNonces(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Nonces{NoncesCaller: NoncesCaller{contract: contract}, NoncesTransactor: NoncesTransactor{contract: contract}, NoncesFilterer: NoncesFilterer{contract: contract}}, nil
}

// NewNoncesCaller creates a new read-only instance of Nonces, bound to a specific deployed contract.
func NewNoncesCaller(address common.Address, caller bind.ContractCaller) (*NoncesCaller, error) {
	contract, err := bindNonces(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &NoncesCaller{contract: contract}, nil
}

// NewNoncesTransactor creates a new write-only instance of Nonces, bound to a specific deployed contract.
func NewNoncesTransactor(address common.Address, transactor bind.ContractTransactor) (*NoncesTransactor, error) {
	contract, err := bindNonces(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &NoncesTransactor{contract: contract}, nil
}

// NewNoncesFilterer creates a new log filterer instance of Nonces, bound to a specific deployed contract.
func NewNoncesFilterer(address common.Address, filterer bind.ContractFilterer) (*NoncesFilterer, error) {
	contract, err := bindNonces(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &NoncesFilterer{contract: contract}, nil
}

// bindNonces binds a generic wrapper to an already deployed contract.
func bindNonces(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := NoncesMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Nonces *NoncesRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Nonces.Contract.NoncesCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Nonces *NoncesRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Nonces.Contract.NoncesTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Nonces *NoncesRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Nonces.Contract.NoncesTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Nonces *NoncesCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Nonces.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Nonces *NoncesTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Nonces.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Nonces *NoncesTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Nonces.Contract.contract.Transact(opts, method, params...)
}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_Nonces *NoncesCaller) Nonces(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _Nonces.contract.Call(opts, &out, "nonces", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_Nonces *NoncesSession) Nonces(owner common.Address) (*big.Int, error) {
	return _Nonces.Contract.Nonces(&_Nonces.CallOpts, owner)
}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_Nonces *NoncesCallerSession) Nonces(owner common.Address) (*big.Int, error) {
	return _Nonces.Contract.Nonces(&_Nonces.CallOpts, owner)
}

// OwnableMetaData contains all meta data concerning the Ownable contract.
var OwnableMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"8da5cb5b": "owner()",
		"715018a6": "renounceOwnership()",
		"f2fde38b": "transferOwnership(address)",
	},
}

// OwnableABI is the input ABI used to generate the binding from.
// Deprecated: Use OwnableMetaData.ABI instead.
var OwnableABI = OwnableMetaData.ABI

// OwnableBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const OwnableBinRuntime = ``

// Deprecated: Use OwnableMetaData.Sigs instead.
// OwnableFuncSigs maps the 4-byte function signature to its string representation.
var OwnableFuncSigs = OwnableMetaData.Sigs

// Ownable is an auto generated Go binding around a Kaia contract.
type Ownable struct {
	OwnableCaller     // Read-only binding to the contract
	OwnableTransactor // Write-only binding to the contract
	OwnableFilterer   // Log filterer for contract events
}

// OwnableCaller is an auto generated read-only Go binding around a Kaia contract.
type OwnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableTransactor is an auto generated write-only Go binding around a Kaia contract.
type OwnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type OwnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type OwnableSession struct {
	Contract     *Ownable          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnableCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type OwnableCallerSession struct {
	Contract *OwnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// OwnableTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type OwnableTransactorSession struct {
	Contract     *OwnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// OwnableRaw is an auto generated low-level Go binding around a Kaia contract.
type OwnableRaw struct {
	Contract *Ownable // Generic contract binding to access the raw methods on
}

// OwnableCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type OwnableCallerRaw struct {
	Contract *OwnableCaller // Generic read-only contract binding to access the raw methods on
}

// OwnableTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type OwnableTransactorRaw struct {
	Contract *OwnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOwnable creates a new instance of Ownable, bound to a specific deployed contract.
func NewOwnable(address common.Address, backend bind.ContractBackend) (*Ownable, error) {
	contract, err := bindOwnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Ownable{OwnableCaller: OwnableCaller{contract: contract}, OwnableTransactor: OwnableTransactor{contract: contract}, OwnableFilterer: OwnableFilterer{contract: contract}}, nil
}

// NewOwnableCaller creates a new read-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableCaller(address common.Address, caller bind.ContractCaller) (*OwnableCaller, error) {
	contract, err := bindOwnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableCaller{contract: contract}, nil
}

// NewOwnableTransactor creates a new write-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableTransactor(address common.Address, transactor bind.ContractTransactor) (*OwnableTransactor, error) {
	contract, err := bindOwnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableTransactor{contract: contract}, nil
}

// NewOwnableFilterer creates a new log filterer instance of Ownable, bound to a specific deployed contract.
func NewOwnableFilterer(address common.Address, filterer bind.ContractFilterer) (*OwnableFilterer, error) {
	contract, err := bindOwnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OwnableFilterer{contract: contract}, nil
}

// bindOwnable binds a generic wrapper to an already deployed contract.
func bindOwnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := OwnableMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.OwnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transact(opts, method, params...)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Ownable.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCallerSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// OwnableOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Ownable contract.
type OwnableOwnershipTransferredIterator struct {
	Event *OwnableOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log    // Log channel receiving the found contract events
	sub  kaia.Subscription // Subscription for errors, completion and termination
	done bool              // Whether the subscription completed delivering logs
	fail error             // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OwnableOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OwnableOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OwnableOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OwnableOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OwnableOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OwnableOwnershipTransferred represents a OwnershipTransferred event raised by the Ownable contract.
type OwnableOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OwnableOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OwnableOwnershipTransferredIterator{contract: _Ownable.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OwnableOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OwnableOwnershipTransferred)
				if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) ParseOwnershipTransferred(log types.Log) (*OwnableOwnershipTransferred, error) {
	event := new(OwnableOwnershipTransferred)
	if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ShortStringsMetaData contains all meta data concerning the ShortStrings contract.
var ShortStringsMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"}]",
	Bin: "0x60556032600b8282823980515f1a607314602657634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f80fdfea264697066735822122032046995b092f0239713c38c7d4143d4ba3098ccd6a437c7b81f9b48c476da5f64736f6c63430008190033",
}

// ShortStringsABI is the input ABI used to generate the binding from.
// Deprecated: Use ShortStringsMetaData.ABI instead.
var ShortStringsABI = ShortStringsMetaData.ABI

// ShortStringsBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ShortStringsBinRuntime = `730000000000000000000000000000000000000000301460806040525f80fdfea264697066735822122032046995b092f0239713c38c7d4143d4ba3098ccd6a437c7b81f9b48c476da5f64736f6c63430008190033`

// ShortStringsBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ShortStringsMetaData.Bin instead.
var ShortStringsBin = ShortStringsMetaData.Bin

// DeployShortStrings deploys a new Kaia contract, binding an instance of ShortStrings to it.
func DeployShortStrings(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ShortStrings, error) {
	parsed, err := ShortStringsMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ShortStringsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ShortStrings{ShortStringsCaller: ShortStringsCaller{contract: contract}, ShortStringsTransactor: ShortStringsTransactor{contract: contract}, ShortStringsFilterer: ShortStringsFilterer{contract: contract}}, nil
}

// ShortStrings is an auto generated Go binding around a Kaia contract.
type ShortStrings struct {
	ShortStringsCaller     // Read-only binding to the contract
	ShortStringsTransactor // Write-only binding to the contract
	ShortStringsFilterer   // Log filterer for contract events
}

// ShortStringsCaller is an auto generated read-only Go binding around a Kaia contract.
type ShortStringsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ShortStringsTransactor is an auto generated write-only Go binding around a Kaia contract.
type ShortStringsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ShortStringsFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type ShortStringsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ShortStringsSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type ShortStringsSession struct {
	Contract     *ShortStrings     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ShortStringsCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type ShortStringsCallerSession struct {
	Contract *ShortStringsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// ShortStringsTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type ShortStringsTransactorSession struct {
	Contract     *ShortStringsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// ShortStringsRaw is an auto generated low-level Go binding around a Kaia contract.
type ShortStringsRaw struct {
	Contract *ShortStrings // Generic contract binding to access the raw methods on
}

// ShortStringsCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type ShortStringsCallerRaw struct {
	Contract *ShortStringsCaller // Generic read-only contract binding to access the raw methods on
}

// ShortStringsTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type ShortStringsTransactorRaw struct {
	Contract *ShortStringsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewShortStrings creates a new instance of ShortStrings, bound to a specific deployed contract.
func NewShortStrings(address common.Address, backend bind.ContractBackend) (*ShortStrings, error) {
	contract, err := bindShortStrings(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ShortStrings{ShortStringsCaller: ShortStringsCaller{contract: contract}, ShortStringsTransactor: ShortStringsTransactor{contract: contract}, ShortStringsFilterer: ShortStringsFilterer{contract: contract}}, nil
}

// NewShortStringsCaller creates a new read-only instance of ShortStrings, bound to a specific deployed contract.
func NewShortStringsCaller(address common.Address, caller bind.ContractCaller) (*ShortStringsCaller, error) {
	contract, err := bindShortStrings(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ShortStringsCaller{contract: contract}, nil
}

// NewShortStringsTransactor creates a new write-only instance of ShortStrings, bound to a specific deployed contract.
func NewShortStringsTransactor(address common.Address, transactor bind.ContractTransactor) (*ShortStringsTransactor, error) {
	contract, err := bindShortStrings(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ShortStringsTransactor{contract: contract}, nil
}

// NewShortStringsFilterer creates a new log filterer instance of ShortStrings, bound to a specific deployed contract.
func NewShortStringsFilterer(address common.Address, filterer bind.ContractFilterer) (*ShortStringsFilterer, error) {
	contract, err := bindShortStrings(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ShortStringsFilterer{contract: contract}, nil
}

// bindShortStrings binds a generic wrapper to an already deployed contract.
func bindShortStrings(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ShortStringsMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ShortStrings *ShortStringsRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ShortStrings.Contract.ShortStringsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ShortStrings *ShortStringsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ShortStrings.Contract.ShortStringsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ShortStrings *ShortStringsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ShortStrings.Contract.ShortStringsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ShortStrings *ShortStringsCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ShortStrings.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ShortStrings *ShortStringsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ShortStrings.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ShortStrings *ShortStringsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ShortStrings.Contract.contract.Transact(opts, method, params...)
}

// SignedMathMetaData contains all meta data concerning the SignedMath contract.
var SignedMathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x60556032600b8282823980515f1a607314602657634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f80fdfea26469706673582212201b9cdc614fb1d761db9d22a5ea624c704e13b84d686c6c5d0745ea711905981864736f6c63430008190033",
}

// SignedMathABI is the input ABI used to generate the binding from.
// Deprecated: Use SignedMathMetaData.ABI instead.
var SignedMathABI = SignedMathMetaData.ABI

// SignedMathBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const SignedMathBinRuntime = `730000000000000000000000000000000000000000301460806040525f80fdfea26469706673582212201b9cdc614fb1d761db9d22a5ea624c704e13b84d686c6c5d0745ea711905981864736f6c63430008190033`

// SignedMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SignedMathMetaData.Bin instead.
var SignedMathBin = SignedMathMetaData.Bin

// DeploySignedMath deploys a new Kaia contract, binding an instance of SignedMath to it.
func DeploySignedMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SignedMath, error) {
	parsed, err := SignedMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SignedMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SignedMath{SignedMathCaller: SignedMathCaller{contract: contract}, SignedMathTransactor: SignedMathTransactor{contract: contract}, SignedMathFilterer: SignedMathFilterer{contract: contract}}, nil
}

// SignedMath is an auto generated Go binding around a Kaia contract.
type SignedMath struct {
	SignedMathCaller     // Read-only binding to the contract
	SignedMathTransactor // Write-only binding to the contract
	SignedMathFilterer   // Log filterer for contract events
}

// SignedMathCaller is an auto generated read-only Go binding around a Kaia contract.
type SignedMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SignedMathTransactor is an auto generated write-only Go binding around a Kaia contract.
type SignedMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SignedMathFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type SignedMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SignedMathSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type SignedMathSession struct {
	Contract     *SignedMath       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SignedMathCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type SignedMathCallerSession struct {
	Contract *SignedMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// SignedMathTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type SignedMathTransactorSession struct {
	Contract     *SignedMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// SignedMathRaw is an auto generated low-level Go binding around a Kaia contract.
type SignedMathRaw struct {
	Contract *SignedMath // Generic contract binding to access the raw methods on
}

// SignedMathCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type SignedMathCallerRaw struct {
	Contract *SignedMathCaller // Generic read-only contract binding to access the raw methods on
}

// SignedMathTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type SignedMathTransactorRaw struct {
	Contract *SignedMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSignedMath creates a new instance of SignedMath, bound to a specific deployed contract.
func NewSignedMath(address common.Address, backend bind.ContractBackend) (*SignedMath, error) {
	contract, err := bindSignedMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SignedMath{SignedMathCaller: SignedMathCaller{contract: contract}, SignedMathTransactor: SignedMathTransactor{contract: contract}, SignedMathFilterer: SignedMathFilterer{contract: contract}}, nil
}

// NewSignedMathCaller creates a new read-only instance of SignedMath, bound to a specific deployed contract.
func NewSignedMathCaller(address common.Address, caller bind.ContractCaller) (*SignedMathCaller, error) {
	contract, err := bindSignedMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SignedMathCaller{contract: contract}, nil
}

// NewSignedMathTransactor creates a new write-only instance of SignedMath, bound to a specific deployed contract.
func NewSignedMathTransactor(address common.Address, transactor bind.ContractTransactor) (*SignedMathTransactor, error) {
	contract, err := bindSignedMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SignedMathTransactor{contract: contract}, nil
}

// NewSignedMathFilterer creates a new log filterer instance of SignedMath, bound to a specific deployed contract.
func NewSignedMathFilterer(address common.Address, filterer bind.ContractFilterer) (*SignedMathFilterer, error) {
	contract, err := bindSignedMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SignedMathFilterer{contract: contract}, nil
}

// bindSignedMath binds a generic wrapper to an already deployed contract.
func bindSignedMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SignedMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SignedMath *SignedMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SignedMath.Contract.SignedMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SignedMath *SignedMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SignedMath.Contract.SignedMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SignedMath *SignedMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SignedMath.Contract.SignedMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SignedMath *SignedMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SignedMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SignedMath *SignedMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SignedMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SignedMath *SignedMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SignedMath.Contract.contract.Transact(opts, method, params...)
}

// StorageSlotMetaData contains all meta data concerning the StorageSlot contract.
var StorageSlotMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x60556032600b8282823980515f1a607314602657634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f80fdfea2646970667358221220eb4a80bee1ba9c696e13f334518c78004b52f1b72f76d392fc592a7e545ecef864736f6c63430008190033",
}

// StorageSlotABI is the input ABI used to generate the binding from.
// Deprecated: Use StorageSlotMetaData.ABI instead.
var StorageSlotABI = StorageSlotMetaData.ABI

// StorageSlotBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const StorageSlotBinRuntime = `730000000000000000000000000000000000000000301460806040525f80fdfea2646970667358221220eb4a80bee1ba9c696e13f334518c78004b52f1b72f76d392fc592a7e545ecef864736f6c63430008190033`

// StorageSlotBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use StorageSlotMetaData.Bin instead.
var StorageSlotBin = StorageSlotMetaData.Bin

// DeployStorageSlot deploys a new Kaia contract, binding an instance of StorageSlot to it.
func DeployStorageSlot(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *StorageSlot, error) {
	parsed, err := StorageSlotMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(StorageSlotBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &StorageSlot{StorageSlotCaller: StorageSlotCaller{contract: contract}, StorageSlotTransactor: StorageSlotTransactor{contract: contract}, StorageSlotFilterer: StorageSlotFilterer{contract: contract}}, nil
}

// StorageSlot is an auto generated Go binding around a Kaia contract.
type StorageSlot struct {
	StorageSlotCaller     // Read-only binding to the contract
	StorageSlotTransactor // Write-only binding to the contract
	StorageSlotFilterer   // Log filterer for contract events
}

// StorageSlotCaller is an auto generated read-only Go binding around a Kaia contract.
type StorageSlotCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StorageSlotTransactor is an auto generated write-only Go binding around a Kaia contract.
type StorageSlotTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StorageSlotFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type StorageSlotFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StorageSlotSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type StorageSlotSession struct {
	Contract     *StorageSlot      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StorageSlotCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type StorageSlotCallerSession struct {
	Contract *StorageSlotCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// StorageSlotTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type StorageSlotTransactorSession struct {
	Contract     *StorageSlotTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// StorageSlotRaw is an auto generated low-level Go binding around a Kaia contract.
type StorageSlotRaw struct {
	Contract *StorageSlot // Generic contract binding to access the raw methods on
}

// StorageSlotCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type StorageSlotCallerRaw struct {
	Contract *StorageSlotCaller // Generic read-only contract binding to access the raw methods on
}

// StorageSlotTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type StorageSlotTransactorRaw struct {
	Contract *StorageSlotTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStorageSlot creates a new instance of StorageSlot, bound to a specific deployed contract.
func NewStorageSlot(address common.Address, backend bind.ContractBackend) (*StorageSlot, error) {
	contract, err := bindStorageSlot(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &StorageSlot{StorageSlotCaller: StorageSlotCaller{contract: contract}, StorageSlotTransactor: StorageSlotTransactor{contract: contract}, StorageSlotFilterer: StorageSlotFilterer{contract: contract}}, nil
}

// NewStorageSlotCaller creates a new read-only instance of StorageSlot, bound to a specific deployed contract.
func NewStorageSlotCaller(address common.Address, caller bind.ContractCaller) (*StorageSlotCaller, error) {
	contract, err := bindStorageSlot(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StorageSlotCaller{contract: contract}, nil
}

// NewStorageSlotTransactor creates a new write-only instance of StorageSlot, bound to a specific deployed contract.
func NewStorageSlotTransactor(address common.Address, transactor bind.ContractTransactor) (*StorageSlotTransactor, error) {
	contract, err := bindStorageSlot(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StorageSlotTransactor{contract: contract}, nil
}

// NewStorageSlotFilterer creates a new log filterer instance of StorageSlot, bound to a specific deployed contract.
func NewStorageSlotFilterer(address common.Address, filterer bind.ContractFilterer) (*StorageSlotFilterer, error) {
	contract, err := bindStorageSlot(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StorageSlotFilterer{contract: contract}, nil
}

// bindStorageSlot binds a generic wrapper to an already deployed contract.
func bindStorageSlot(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := StorageSlotMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_StorageSlot *StorageSlotRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _StorageSlot.Contract.StorageSlotCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_StorageSlot *StorageSlotRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _StorageSlot.Contract.StorageSlotTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_StorageSlot *StorageSlotRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _StorageSlot.Contract.StorageSlotTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_StorageSlot *StorageSlotCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _StorageSlot.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_StorageSlot *StorageSlotTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _StorageSlot.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_StorageSlot *StorageSlotTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _StorageSlot.Contract.contract.Transact(opts, method, params...)
}

// StringsMetaData contains all meta data concerning the Strings contract.
var StringsMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"StringsInsufficientHexLength\",\"type\":\"error\"}]",
	Bin: "0x60556032600b8282823980515f1a607314602657634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f80fdfea2646970667358221220891bac40fd7e292785f3019d2c6f384c9e95bc42e26afee90b150dfb5b603e3864736f6c63430008190033",
}

// StringsABI is the input ABI used to generate the binding from.
// Deprecated: Use StringsMetaData.ABI instead.
var StringsABI = StringsMetaData.ABI

// StringsBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const StringsBinRuntime = `730000000000000000000000000000000000000000301460806040525f80fdfea2646970667358221220891bac40fd7e292785f3019d2c6f384c9e95bc42e26afee90b150dfb5b603e3864736f6c63430008190033`

// StringsBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use StringsMetaData.Bin instead.
var StringsBin = StringsMetaData.Bin

// DeployStrings deploys a new Kaia contract, binding an instance of Strings to it.
func DeployStrings(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Strings, error) {
	parsed, err := StringsMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(StringsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Strings{StringsCaller: StringsCaller{contract: contract}, StringsTransactor: StringsTransactor{contract: contract}, StringsFilterer: StringsFilterer{contract: contract}}, nil
}

// Strings is an auto generated Go binding around a Kaia contract.
type Strings struct {
	StringsCaller     // Read-only binding to the contract
	StringsTransactor // Write-only binding to the contract
	StringsFilterer   // Log filterer for contract events
}

// StringsCaller is an auto generated read-only Go binding around a Kaia contract.
type StringsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsTransactor is an auto generated write-only Go binding around a Kaia contract.
type StringsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsFilterer is an auto generated log filtering Go binding around a Kaia contract events.
type StringsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsSession is an auto generated Go binding around a Kaia contract,
// with pre-set call and transact options.
type StringsSession struct {
	Contract     *Strings          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StringsCallerSession is an auto generated read-only Go binding around a Kaia contract,
// with pre-set call options.
type StringsCallerSession struct {
	Contract *StringsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// StringsTransactorSession is an auto generated write-only Go binding around a Kaia contract,
// with pre-set transact options.
type StringsTransactorSession struct {
	Contract     *StringsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// StringsRaw is an auto generated low-level Go binding around a Kaia contract.
type StringsRaw struct {
	Contract *Strings // Generic contract binding to access the raw methods on
}

// StringsCallerRaw is an auto generated low-level read-only Go binding around a Kaia contract.
type StringsCallerRaw struct {
	Contract *StringsCaller // Generic read-only contract binding to access the raw methods on
}

// StringsTransactorRaw is an auto generated low-level write-only Go binding around a Kaia contract.
type StringsTransactorRaw struct {
	Contract *StringsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStrings creates a new instance of Strings, bound to a specific deployed contract.
func NewStrings(address common.Address, backend bind.ContractBackend) (*Strings, error) {
	contract, err := bindStrings(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Strings{StringsCaller: StringsCaller{contract: contract}, StringsTransactor: StringsTransactor{contract: contract}, StringsFilterer: StringsFilterer{contract: contract}}, nil
}

// NewStringsCaller creates a new read-only instance of Strings, bound to a specific deployed contract.
func NewStringsCaller(address common.Address, caller bind.ContractCaller) (*StringsCaller, error) {
	contract, err := bindStrings(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StringsCaller{contract: contract}, nil
}

// NewStringsTransactor creates a new write-only instance of Strings, bound to a specific deployed contract.
func NewStringsTransactor(address common.Address, transactor bind.ContractTransactor) (*StringsTransactor, error) {
	contract, err := bindStrings(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StringsTransactor{contract: contract}, nil
}

// NewStringsFilterer creates a new log filterer instance of Strings, bound to a specific deployed contract.
func NewStringsFilterer(address common.Address, filterer bind.ContractFilterer) (*StringsFilterer, error) {
	contract, err := bindStrings(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StringsFilterer{contract: contract}, nil
}

// bindStrings binds a generic wrapper to an already deployed contract.
func bindStrings(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := StringsMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Strings *StringsRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Strings.Contract.StringsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Strings *StringsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Strings.Contract.StringsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Strings *StringsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Strings.Contract.StringsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Strings *StringsCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Strings.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Strings *StringsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Strings.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Strings *StringsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Strings.Contract.contract.Transact(opts, method, params...)
}
